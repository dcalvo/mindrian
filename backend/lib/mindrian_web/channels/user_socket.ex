defmodule MindrianWeb.UserSocket do
  @moduledoc """
  WebSocket handler with token-based authentication.

  All channels require authentication. Connections without a valid token are rejected.
  The token is generated by `GET /api/me` and passed by the frontend when connecting.

  ## Creating New Channels

  All channels are authenticated by default. `socket.assigns.user_id` is always available:

      defmodule MindrianWeb.MyChannel do
        use MindrianWeb, :channel

        def join("my_topic:" <> id, _payload, socket) do
          # socket.assigns.user_id is guaranteed to exist
          {:ok, socket}
        end
      end

  For authorization (e.g., user can only access their own resources):

      def join("documents:" <> user_id, _payload, socket) do
        if to_string(socket.assigns.user_id) == user_id do
          {:ok, socket}
        else
          {:error, %{reason: "forbidden"}}
        end
      end

  Then register the channel here:

      channel "my_topic:*", MindrianWeb.MyChannel
  """
  use Phoenix.Socket

  channel "ping:*", MindrianWeb.PingChannel
  channel "y_doc:*", MindrianWeb.YDocChannel
  channel "documents:*", MindrianWeb.DocumentsChannel
  channel "presence:*", MindrianWeb.PresenceChannel

  # Token valid for 2 weeks (same as session token)
  @max_age 86400 * 14

  @impl true
  def connect(%{"token" => token}, socket, _connect_info) do
    case Phoenix.Token.verify(socket, "user socket", token, max_age: @max_age) do
      {:ok, user_id} ->
        {:ok, assign(socket, :user_id, user_id)}

      {:error, _reason} ->
        :error
    end
  end

  def connect(_params, _socket, _connect_info), do: :error

  @impl true
  def id(socket) do
    if socket.assigns[:user_id] do
      "user_socket:#{socket.assigns.user_id}"
    end
  end
end
