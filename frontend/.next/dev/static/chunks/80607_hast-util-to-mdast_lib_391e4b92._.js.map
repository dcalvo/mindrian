{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/a.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link}\n *   mdast node.\n */\nexport function a(state, node) {\n  const properties = node.properties || {}\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    url: state.resolve(String(properties.href || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,EAAE,KAAK,EAAE,IAAI;IAC3B,MAAM,aAAa,KAAK,UAAU,IAAI,CAAC;IACvC,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD,MAAM,GAAG,CAAC;IAElE,iBAAiB,GACjB,MAAM,SAAS;QACb,MAAM;QACN,KAAK,MAAM,OAAO,CAAC,OAAO,WAAW,IAAI,IAAI,OAAO;QACpD,OAAO,WAAW,KAAK,GAAG,OAAO,WAAW,KAAK,IAAI;QACrD;IACF;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/base.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {undefined}\n *   Nothing.\n */\nexport function base(state, node) {\n  if (!state.baseFound) {\n    state.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || undefined\n    state.baseFound = true\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;;;CAOC;;;;AACM,SAAS,KAAK,KAAK,EAAE,IAAI;IAC9B,IAAI,CAAC,MAAM,SAAS,EAAE;QACpB,MAAM,aAAa,GACjB,OAAO,AAAC,KAAK,UAAU,IAAI,KAAK,UAAU,CAAC,IAAI,IAAK,OAAO;QAC7D,MAAM,SAAS,GAAG;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/blockquote.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Blockquote} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Blockquote}\n *   mdast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Blockquote} */\n  const result = {type: 'blockquote', children: state.toFlow(state.all(node))}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,WAAW,KAAK,EAAE,IAAI;IACpC,uBAAuB,GACvB,MAAM,SAAS;QAAC,MAAM;QAAc,UAAU,MAAM,MAAM,CAAC,MAAM,GAAG,CAAC;IAAM;IAC3E,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/br.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Break} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Break}\n *   mdast node.\n */\nexport function br(state, node) {\n  /** @type {Break} */\n  const result = {type: 'break'}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,GAAG,KAAK,EAAE,IAAI;IAC5B,kBAAkB,GAClB,MAAM,SAAS;QAAC,MAAM;IAAO;IAC7B,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/code.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Code} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\n\nconst prefix = 'language-'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Code}\n *   mdast node.\n */\nexport function code(state, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<number | string> | undefined} */\n  let classList\n  /** @type {string | undefined} */\n  let lang\n\n  if (node.tagName === 'pre') {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        child.type === 'element' &&\n        child.tagName === 'code' &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  /** @type {Code} */\n  const result = {\n    type: 'code',\n    lang: lang || null,\n    meta: null,\n    value: trimTrailingLines(toText(node))\n  }\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;AACA;;;AAEA,MAAM,SAAS;AAUR,SAAS,KAAK,KAAK,EAAE,IAAI;IAC9B,MAAM,WAAW,KAAK,QAAQ;IAC9B,IAAI,QAAQ,CAAC;IACb,+CAA+C,GAC/C,IAAI;IACJ,+BAA+B,GAC/B,IAAI;IAEJ,IAAI,KAAK,OAAO,KAAK,OAAO;QAC1B,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;YAChC,MAAM,QAAQ,QAAQ,CAAC,MAAM;YAE7B,IACE,MAAM,IAAI,KAAK,aACf,MAAM,OAAO,KAAK,UAClB,MAAM,UAAU,IAChB,MAAM,UAAU,CAAC,SAAS,IAC1B,MAAM,OAAO,CAAC,MAAM,UAAU,CAAC,SAAS,GACxC;gBACA,YAAY,MAAM,UAAU,CAAC,SAAS;gBACtC;YACF;QACF;IACF;IAEA,IAAI,WAAW;QACb,QAAQ,CAAC;QAET,MAAO,EAAE,QAAQ,UAAU,MAAM,CAAE;YACjC,IAAI,OAAO,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,OAAO,MAAM,MAAM,QAAQ;gBAC/D,OAAO,OAAO,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,OAAO,MAAM;gBACnD;YACF;QACF;IACF;IAEA,iBAAiB,GACjB,MAAM,SAAS;QACb,MAAM;QACN,MAAM,QAAQ;QACd,MAAM;QACN,OAAO,IAAA,iSAAiB,EAAC,IAAA,+RAAM,EAAC;IAClC;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/comment.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Comment} from 'hast'\n * @import {Html} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Comment>} node\n *   hast element to transform.\n * @returns {Html}\n *   mdast node.\n */\nexport function comment(state, node) {\n  /** @type {Html} */\n  const result = {\n    type: 'html',\n    value: '<!--' + node.value + '-->'\n  }\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,QAAQ,KAAK,EAAE,IAAI;IACjC,iBAAiB,GACjB,MAAM,SAAS;QACb,MAAM;QACN,OAAO,SAAS,KAAK,KAAK,GAAG;IAC/B;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/del.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Delete, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Delete}\n *   mdast node.\n */\nexport function del(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n  /** @type {Delete} */\n  const result = {type: 'delete', children}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,IAAI,KAAK,EAAE,IAAI;IAC7B,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD,MAAM,GAAG,CAAC;IAClE,mBAAmB,GACnB,MAAM,SAAS;QAAC,MAAM;QAAU;IAAQ;IACxC,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/util/list-items-spread.js"],"sourcesContent":["/**\n * @import {ListContent} from 'mdast'\n */\n\n/**\n * Infer whether list items are spread.\n *\n * @param {Readonly<Array<Readonly<ListContent>>>} children\n *   List items.\n * @returns {boolean}\n *   Whether one or more list items are spread.\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;;CAOC;;;;AACM,SAAS,gBAAgB,QAAQ;IACtC,IAAI,QAAQ,CAAC;IAEb,IAAI,SAAS,MAAM,GAAG,GAAG;QACvB,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;YAChC,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;gBAC1B,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/dl.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {ElementContent, Element} from 'hast'\n * @import {BlockContent, DefinitionContent, ListContent, ListItem, List} from 'mdast'\n */\n\n/**\n * @typedef Group\n *   Title/definition group.\n * @property {Array<Element>} titles\n *   One or more titles.\n * @property {Array<ElementContent>} definitions\n *   One or more definitions.\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List | undefined}\n *   mdast node.\n */\nexport function dl(state, node) {\n  /** @type {Array<ElementContent>} */\n  const clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  let index = -1\n\n  // Unwrap `<div>`s\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'div') {\n      clean.push(...child.children)\n    } else {\n      clean.push(child)\n    }\n  }\n\n  /** @type {Group} */\n  let group = {definitions: [], titles: []}\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    const child = clean[index]\n\n    if (child.type === 'element' && child.tagName === 'dt') {\n      const previous = clean[index - 1]\n\n      if (\n        previous &&\n        previous.type === 'element' &&\n        previous.tagName === 'dd'\n      ) {\n        groups.push(group)\n        group = {definitions: [], titles: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<ListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    const result = [\n      ...handle(state, groups[index].titles),\n      ...handle(state, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    /** @type {List} */\n    const result = {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(content),\n      children: content\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Array<ElementContent>} children\n *   hast element children to transform.\n * @returns {Array<BlockContent | DefinitionContent>}\n *   mdast nodes.\n */\nfunction handle(state, children) {\n  const nodes = state.all({type: 'root', children})\n  const listItems = state.toSpecificContent(nodes, create)\n\n  if (listItems.length === 0) {\n    return []\n  }\n\n  if (listItems.length === 1) {\n    return listItems[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(listItems),\n      children: listItems\n    }\n  ]\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AAED;;AAUO,SAAS,GAAG,KAAK,EAAE,IAAI;IAC5B,kCAAkC,GAClC,MAAM,QAAQ,EAAE;IAChB,yBAAyB,GACzB,MAAM,SAAS,EAAE;IACjB,IAAI,QAAQ,CAAC;IAEb,kBAAkB;IAClB,MAAO,EAAE,QAAQ,KAAK,QAAQ,CAAC,MAAM,CAAE;QACrC,MAAM,QAAQ,KAAK,QAAQ,CAAC,MAAM;QAElC,IAAI,MAAM,IAAI,KAAK,aAAa,MAAM,OAAO,KAAK,OAAO;YACvD,MAAM,IAAI,IAAI,MAAM,QAAQ;QAC9B,OAAO;YACL,MAAM,IAAI,CAAC;QACb;IACF;IAEA,kBAAkB,GAClB,IAAI,QAAQ;QAAC,aAAa,EAAE;QAAE,QAAQ,EAAE;IAAA;IACxC,QAAQ,CAAC;IAET,gCAAgC;IAChC,MAAO,EAAE,QAAQ,MAAM,MAAM,CAAE;QAC7B,MAAM,QAAQ,KAAK,CAAC,MAAM;QAE1B,IAAI,MAAM,IAAI,KAAK,aAAa,MAAM,OAAO,KAAK,MAAM;YACtD,MAAM,WAAW,KAAK,CAAC,QAAQ,EAAE;YAEjC,IACE,YACA,SAAS,IAAI,KAAK,aAClB,SAAS,OAAO,KAAK,MACrB;gBACA,OAAO,IAAI,CAAC;gBACZ,QAAQ;oBAAC,aAAa,EAAE;oBAAE,QAAQ,EAAE;gBAAA;YACtC;YAEA,MAAM,MAAM,CAAC,IAAI,CAAC;QACpB,OAAO;YACL,MAAM,WAAW,CAAC,IAAI,CAAC;QACzB;IACF;IAEA,OAAO,IAAI,CAAC;IAEZ,gBAAgB;IAChB,QAAQ,CAAC;IACT,+BAA+B,GAC/B,MAAM,UAAU,EAAE;IAElB,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;QAC9B,MAAM,SAAS;eACV,OAAO,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM;eAClC,OAAO,OAAO,MAAM,CAAC,MAAM,CAAC,WAAW;SAC3C;QAED,IAAI,OAAO,MAAM,GAAG,GAAG;YACrB,QAAQ,IAAI,CAAC;gBACX,MAAM;gBACN,QAAQ,OAAO,MAAM,GAAG;gBACxB,SAAS;gBACT,UAAU;YACZ;QACF;IACF;IAEA,oCAAoC;IACpC,IAAI,QAAQ,MAAM,GAAG,GAAG;QACtB,iBAAiB,GACjB,MAAM,SAAS;YACb,MAAM;YACN,SAAS;YACT,OAAO;YACP,QAAQ,IAAA,qUAAe,EAAC;YACxB,UAAU;QACZ;QACA,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF;AAEA;;;;;;;CAOC,GACD,SAAS,OAAO,KAAK,EAAE,QAAQ;IAC7B,MAAM,QAAQ,MAAM,GAAG,CAAC;QAAC,MAAM;QAAQ;IAAQ;IAC/C,MAAM,YAAY,MAAM,iBAAiB,CAAC,OAAO;IAEjD,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,OAAO,EAAE;IACX;IAEA,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,OAAO,SAAS,CAAC,EAAE,CAAC,QAAQ;IAC9B;IAEA,OAAO;QACL;YACE,MAAM;YACN,SAAS;YACT,OAAO;YACP,QAAQ,IAAA,qUAAe,EAAC;YACxB,UAAU;QACZ;KACD;AACH;AAEA;;CAEC,GACD,SAAS;IACP,OAAO;QAAC,MAAM;QAAY,QAAQ;QAAO,SAAS;QAAM,UAAU,EAAE;IAAA;AACtE","ignoreList":[0]}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/em.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Emphasis, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Emphasis}\n *   mdast node.\n */\nexport function em(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Emphasis} */\n  const result = {type: 'emphasis', children}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,GAAG,KAAK,EAAE,IAAI;IAC5B,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD,MAAM,GAAG,CAAC;IAElE,qBAAqB,GACrB,MAAM,SAAS;QAAC,MAAM;QAAY;IAAQ;IAC1C,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js"],"sourcesContent":["/**\n * @import {Nodes} from 'mdast'\n */\n\n/**\n * Drop trailing initial and final `br`s.\n *\n * @template {Nodes} Node\n *   Node type.\n * @param {Array<Node>} nodes\n *   List of nodes.\n * @returns {Array<Node>}\n *   List of nodes w/o `break`s.\n */\nexport function dropSurroundingBreaks(nodes) {\n  let start = 0\n  let end = nodes.length\n\n  while (start < end && nodes[start].type === 'break') start++\n  while (end > start && nodes[end - 1].type === 'break') end--\n\n  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end)\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;;;;CASC;;;;AACM,SAAS,sBAAsB,KAAK;IACzC,IAAI,QAAQ;IACZ,IAAI,MAAM,MAAM,MAAM;IAEtB,MAAO,QAAQ,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,KAAK,QAAS;IACrD,MAAO,MAAM,SAAS,KAAK,CAAC,MAAM,EAAE,CAAC,IAAI,KAAK,QAAS;IAEvD,OAAO,UAAU,KAAK,QAAQ,MAAM,MAAM,GAAG,QAAQ,MAAM,KAAK,CAAC,OAAO;AAC1E","ignoreList":[0]}},
    {"offset": {"line": 430, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/heading.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Heading, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Heading}\n *   mdast node.\n */\nexport function heading(state, node) {\n  const depth = /** @type {Heading['depth']} */ (\n    /* c8 ignore next */\n    Number(node.tagName.charAt(1)) || 1\n  )\n  const children = dropSurroundingBreaks(\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  /** @type {Heading} */\n  const result = {type: 'heading', depth, children}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,QAAQ,KAAK,EAAE,IAAI;IACjC,MAAM,QACJ,kBAAkB,GAClB,OAAO,KAAK,OAAO,CAAC,MAAM,CAAC,OAAO;IAEpC,MAAM,WAAW,IAAA,iVAAqB,EACG,MAAM,GAAG,CAAC;IAGnD,oBAAoB,GACpB,MAAM,SAAS;QAAC,MAAM;QAAW;QAAO;IAAQ;IAChD,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 455, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/hr.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ThematicBreak} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ThematicBreak}\n *   mdast node.\n */\nexport function hr(state, node) {\n  /** @type {ThematicBreak} */\n  const result = {type: 'thematicBreak'}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,GAAG,KAAK,EAAE,IAAI;IAC5B,0BAA0B,GAC1B,MAAM,SAAS;QAAC,MAAM;IAAe;IACrC,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/iframe.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link | undefined}\n *   mdast node.\n */\nexport function iframe(state, node) {\n  const properties = node.properties || {}\n  const source = String(properties.src || '')\n  const title = String(properties.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (source && title) {\n    /** @type {Link} */\n    const result = {\n      type: 'link',\n      title: null,\n      url: state.resolve(source),\n      children: [{type: 'text', value: title}]\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,OAAO,KAAK,EAAE,IAAI;IAChC,MAAM,aAAa,KAAK,UAAU,IAAI,CAAC;IACvC,MAAM,SAAS,OAAO,WAAW,GAAG,IAAI;IACxC,MAAM,QAAQ,OAAO,WAAW,KAAK,IAAI;IAEzC,0CAA0C;IAC1C,8EAA8E;IAC9E,yEAAyE;IACzE,0CAA0C;IAC1C,IAAI,UAAU,OAAO;QACnB,iBAAiB,GACjB,MAAM,SAAS;YACb,MAAM;YACN,OAAO;YACP,KAAK,MAAM,OAAO,CAAC;YACnB,UAAU;gBAAC;oBAAC,MAAM;oBAAQ,OAAO;gBAAK;aAAE;QAC1C;QACA,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 524, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/img.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Image}\n *   mdast node.\n */\nexport function img(state, node) {\n  const properties = node.properties || {}\n\n  /** @type {Image} */\n  const result = {\n    type: 'image',\n    url: state.resolve(String(properties.src || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    alt: properties.alt ? String(properties.alt) : ''\n  }\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,IAAI,KAAK,EAAE,IAAI;IAC7B,MAAM,aAAa,KAAK,UAAU,IAAI,CAAC;IAEvC,kBAAkB,GAClB,MAAM,SAAS;QACb,MAAM;QACN,KAAK,MAAM,OAAO,CAAC,OAAO,WAAW,GAAG,IAAI,OAAO;QACnD,OAAO,WAAW,KAAK,GAAG,OAAO,WAAW,KAAK,IAAI;QACrD,KAAK,WAAW,GAAG,GAAG,OAAO,WAAW,GAAG,IAAI;IACjD;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/inline-code.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {InlineCode} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {InlineCode}\n *   mdast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {InlineCode} */\n  const result = {type: 'inlineCode', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,WAAW,KAAK,EAAE,IAAI;IACpC,uBAAuB,GACvB,MAAM,SAAS;QAAC,MAAM;QAAc,OAAO,IAAA,+RAAM,EAAC;IAAK;IACvD,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 576, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/util/find-selected-options.js"],"sourcesContent":["/**\n * @import {Element, Properties} from 'hast'\n */\n\n/**\n * @typedef {[string, Value]} Option\n *   Option, where the item at `0` is the label, the item at `1` the value.\n *\n * @typedef {Array<Option>} Options\n *   List of options.\n *\n * @typedef {string | undefined} Value\n *   `value` field of option.\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {Readonly<Element>} node\n *   hast element to inspect.\n * @param {Properties | undefined} [explicitProperties]\n *   Properties to use, normally taken from `node`, but can be changed.\n * @returns {Options}\n *   Options.\n */\nexport function findSelectedOptions(node, explicitProperties) {\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Options} */\n  const values = []\n  const properties = explicitProperties || node.properties || {}\n  const options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(properties.size), 10), 0) ||\n    (properties.multiple ? 4 : 1)\n  let index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n\n    if (option && option.properties && option.properties.selected) {\n      selectedOptions.push(option)\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  const max = Math.min(list.length, size)\n  index = -1\n\n  while (++index < max) {\n    const option = list[index]\n    const properties = option.properties || {}\n    const content = toText(option)\n    const label = content || String(properties.label || '')\n    const value = String(properties.value || '') || content\n    values.push([value, label === value ? undefined : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Element} node\n *   Parent to find in.\n * @returns {Array<Element>}\n *   Option elements.\n */\nfunction findOptions(node) {\n  /** @type {Array<Element>} */\n  const results = []\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if ('children' in child && Array.isArray(child.children)) {\n      results.push(...findOptions(child))\n    }\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'option' &&\n      (!child.properties || !child.properties.disabled)\n    ) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;;;;CASC;;;;AAED;;AAUO,SAAS,oBAAoB,IAAI,EAAE,kBAAkB;IAC1D,2BAA2B,GAC3B,MAAM,kBAAkB,EAAE;IAC1B,oBAAoB,GACpB,MAAM,SAAS,EAAE;IACjB,MAAM,aAAa,sBAAsB,KAAK,UAAU,IAAI,CAAC;IAC7D,MAAM,UAAU,YAAY;IAC5B,MAAM,OACJ,KAAK,GAAG,CAAC,OAAO,QAAQ,CAAC,OAAO,WAAW,IAAI,GAAG,KAAK,MACvD,CAAC,WAAW,QAAQ,GAAG,IAAI,CAAC;IAC9B,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,QAAQ,MAAM,CAAE;QAC/B,MAAM,SAAS,OAAO,CAAC,MAAM;QAE7B,IAAI,UAAU,OAAO,UAAU,IAAI,OAAO,UAAU,CAAC,QAAQ,EAAE;YAC7D,gBAAgB,IAAI,CAAC;QACvB;IACF;IAEA,MAAM,OAAO,gBAAgB,MAAM,GAAG,IAAI,kBAAkB;IAC5D,MAAM,MAAM,KAAK,GAAG,CAAC,KAAK,MAAM,EAAE;IAClC,QAAQ,CAAC;IAET,MAAO,EAAE,QAAQ,IAAK;QACpB,MAAM,SAAS,IAAI,CAAC,MAAM;QAC1B,MAAM,aAAa,OAAO,UAAU,IAAI,CAAC;QACzC,MAAM,UAAU,IAAA,+RAAM,EAAC;QACvB,MAAM,QAAQ,WAAW,OAAO,WAAW,KAAK,IAAI;QACpD,MAAM,QAAQ,OAAO,WAAW,KAAK,IAAI,OAAO;QAChD,OAAO,IAAI,CAAC;YAAC;YAAO,UAAU,QAAQ,YAAY;SAAM;IAC1D;IAEA,OAAO;AACT;AAEA;;;;;CAKC,GACD,SAAS,YAAY,IAAI;IACvB,2BAA2B,GAC3B,MAAM,UAAU,EAAE;IAClB,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,KAAK,QAAQ,CAAC,MAAM,CAAE;QACrC,MAAM,QAAQ,KAAK,QAAQ,CAAC,MAAM;QAElC,IAAI,cAAc,SAAS,MAAM,OAAO,CAAC,MAAM,QAAQ,GAAG;YACxD,QAAQ,IAAI,IAAI,YAAY;QAC9B;QAEA,IACE,MAAM,IAAI,KAAK,aACf,MAAM,OAAO,KAAK,YAClB,CAAC,CAAC,MAAM,UAAU,IAAI,CAAC,MAAM,UAAU,CAAC,QAAQ,GAChD;YACA,QAAQ,IAAI,CAAC;QACf;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 645, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/input.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, Text} from 'mdast'\n * @import {Options} from '../util/find-selected-options.js'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\nconst defaultChecked = '[x]'\nconst defaultUnchecked = '[ ]'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<Link | Text> | Image | Text | undefined}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function input(state, node) {\n  const properties = node.properties || {}\n  const value = String(properties.value || properties.placeholder || '')\n\n  if (\n    properties.disabled ||\n    properties.type === 'hidden' ||\n    properties.type === 'file'\n  ) {\n    return\n  }\n\n  if (properties.type === 'checkbox' || properties.type === 'radio') {\n    /** @type {Text} */\n    const result = {\n      type: 'text',\n      value: properties.checked\n        ? state.options.checked || defaultChecked\n        : state.options.unchecked || defaultUnchecked\n    }\n    state.patch(node, result)\n    return result\n  }\n\n  if (properties.type === 'image') {\n    const alt = properties.alt || value\n\n    if (alt) {\n      /** @type {Image} */\n      const result = {\n        type: 'image',\n        url: state.resolve(String(properties.src || '') || null),\n        title: String(properties.title || '') || null,\n        alt: String(alt)\n      }\n      state.patch(node, result)\n      return result\n    }\n\n    return\n  }\n\n  /** @type {Options} */\n  let values = []\n\n  if (value) {\n    values = [[value, undefined]]\n  } else if (\n    // `list` is not supported on these types:\n    properties.type !== 'button' &&\n    properties.type !== 'file' &&\n    properties.type !== 'password' &&\n    properties.type !== 'reset' &&\n    properties.type !== 'submit' &&\n    properties.list\n  ) {\n    const list = String(properties.list)\n    const datalist = state.elementById.get(list)\n\n    if (datalist && datalist.tagName === 'datalist') {\n      values = findSelectedOptions(datalist, properties)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (properties.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), undefined]\n  }\n\n  if (properties.type === 'email' || properties.type === 'url') {\n    /** @type {Array<Link | Text>} */\n    const results = []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = state.resolve(values[index][0])\n      /** @type {Link} */\n      const result = {\n        type: 'link',\n        title: null,\n        url: properties.type === 'email' ? 'mailto:' + value : value,\n        children: [{type: 'text', value: values[index][1] || value}]\n      }\n\n      results.push(result)\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  /** @type {Array<string>} */\n  const texts = []\n  let index = -1\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  /** @type {Text} */\n  const result = {type: 'text', value: texts.join(', ')}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/li.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem} from 'mdast'\n */\n\n/**\n * @typedef ExtractResult\n *   Result of extracting a leading checkbox.\n * @property {Element | undefined} checkbox\n *   The checkbox that was removed, if any.\n * @property {Element} rest\n *   If there was a leading checkbox, a deep clone of the node w/o the leading\n *   checkbox; otherwise a reference to the given, untouched, node.\n */\n\nimport {phrasing} from 'hast-util-phrasing'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ListItem}\n *   mdast node.\n */\nexport function li(state, node) {\n  // If the list item starts with a checkbox, remove the checkbox and mark the\n  // list item as a GFM task list item.\n  const {rest, checkbox} = extractLeadingCheckbox(node)\n  const checked = checkbox ? Boolean(checkbox.properties.checked) : null\n  const spread = spreadout(rest)\n  const children = state.toFlow(state.all(rest))\n\n  /** @type {ListItem} */\n  const result = {type: 'listItem', spread, checked, children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Check if an element should spread out.\n *\n * The reason to spread out a markdown list item is primarily whether writing\n * the equivalent in markdown, would yield a spread out item.\n *\n * A spread out item results in `<p>` and `</p>` tags.\n * Otherwise, the phrasing would be output directly.\n * We can check for that: if there’s a `<p>` element, spread it out.\n *\n * But what if there are no paragraphs?\n * In that case, we can also assume that if two “block” things were written in\n * an item, that it is spread out, because blocks are typically joined by blank\n * lines, which also means a spread item.\n *\n * Lastly, because in HTML things can be wrapped in a `<div>` or similar, we\n * delve into non-phrasing elements here to figure out if they themselves\n * contain paragraphs or 2 or more flow non-phrasing elements.\n *\n * @param {Readonly<Element>} node\n * @returns {boolean}\n */\nfunction spreadout(node) {\n  let index = -1\n  let seenFlow = false\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element') {\n      if (phrasing(child)) continue\n\n      if (child.tagName === 'p' || seenFlow || spreadout(child)) {\n        return true\n      }\n\n      seenFlow = true\n    }\n  }\n\n  return false\n}\n\n/**\n * Extract a leading checkbox from a list item.\n *\n * If there was a leading checkbox, makes a deep clone of the node w/o the\n * leading checkbox; otherwise a reference to the given, untouched, node is\n * given back.\n *\n * So for example:\n *\n * ```html\n * <li><input type=\"checkbox\">Text</li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li>Text</li>\n * ```\n *\n * ```html\n * <li><p><input type=\"checkbox\">Text</p></li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li><p>Text</p></li>\n * ```\n *\n * @param {Readonly<Element>} node\n * @returns {ExtractResult}\n */\nfunction extractLeadingCheckbox(node) {\n  const head = node.children[0]\n\n  if (\n    head &&\n    head.type === 'element' &&\n    head.tagName === 'input' &&\n    head.properties &&\n    (head.properties.type === 'checkbox' || head.properties.type === 'radio')\n  ) {\n    const rest = {...node, children: node.children.slice(1)}\n    return {checkbox: head, rest}\n  }\n\n  // The checkbox may be nested in another element.\n  // If the first element has children, look for a leading checkbox inside it.\n  //\n  // This only handles nesting in `<p>` elements, which is most common.\n  // It’s possible a leading checkbox might be nested in other types of flow or\n  // phrasing elements (and *deeply* nested, which is not possible with `<p>`).\n  // Limiting things to `<p>` elements keeps this simpler for now.\n  if (head && head.type === 'element' && head.tagName === 'p') {\n    const {checkbox, rest: restHead} = extractLeadingCheckbox(head)\n\n    if (checkbox) {\n      const rest = {...node, children: [restHead, ...node.children.slice(1)]}\n      return {checkbox, rest}\n    }\n  }\n\n  return {checkbox: undefined, rest: node}\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;;CAQC;;;;AAED;;AAUO,SAAS,GAAG,KAAK,EAAE,IAAI;IAC5B,4EAA4E;IAC5E,qCAAqC;IACrC,MAAM,EAAC,IAAI,EAAE,QAAQ,EAAC,GAAG,uBAAuB;IAChD,MAAM,UAAU,WAAW,QAAQ,SAAS,UAAU,CAAC,OAAO,IAAI;IAClE,MAAM,SAAS,UAAU;IACzB,MAAM,WAAW,MAAM,MAAM,CAAC,MAAM,GAAG,CAAC;IAExC,qBAAqB,GACrB,MAAM,SAAS;QAAC,MAAM;QAAY;QAAQ;QAAS;IAAQ;IAC3D,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;CAqBC,GACD,SAAS,UAAU,IAAI;IACrB,IAAI,QAAQ,CAAC;IACb,IAAI,WAAW;IAEf,MAAO,EAAE,QAAQ,KAAK,QAAQ,CAAC,MAAM,CAAE;QACrC,MAAM,QAAQ,KAAK,QAAQ,CAAC,MAAM;QAElC,IAAI,MAAM,IAAI,KAAK,WAAW;YAC5B,IAAI,IAAA,6RAAQ,EAAC,QAAQ;YAErB,IAAI,MAAM,OAAO,KAAK,OAAO,YAAY,UAAU,QAAQ;gBACzD,OAAO;YACT;YAEA,WAAW;QACb;IACF;IAEA,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BC,GACD,SAAS,uBAAuB,IAAI;IAClC,MAAM,OAAO,KAAK,QAAQ,CAAC,EAAE;IAE7B,IACE,QACA,KAAK,IAAI,KAAK,aACd,KAAK,OAAO,KAAK,WACjB,KAAK,UAAU,IACf,CAAC,KAAK,UAAU,CAAC,IAAI,KAAK,cAAc,KAAK,UAAU,CAAC,IAAI,KAAK,OAAO,GACxE;QACA,MAAM,OAAO;YAAC,GAAG,IAAI;YAAE,UAAU,KAAK,QAAQ,CAAC,KAAK,CAAC;QAAE;QACvD,OAAO;YAAC,UAAU;YAAM;QAAI;IAC9B;IAEA,iDAAiD;IACjD,4EAA4E;IAC5E,EAAE;IACF,qEAAqE;IACrE,6EAA6E;IAC7E,6EAA6E;IAC7E,gEAAgE;IAChE,IAAI,QAAQ,KAAK,IAAI,KAAK,aAAa,KAAK,OAAO,KAAK,KAAK;QAC3D,MAAM,EAAC,QAAQ,EAAE,MAAM,QAAQ,EAAC,GAAG,uBAAuB;QAE1D,IAAI,UAAU;YACZ,MAAM,OAAO;gBAAC,GAAG,IAAI;gBAAE,UAAU;oBAAC;uBAAa,KAAK,QAAQ,CAAC,KAAK,CAAC;iBAAG;YAAA;YACtE,OAAO;gBAAC;gBAAU;YAAI;QACxB;IACF;IAEA,OAAO;QAAC,UAAU;QAAW,MAAM;IAAI;AACzC","ignoreList":[0]}},
    {"offset": {"line": 900, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/list.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem, List} from 'mdast'\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List}\n *   mdast node.\n */\nexport function list(state, node) {\n  const ordered = node.tagName === 'ol'\n  const children = state.toSpecificContent(state.all(node), create)\n  /** @type {number | null} */\n  let start = null\n\n  if (ordered) {\n    start =\n      node.properties && node.properties.start\n        ? Number.parseInt(String(node.properties.start), 10)\n        : 1\n  }\n\n  /** @type {List} */\n  const result = {\n    type: 'list',\n    ordered,\n    start,\n    spread: listItemsSpread(children),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,KAAK,KAAK,EAAE,IAAI;IAC9B,MAAM,UAAU,KAAK,OAAO,KAAK;IACjC,MAAM,WAAW,MAAM,iBAAiB,CAAC,MAAM,GAAG,CAAC,OAAO;IAC1D,0BAA0B,GAC1B,IAAI,QAAQ;IAEZ,IAAI,SAAS;QACX,QACE,KAAK,UAAU,IAAI,KAAK,UAAU,CAAC,KAAK,GACpC,OAAO,QAAQ,CAAC,OAAO,KAAK,UAAU,CAAC,KAAK,GAAG,MAC/C;IACR;IAEA,iBAAiB,GACjB,MAAM,SAAS;QACb,MAAM;QACN;QACA;QACA,QAAQ,IAAA,qUAAe,EAAC;QACxB;IACF;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT;AAEA;;CAEC,GACD,SAAS;IACP,OAAO;QAAC,MAAM;QAAY,QAAQ;QAAO,SAAS;QAAM,UAAU,EAAE;IAAA;AACtE","ignoreList":[0]}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/util/wrap.js"],"sourcesContent":["/**\n * @import {} from 'mdast-util-to-hast'\n * @import {\n *   BlockContent,\n *   Delete,\n *   Link,\n *   Nodes,\n *   Paragraph,\n *   Parents,\n *   PhrasingContent,\n *   RootContent\n * } from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\nimport {dropSurroundingBreaks} from './drop-surrounding-breaks.js'\n\n/**\n * Check if there are phrasing mdast nodes.\n *\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<Nodes>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap runs of phrasing content into paragraphs, leaving the non-phrasing\n * content as-is.\n *\n * @param {Array<RootContent>} nodes\n *   Content.\n * @returns {Array<BlockContent>}\n *   Content where phrasing is wrapped in paragraphs.\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing, function (d) {\n    return d\n  })\n\n  /**\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<Paragraph>}\n   */\n  function onphrasing(nodes) {\n    return nodes.every(function (d) {\n      return d.type === 'text' ? whitespace(d.value) : false\n    })\n      ? []\n      : [{type: 'paragraph', children: dropSurroundingBreaks(nodes)}]\n  }\n}\n\n/**\n * @param {Delete | Link} node\n * @returns {Array<BlockContent>}\n */\nfunction split(node) {\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<BlockContent>}\n   */\n  function onphrasing(nodes) {\n    const newParent = cloneWithoutChildren(node)\n    newParent.children = nodes\n    // @ts-expect-error Assume fine.\n    return [newParent]\n  }\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {BlockContent} child\n   * @returns {BlockContent}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const newParent = cloneWithoutChildren(node)\n      const newChild = cloneWithoutChildren(child)\n      // @ts-expect-error Assume fine.\n      newParent.children = child.children\n      // @ts-expect-error Assume fine.\n      newChild.children.push(newParent)\n      return newChild\n    }\n\n    return {...child}\n  }\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of input nodes.\n * @param {(nodes: Array<PhrasingContent>) => Array<BlockContent>} onphrasing\n *   Turn phrasing content into block content.\n * @param {(node: BlockContent) => BlockContent} onnonphrasing\n *   Map block content (defaults to keeping them as-is).\n * @returns {Array<BlockContent>}\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const flattened = flatten(nodes)\n  /** @type {Array<BlockContent>} */\n  const result = []\n  /** @type {Array<PhrasingContent>} */\n  let queue = []\n  let index = -1\n\n  while (++index < flattened.length) {\n    const node = flattened[index]\n\n    if (phrasing(node)) {\n      queue.push(node)\n    } else {\n      if (queue.length > 0) {\n        result.push(...onphrasing(queue))\n        queue = []\n      }\n\n      // @ts-expect-error Assume non-phrasing.\n      result.push(onnonphrasing(node))\n    }\n  }\n\n  if (queue.length > 0) {\n    result.push(...onphrasing(queue))\n    queue = []\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of nodes, will unravel `delete` and `link`.\n * @returns {Array<RootContent>}\n *   Unraveled nodes.\n */\nfunction flatten(nodes) {\n  /** @type {Array<RootContent>} */\n  const flattened = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened.push(...split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {Nodes} node\n *   mdast node to check.\n * @returns {node is PhrasingContent}\n *   Whether `node` is phrasing content (includes nodes with `hName` fields\n *   set to phrasing hast element names).\n */\nfunction phrasing(node) {\n  const tagName = node.data && node.data.hName\n  return tagName\n    ? hastPhrasing({type: 'element', tagName, properties: {}, children: []})\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {Parents} ParentType\n *   Parent type.\n * @param {ParentType} node\n *   Node to clone.\n * @returns {ParentType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return structuredClone({...node, children: []})\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/media.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, PhrasingContent, RootContent as MdastRootContent, Root} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {EXIT, visit} from 'unist-util-visit'\nimport {wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent> | Link}\n *   mdast node.\n */\nexport function media(state, node) {\n  const properties = node.properties || {}\n  const poster = node.tagName === 'video' ? String(properties.poster || '') : ''\n  let source = String(properties.src || '')\n  let index = -1\n  let linkInFallbackContent = false\n  let nodes = state.all(node)\n\n  /** @type {Root} */\n  const fragment = {type: 'root', children: nodes}\n\n  visit(fragment, function (node) {\n    if (node.type === 'link') {\n      linkInFallbackContent = true\n      return EXIT\n    }\n  })\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!source && ++index < node.children.length) {\n    const child = node.children[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'source' &&\n      child.properties\n    ) {\n      source = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    /** @type {Image} */\n    const image = {\n      type: 'image',\n      title: null,\n      url: state.resolve(poster),\n      alt: toString(nodes)\n    }\n    state.patch(node, image)\n    nodes = [image]\n  }\n\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (nodes)\n\n  // Link to the media resource.\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: properties.title ? String(properties.title) : null,\n    url: state.resolve(source),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;AACA;AAAA;AACA;;;;AAUO,SAAS,MAAM,KAAK,EAAE,IAAI;IAC/B,MAAM,aAAa,KAAK,UAAU,IAAI,CAAC;IACvC,MAAM,SAAS,KAAK,OAAO,KAAK,UAAU,OAAO,WAAW,MAAM,IAAI,MAAM;IAC5E,IAAI,SAAS,OAAO,WAAW,GAAG,IAAI;IACtC,IAAI,QAAQ,CAAC;IACb,IAAI,wBAAwB;IAC5B,IAAI,QAAQ,MAAM,GAAG,CAAC;IAEtB,iBAAiB,GACjB,MAAM,WAAW;QAAC,MAAM;QAAQ,UAAU;IAAK;IAE/C,IAAA,sSAAK,EAAC,UAAU,SAAU,IAAI;QAC5B,IAAI,KAAK,IAAI,KAAK,QAAQ;YACxB,wBAAwB;YACxB,OAAO,2SAAI;QACb;IACF;IAEA,8DAA8D;IAC9D,IAAI,yBAAyB,IAAA,6SAAU,EAAC,QAAQ;QAC9C,OAAO;IACT;IAEA,mBAAmB;IACnB,MAAO,CAAC,UAAU,EAAE,QAAQ,KAAK,QAAQ,CAAC,MAAM,CAAE;QAChD,MAAM,QAAQ,KAAK,QAAQ,CAAC,MAAM;QAElC,IACE,MAAM,IAAI,KAAK,aACf,MAAM,OAAO,KAAK,YAClB,MAAM,UAAU,EAChB;YACA,SAAS,OAAO,MAAM,UAAU,CAAC,GAAG,IAAI;QAC1C;IACF;IAEA,6DAA6D;IAC7D,IAAI,QAAQ;QACV,kBAAkB,GAClB,MAAM,QAAQ;YACZ,MAAM;YACN,OAAO;YACP,KAAK,MAAM,OAAO,CAAC;YACnB,KAAK,IAAA,uSAAQ,EAAC;QAChB;QACA,MAAM,KAAK,CAAC,MAAM;QAClB,QAAQ;YAAC;SAAM;IACjB;IAEA,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD;IAExD,8BAA8B;IAC9B,iBAAiB,GACjB,MAAM,SAAS;QACb,MAAM;QACN,OAAO,WAAW,KAAK,GAAG,OAAO,WAAW,KAAK,IAAI;QACrD,KAAK,MAAM,OAAO,CAAC;QACnB;IACF;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/p.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Paragraph, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Paragraph | undefined}\n *   mdast node.\n */\nexport function p(state, node) {\n  const children = dropSurroundingBreaks(\n    // Allow potentially “invalid” nodes, they might be unknown.\n    // We also support straddling later.\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  if (children.length > 0) {\n    /** @type {Paragraph} */\n    const result = {type: 'paragraph', children}\n    state.patch(node, result)\n    return result\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,EAAE,KAAK,EAAE,IAAI;IAC3B,MAAM,WAAW,IAAA,iVAAqB,EAGG,MAAM,GAAG,CAAC;IAGnD,IAAI,SAAS,MAAM,GAAG,GAAG;QACvB,sBAAsB,GACtB,MAAM,SAAS;YAAC,MAAM;YAAa;QAAQ;QAC3C,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/q.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RootContent as MdastRootContent} from 'mdast'\n */\n\nconst defaultQuotes = ['\"']\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent>}\n *   mdast nodes.\n */\nexport function q(state, node) {\n  const quotes = state.options.quotes || defaultQuotes\n\n  state.qNesting++\n  const contents = state.all(node)\n  state.qNesting--\n\n  const quote = quotes[state.qNesting % quotes.length]\n  const head = contents[0]\n  const tail = contents[contents.length - 1]\n  const open = quote.charAt(0)\n  const close = quote.length > 1 ? quote.charAt(1) : quote\n\n  if (head && head.type === 'text') {\n    head.value = open + head.value\n  } else {\n    contents.unshift({type: 'text', value: open})\n  }\n\n  if (tail && tail.type === 'text') {\n    tail.value += close\n  } else {\n    contents.push({type: 'text', value: close})\n  }\n\n  return contents\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED,MAAM,gBAAgB;IAAC;CAAI;AAUpB,SAAS,EAAE,KAAK,EAAE,IAAI;IAC3B,MAAM,SAAS,MAAM,OAAO,CAAC,MAAM,IAAI;IAEvC,MAAM,QAAQ;IACd,MAAM,WAAW,MAAM,GAAG,CAAC;IAC3B,MAAM,QAAQ;IAEd,MAAM,QAAQ,MAAM,CAAC,MAAM,QAAQ,GAAG,OAAO,MAAM,CAAC;IACpD,MAAM,OAAO,QAAQ,CAAC,EAAE;IACxB,MAAM,OAAO,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE;IAC1C,MAAM,OAAO,MAAM,MAAM,CAAC;IAC1B,MAAM,QAAQ,MAAM,MAAM,GAAG,IAAI,MAAM,MAAM,CAAC,KAAK;IAEnD,IAAI,QAAQ,KAAK,IAAI,KAAK,QAAQ;QAChC,KAAK,KAAK,GAAG,OAAO,KAAK,KAAK;IAChC,OAAO;QACL,SAAS,OAAO,CAAC;YAAC,MAAM;YAAQ,OAAO;QAAI;IAC7C;IAEA,IAAI,QAAQ,KAAK,IAAI,KAAK,QAAQ;QAChC,KAAK,KAAK,IAAI;IAChB,OAAO;QACL,SAAS,IAAI,CAAC;YAAC,MAAM;YAAQ,OAAO;QAAK;IAC3C;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1281, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/root.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n */\n\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastRoot>} node\n *   hast root to transform.\n * @returns {MdastRoot}\n *   mdast node.\n */\nexport function root(state, node) {\n  let children = state.all(node)\n\n  if (state.options.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  /** @type {MdastRoot} */\n  const result = {type: 'root', children}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,KAAK,KAAK,EAAE,IAAI;IAC9B,IAAI,WAAW,MAAM,GAAG,CAAC;IAEzB,IAAI,MAAM,OAAO,CAAC,QAAQ,IAAI,IAAA,6SAAU,EAAC,WAAW;QAClD,WAAW,IAAA,uSAAI,EAAC;IAClB;IAEA,sBAAsB,GACtB,MAAM,SAAS;QAAC,MAAM;QAAQ;IAAQ;IACtC,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1307, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/select.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text | undefined}\n *   mdast node.\n */\nexport function select(state, node) {\n  const values = findSelectedOptions(node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < values.length) {\n    const value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    /** @type {Text} */\n    const result = {type: 'text', value: results.join(', ')}\n    state.patch(node, result)\n    return result\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,OAAO,KAAK,EAAE,IAAI;IAChC,MAAM,SAAS,IAAA,6UAAmB,EAAC;IACnC,IAAI,QAAQ,CAAC;IACb,0BAA0B,GAC1B,MAAM,UAAU,EAAE;IAElB,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;QAC9B,MAAM,QAAQ,MAAM,CAAC,MAAM;QAC3B,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,GAAG,OAAO,KAAK,CAAC,EAAE,GAAG,MAAM,KAAK,CAAC,EAAE;IACrE;IAEA,IAAI,QAAQ,MAAM,GAAG,GAAG;QACtB,iBAAiB,GACjB,MAAM,SAAS;YAAC,MAAM;YAAQ,OAAO,QAAQ,IAAI,CAAC;QAAK;QACvD,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1338, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/strong.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, Strong} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Strong}\n *   mdast node.\n */\nexport function strong(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Strong} */\n  const result = {type: 'strong', children}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,OAAO,KAAK,EAAE,IAAI;IAChC,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD,MAAM,GAAG,CAAC;IAElE,mBAAmB,GACnB,MAAM,SAAS;QAAC,MAAM;QAAU;IAAQ;IACxC,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-cell.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, TableCell} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableCell}\n *   mdast node.\n */\nexport function tableCell(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {TableCell} */\n  const result = {type: 'tableCell', children}\n  state.patch(node, result)\n\n  if (node.properties) {\n    const rowSpan = node.properties.rowSpan\n    const colSpan = node.properties.colSpan\n\n    if (rowSpan || colSpan) {\n      const data = /** @type {Record<string, unknown>} */ (\n        result.data || (result.data = {})\n      )\n      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan\n      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan\n    }\n  }\n\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,UAAU,KAAK,EAAE,IAAI;IACnC,4DAA4D;IAC5D,oCAAoC;IACpC,MAAM,WAAkD,MAAM,GAAG,CAAC;IAElE,sBAAsB,GACtB,MAAM,SAAS;QAAC,MAAM;QAAa;IAAQ;IAC3C,MAAM,KAAK,CAAC,MAAM;IAElB,IAAI,KAAK,UAAU,EAAE;QACnB,MAAM,UAAU,KAAK,UAAU,CAAC,OAAO;QACvC,MAAM,UAAU,KAAK,UAAU,CAAC,OAAO;QAEvC,IAAI,WAAW,SAAS;YACtB,MAAM,OACJ,OAAO,IAAI,IAAI,CAAC,OAAO,IAAI,GAAG,CAAC,CAAC;YAElC,IAAI,SAAS,KAAK,+BAA+B,GAAG;YACpD,IAAI,SAAS,KAAK,+BAA+B,GAAG;QACtD;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-row.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RowContent, TableRow} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableRow}\n *   mdast node.\n */\nexport function tableRow(state, node) {\n  const children = state.toSpecificContent(state.all(node), create)\n\n  /** @type {TableRow} */\n  const result = {type: 'tableRow', children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {RowContent}\n */\nfunction create() {\n  return {type: 'tableCell', children: []}\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,SAAS,KAAK,EAAE,IAAI;IAClC,MAAM,WAAW,MAAM,iBAAiB,CAAC,MAAM,GAAG,CAAC,OAAO;IAE1D,qBAAqB,GACrB,MAAM,SAAS;QAAC,MAAM;QAAY;IAAQ;IAC1C,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT;AAEA;;CAEC,GACD,SAAS;IACP,OAAO;QAAC,MAAM;QAAa,UAAU,EAAE;IAAA;AACzC","ignoreList":[0]}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/table.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {AlignType, RowContent, TableContent, Table, Text} from 'mdast'\n */\n\n/**\n * @typedef Info\n *   Inferred info on a table.\n * @property {Array<AlignType>} align\n *   Alignment.\n * @property {boolean} headless\n *   Whether a `thead` is missing.\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Table | Text}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function table(state, node) {\n  // Ignore nested tables.\n  if (state.inTable) {\n    /** @type {Text} */\n    const result = {type: 'text', value: toText(node)}\n    state.patch(node, result)\n    return result\n  }\n\n  state.inTable = true\n\n  const {align, headless} = inspect(node)\n  const rows = state.toSpecificContent(state.all(node), createRow)\n\n  // Add an empty header row.\n  if (headless) {\n    rows.unshift(createRow())\n  }\n\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const row = rows[rowIndex]\n    const cells = state.toSpecificContent(row.children, createCell)\n    row.children = cells\n  }\n\n  let columns = 1\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const data = /** @type {Record<string, unknown>} */ (cell.data)\n        const colSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1\n        const rowSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<RowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('hastUtilToMdastTemporaryColSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryColSpan\n        if ('hastUtilToMdastTemporaryRowSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryRowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  state.inTable = false\n\n  /** @type {Table} */\n  const result = {type: 'table', align, children: rows}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Readonly<Element>} node\n *   Table element to check.\n * @returns {Info}\n *   Info.\n */\nfunction inspect(node) {\n  /** @type {Info} */\n  const info = {align: [null], headless: true}\n  let rowIndex = 0\n  let cellIndex = 0\n\n  visit(node, function (child) {\n    if (child.type === 'element') {\n      // Don’t enter nested tables.\n      if (child.tagName === 'table' && node !== child) {\n        return SKIP\n      }\n\n      if (\n        (child.tagName === 'th' || child.tagName === 'td') &&\n        child.properties\n      ) {\n        if (!info.align[cellIndex]) {\n          const value = String(child.properties.align || '') || null\n\n          if (\n            value === 'center' ||\n            value === 'left' ||\n            value === 'right' ||\n            value === null\n          ) {\n            info.align[cellIndex] = value\n          }\n        }\n\n        // If there is a `th` in the first row, assume there is a header row.\n        if (info.headless && rowIndex < 2 && child.tagName === 'th') {\n          info.headless = false\n        }\n\n        cellIndex++\n      }\n      // If there is a `thead`, assume there is a header row.\n      else if (child.tagName === 'thead') {\n        info.headless = false\n      } else if (child.tagName === 'tr') {\n        rowIndex++\n        cellIndex = 0\n      }\n    }\n  })\n\n  return info\n}\n\n/**\n * @returns {RowContent}\n */\nfunction createCell() {\n  return {type: 'tableCell', children: []}\n}\n\n/**\n * @returns {TableContent}\n */\nfunction createRow() {\n  return {type: 'tableRow', children: []}\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/text.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Text as HastText} from 'hast'\n * @import {Text as MdastText} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastText>} node\n *   hast element to transform.\n * @returns {MdastText}\n *   mdast node.\n */\nexport function text(state, node) {\n  /** @type {MdastText} */\n  const result = {type: 'text', value: node.value}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,KAAK,KAAK,EAAE,IAAI;IAC9B,sBAAsB,GACtB,MAAM,SAAS;QAAC,MAAM;QAAQ,OAAO,KAAK,KAAK;IAAA;IAC/C,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1640, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/textarea.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function textarea(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAUO,SAAS,SAAS,KAAK,EAAE,IAAI;IAClC,iBAAiB,GACjB,MAAM,SAAS;QAAC,MAAM;QAAQ,OAAO,IAAA,+RAAM,EAAC;IAAK;IACjD,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/wbr.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function wbr(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: '\\u200B'}\n  state.patch(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;CAOC;;;;AACM,SAAS,IAAI,KAAK,EAAE,IAAI;IAC7B,iBAAiB,GACjB,MAAM,SAAS;QAAC,MAAM;QAAQ,OAAO;IAAQ;IAC7C,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1689, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/handlers/index.js"],"sourcesContent":["/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Parents} from 'hast'\n */\n\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\n/**\n * Default handlers for nodes.\n *\n * Each key is a node type, each value is a `NodeHandler`.\n */\nexport const nodeHandlers = {\n  comment,\n  doctype: ignore,\n  root,\n  text\n}\n\n/**\n * Default handlers for elements.\n *\n * Each key is an element name, each value is a `Handler`.\n */\nexport const handlers = {\n  // Ignore:\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  // Use children:\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  // Use children as flow.\n  address: flow,\n  article: flow,\n  aside: flow,\n  body: flow,\n  center: flow,\n  div: flow,\n  fieldset: flow,\n  figcaption: flow,\n  figure: flow,\n  form: flow,\n  footer: flow,\n  header: flow,\n  hgroup: flow,\n  html: flow,\n  legend: flow,\n  main: flow,\n  multicol: flow,\n  nav: flow,\n  picture: flow,\n  section: flow,\n\n  // Handle.\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction all(state, node) {\n  return state.all(node)\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction flow(state, node) {\n  return state.toFlow(state.all(node))\n}\n\n/**\n * @returns {undefined}\n */\nfunction ignore() {}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1938, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/state.js"],"sourcesContent":["/**\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {\n *   BlockContent as MdastBlockContent,\n *   DefinitionContent as MdastDefinitionContent,\n *   Nodes as MdastNodes,\n *   Parents as MdastParents,\n *   RootContent as MdastRootContent\n * } from 'mdast'\n */\n\n/**\n * @typedef {MdastBlockContent | MdastDefinitionContent} MdastFlowContent\n */\n\n/**\n * @callback All\n *   Transform the children of a hast parent to mdast.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n *\n * @callback Handle\n *   Handle a particular element.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Element} element\n *   Element to transform.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback NodeHandle\n *   Handle a particular node.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {any} node\n *   Node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback One\n *   Transform a hast node to mdast.\n * @param {Nodes} node\n *   Expected hast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [checked='[x]']\n *   Value to use for a checked checkbox or radio input (default: `'[x]'`)\n * @property {boolean | null | undefined} [document]\n *   Whether the given tree represents a complete document (optional).\n *\n *   Applies when the `tree` is a `root` node.\n *   When the tree represents a complete document, then things are wrapped in\n *   paragraphs when needed, and otherwise they’re left as-is.\n *   The default checks for whether there’s mixed content: some phrasing nodes\n *   *and* some non-phrasing nodes.\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers]\n *   Object mapping tag names to functions handling the corresponding elements\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {boolean | null | undefined} [newlines=false]\n *   Keep line endings when collapsing whitespace (default: `false`).\n *\n *   The default collapses to a single space.\n * @property {Record<string, NodeHandle | null | undefined> | null | undefined} [nodeHandlers]\n *   Object mapping node types to functions handling the corresponding nodes\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {Array<string> | null | undefined} [quotes=['\"']]\n *   List of quotes to use (default: `['\"']`).\n *\n *   Each value can be one or two characters.\n *   When two, the first character determines the opening quote and the second\n *   the closing quote at that level.\n *   When one, both the opening and closing quote are that character.\n *\n *   The order in which the preferred quotes appear determines which quotes to\n *   use at which level of nesting.\n *   So, to prefer `‘’` at the first level of nesting, and `“”` at the second,\n *   pass `['‘’', '“”']`.\n *   If `<q>`s are nested deeper than the given amount of quotes, the markers\n *   wrap around: a third level of nesting when using `['«»', '‹›']` should\n *   have double guillemets, a fourth single, a fifth double again, etc.\n * @property {string | null | undefined} [unchecked='[ ]']\n *   Value to use for an unchecked checkbox or radio input (default: `'[ ]'`).\n *\n * @callback Patch\n *   Copy a node’s positional info.\n * @param {Nodes} from\n *   hast node to copy from.\n * @param {MdastNodes} to\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback Resolve\n *   Resolve a URL relative to a base.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {All} all\n *   Transform the children of a hast parent to mdast.\n * @property {boolean} baseFound\n *   Whether a `<base>` element was seen.\n * @property {Map<string, Element>} elementById\n *   Elements by their `id`.\n * @property {string | undefined} frozenBaseUrl\n *   `href` of `<base>`, if any.\n * @property {Record<string, Handle>} handlers\n *   Applied element handlers.\n * @property {boolean} inTable\n *   Whether we’re in a table.\n * @property {Record<string, NodeHandle>} nodeHandlers\n *   Applied node handlers.\n * @property {One} one\n *   Transform a hast node to mdast.\n * @property {Options} options\n *   User configuration.\n * @property {Patch} patch\n *   Copy a node’s positional info.\n * @property {number} qNesting\n *   Non-negative finite integer representing how deep we’re in `<q>`s.\n * @property {Resolve} resolve\n *   Resolve a URL relative to a base.\n * @property {ToFlow} toFlow\n *   Transform a list of mdast nodes to flow.\n * @property {<ChildType extends MdastNodes, ParentType extends MdastParents & {'children': Array<ChildType>}>(nodes: Array<MdastRootContent>, build: (() => ParentType)) => Array<ParentType>} toSpecificContent\n *   Turn arbitrary content into a list of a particular node type.\n *\n *   This is useful for example for lists, which must have list items as\n *   content.\n *   in this example, when non-items are found, they will be queued, and\n *   inserted into an adjacent item.\n *   When no actual items exist, one will be made with `build`.\n *\n * @callback ToFlow\n *   Transform a list of mdast nodes to flow.\n * @param {Array<MdastRootContent>} nodes\n *   mdast nodes.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\n\nimport {position} from 'unist-util-position'\nimport {handlers, nodeHandlers} from './handlers/index.js'\nimport {wrap} from './util/wrap.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a state.\n *\n * @param {Readonly<Options>} options\n *   User configuration.\n * @returns {State}\n *   State.\n */\nexport function createState(options) {\n  return {\n    all,\n    baseFound: false,\n    elementById: new Map(),\n    frozenBaseUrl: undefined,\n    handlers: {...handlers, ...options.handlers},\n    inTable: false,\n    nodeHandlers: {...nodeHandlers, ...options.nodeHandlers},\n    one,\n    options,\n    patch,\n    qNesting: 0,\n    resolve,\n    toFlow,\n    toSpecificContent\n  }\n}\n\n/**\n * Transform the children of a hast parent to mdast.\n *\n * You might want to combine this with `toFlow` or `toSpecificContent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  /** @type {Array<MdastRootContent>} */\n  const results = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Content -> content.\n    const result =\n      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */ (\n        this.one(child, parent)\n      )\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Transform a hast node to mdast.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n */\nfunction one(node, parent) {\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(this.handlers, node.tagName)) {\n      return this.handlers[node.tagName](this, node, parent) || undefined\n    }\n  } else if (own.call(this.nodeHandlers, node.type)) {\n    return this.nodeHandlers[node.type](this, node, parent) || undefined\n  }\n\n  // Unknown literal.\n  if ('value' in node && typeof node.value === 'string') {\n    /** @type {MdastRootContent} */\n    const result = {type: 'text', value: node.value}\n    this.patch(node, result)\n    return result\n  }\n\n  // Unknown parent.\n  if ('children' in node) {\n    return this.all(node)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {Nodes} origin\n *   hast node to copy from.\n * @param {MdastNodes} node\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(origin, node) {\n  if (origin.position) node.position = position(origin)\n}\n\n/**\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n */\nfunction resolve(url) {\n  const base = this.frozenBaseUrl\n\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (base) {\n    return String(new URL(url, base))\n  }\n\n  return url\n}\n\n/**\n * Transform a list of mdast nodes to flow.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Array<MdastRootContent>} nodes\n *   Parent.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\nfunction toFlow(nodes) {\n  return wrap(nodes)\n}\n\n/**\n * Turn arbitrary content into a particular node type.\n *\n * This is useful for example for lists, which must have list items as content.\n * in this example, when non-items are found, they will be queued, and\n * inserted into an adjacent item.\n * When no actual items exist, one will be made with `build`.\n *\n * @template {MdastNodes} ChildType\n *   Node type of children.\n * @template {MdastParents & {'children': Array<ChildType>}} ParentType\n *   Node type of parent.\n * @param {Array<MdastRootContent>} nodes\n *   Nodes, which are either `ParentType`, or will be wrapped in one.\n * @param {() => ParentType} build\n *   Build a parent if needed (must have empty `children`).\n * @returns {Array<ParentType>}\n *   List of parents.\n */\nfunction toSpecificContent(nodes, build) {\n  const reference = build()\n  /** @type {Array<ParentType>} */\n  const results = []\n  /** @type {Array<ChildType>} */\n  let queue = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (expectedParent(node)) {\n      if (queue.length > 0) {\n        node.children.unshift(...queue)\n        queue = []\n      }\n\n      results.push(node)\n    } else {\n      // Assume `node` can be a child of `ParentType`.\n      // If we start checking nodes, we’d run into problems with unknown nodes,\n      // which we do want to support.\n      const child = /** @type {ChildType} */ (node)\n      queue.push(child)\n    }\n  }\n\n  if (queue.length > 0) {\n    let node = results[results.length - 1]\n\n    if (!node) {\n      node = build()\n      results.push(node)\n    }\n\n    node.children.push(...queue)\n    queue = []\n  }\n\n  return results\n\n  /**\n   * @param {MdastNodes} node\n   * @returns {node is ParentType}\n   */\n  function expectedParent(node) {\n    return node.type === reference.type\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2296, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/hast-util-to-mdast%4010.1.2/node_modules/hast-util-to-mdast/lib/index.js"],"sourcesContent":["/**\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Nodes} from 'hast'\n * @import {Nodes as MdastNodes, RootContent as MdastRootContent} from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visit} from 'unist-util-visit'\nimport {createState} from './state.js'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Transform hast to mdast.\n *\n * @param {Readonly<Nodes>} tree\n *   hast tree to transform.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {MdastNodes}\n *   mdast tree.\n */\nexport function toMdast(tree, options) {\n  // We have to clone, cause we’ll use `rehype-minify-whitespace` on the tree,\n  // which modifies.\n  const cleanTree = structuredClone(tree)\n  const settings = options || emptyOptions\n  const transformWhitespace = rehypeMinifyWhitespace({\n    newlines: settings.newlines === true\n  })\n  const state = createState(settings)\n  /** @type {MdastNodes} */\n  let mdast\n\n  // @ts-expect-error: fine to pass an arbitrary node.\n  transformWhitespace(cleanTree)\n\n  visit(cleanTree, function (node) {\n    if (node && node.type === 'element' && node.properties) {\n      const id = String(node.properties.id || '') || undefined\n\n      if (id && !state.elementById.has(id)) {\n        state.elementById.set(id, node)\n      }\n    }\n  })\n\n  const result = state.one(cleanTree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    // Assume content.\n    const children = /** @type {Array<MdastRootContent>} */ (result)\n    mdast = {type: 'root', children}\n  } else {\n    mdast = result\n  }\n\n  // Collapse text nodes, and fix whitespace.\n  //\n  // Most of this is taken care of by `rehype-minify-whitespace`, but\n  // we’re generating some whitespace too, and some nodes are in the end\n  // ignored.\n  // So clean up.\n  visit(mdast, function (node, index, parent) {\n    if (node.type === 'text' && index !== undefined && parent) {\n      const previous = parent.children[index - 1]\n\n      if (previous && previous.type === node.type) {\n        previous.value += node.value\n        parent.children.splice(index, 1)\n\n        if (previous.position && node.position) {\n          previous.position.end = node.position.end\n        }\n\n        // Iterate over the previous node again, to handle its total value.\n        return index - 1\n      }\n\n      node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n      // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n      // as there the whitespace matters.\n      if (\n        parent &&\n        (parent.type === 'heading' ||\n          parent.type === 'paragraph' ||\n          parent.type === 'root')\n      ) {\n        if (!index) {\n          node.value = node.value.replace(/^[\\t ]+/, '')\n        }\n\n        if (index === parent.children.length - 1) {\n          node.value = node.value.replace(/[\\t ]+$/, '')\n        }\n      }\n\n      if (!node.value) {\n        parent.children.splice(index, 1)\n        return index\n      }\n    }\n  })\n\n  return mdast\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;AACA;AACA;AACA;;;;;AAEA,8BAA8B,GAC9B,MAAM,eAAe,CAAC;AAYf,SAAS,QAAQ,IAAI,EAAE,OAAO;IACnC,4EAA4E;IAC5E,kBAAkB;IAClB,MAAM,YAAY,IAAA,wTAAe,EAAC;IAClC,MAAM,WAAW,WAAW;IAC5B,MAAM,sBAAsB,IAAA,wSAAsB,EAAC;QACjD,UAAU,SAAS,QAAQ,KAAK;IAClC;IACA,MAAM,QAAQ,IAAA,uSAAW,EAAC;IAC1B,uBAAuB,GACvB,IAAI;IAEJ,oDAAoD;IACpD,oBAAoB;IAEpB,IAAA,sSAAK,EAAC,WAAW,SAAU,IAAI;QAC7B,IAAI,QAAQ,KAAK,IAAI,KAAK,aAAa,KAAK,UAAU,EAAE;YACtD,MAAM,KAAK,OAAO,KAAK,UAAU,CAAC,EAAE,IAAI,OAAO;YAE/C,IAAI,MAAM,CAAC,MAAM,WAAW,CAAC,GAAG,CAAC,KAAK;gBACpC,MAAM,WAAW,CAAC,GAAG,CAAC,IAAI;YAC5B;QACF;IACF;IAEA,MAAM,SAAS,MAAM,GAAG,CAAC,WAAW;IAEpC,IAAI,CAAC,QAAQ;QACX,QAAQ;YAAC,MAAM;YAAQ,UAAU,EAAE;QAAA;IACrC,OAAO,IAAI,MAAM,OAAO,CAAC,SAAS;QAChC,kBAAkB;QAClB,MAAM,WAAmD;QACzD,QAAQ;YAAC,MAAM;YAAQ;QAAQ;IACjC,OAAO;QACL,QAAQ;IACV;IAEA,2CAA2C;IAC3C,EAAE;IACF,mEAAmE;IACnE,sEAAsE;IACtE,WAAW;IACX,eAAe;IACf,IAAA,sSAAK,EAAC,OAAO,SAAU,IAAI,EAAE,KAAK,EAAE,MAAM;QACxC,IAAI,KAAK,IAAI,KAAK,UAAU,UAAU,aAAa,QAAQ;YACzD,MAAM,WAAW,OAAO,QAAQ,CAAC,QAAQ,EAAE;YAE3C,IAAI,YAAY,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE;gBAC3C,SAAS,KAAK,IAAI,KAAK,KAAK;gBAC5B,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAE9B,IAAI,SAAS,QAAQ,IAAI,KAAK,QAAQ,EAAE;oBACtC,SAAS,QAAQ,CAAC,GAAG,GAAG,KAAK,QAAQ,CAAC,GAAG;gBAC3C;gBAEA,mEAAmE;gBACnE,OAAO,QAAQ;YACjB;YAEA,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC,OAAO,CAAC,0BAA0B;YAE1D,2EAA2E;YAC3E,mCAAmC;YACnC,IACE,UACA,CAAC,OAAO,IAAI,KAAK,aACf,OAAO,IAAI,KAAK,eAChB,OAAO,IAAI,KAAK,MAAM,GACxB;gBACA,IAAI,CAAC,OAAO;oBACV,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC,OAAO,CAAC,WAAW;gBAC7C;gBAEA,IAAI,UAAU,OAAO,QAAQ,CAAC,MAAM,GAAG,GAAG;oBACxC,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC,OAAO,CAAC,WAAW;gBAC7C;YACF;YAEA,IAAI,CAAC,KAAK,KAAK,EAAE;gBACf,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAC9B,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}}]
}