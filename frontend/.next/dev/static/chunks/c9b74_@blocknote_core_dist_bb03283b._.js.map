{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/BlockNoteExtension-C2X7LW-V.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/ExtensionManager/symbol.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/BlockNoteExtension.ts"],"sourcesContent":["/**\n * Symbol used to track the original factory function for extensions.\n * This allows us to retrieve the original factory for comparison and other operations.\n */\nexport const originalFactorySymbol = Symbol(\"originalFactory\");\n\n","import { Store, StoreOptions } from \"@tanstack/store\";\nimport { type AnyExtension } from \"@tiptap/core\";\nimport type { Plugin as ProsemirrorPlugin } from \"prosemirror-state\";\nimport type { PartialBlockNoDefaults } from \"../schema/index.js\";\nimport type { BlockNoteEditor } from \"./BlockNoteEditor.js\";\nimport { originalFactorySymbol } from \"./managers/ExtensionManager/symbol.js\";\n\n/**\n * This function is called when the extension is destroyed.\n */\ntype OnDestroy = () => void;\n\n/**\n * Describes a BlockNote extension.\n */\nexport interface Extension<State = any, Key extends string = string> {\n  /**\n   * The unique identifier for the extension.\n   */\n  readonly key: Key;\n\n  /**\n   * Triggered when the extension is mounted to the editor.\n   */\n  readonly mount?: (ctx: {\n    /**\n     * The DOM element that the editor is mounted to.\n     */\n    dom: HTMLElement;\n    /**\n     * The root document of the {@link document} that the editor is mounted to.\n     */\n    root: Document | ShadowRoot;\n    /**\n     * An {@link AbortSignal} that will be aborted when the extension is destroyed.\n     */\n    signal: AbortSignal;\n  }) => void | OnDestroy;\n\n  /**\n   * The store for the extension.\n   */\n  readonly store?: Store<State>;\n\n  /**\n   * Declares what {@link Extension}s that this extension depends on.\n   */\n  readonly runsBefore?: ReadonlyArray<string>;\n\n  /**\n   * Input rules for a block: An input rule is what is used to replace text in a block when a regular expression match is found.\n   * As an example, typing `#` in a paragraph block will trigger an input rule to replace the text with a heading block.\n   */\n  readonly inputRules?: ReadonlyArray<InputRule>;\n\n  /**\n   * A mapping of a keyboard shortcut to a function that will be called when the shortcut is pressed\n   *\n   * The keys are in the format:\n   * - Key names may be strings like `Shift-Ctrl-Enter`â€”a key identifier prefixed with zero or more modifiers\n   * - Key identifiers are based on the strings that can appear in KeyEvent.key\n   * - Use lowercase letters to refer to letter keys (or uppercase letters if you want shift to be held)\n   * - You may use `Space` as an alias for the \" \" name\n   * - Modifiers can be given in any order: `Shift-` (or `s-`), `Alt-` (or `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or `Meta-`)\n   * - For characters that are created by holding shift, the Shift- prefix is implied, and should not be added explicitly\n   * - You can use Mod- as a shorthand for Cmd- on Mac and Ctrl- on other platforms\n   *\n   * @example\n   * ```typescript\n   * keyboardShortcuts: {\n   *   \"Mod-Enter\": (ctx) => {  return true; },\n   *   \"Shift-Ctrl-Space\": (ctx) => { return true; },\n   *   \"a\": (ctx) => { return true; },\n   *   \"Space\": (ctx) => { return true; }\n   * }\n   * ```\n   */\n  readonly keyboardShortcuts?: Record<\n    string,\n    (ctx: { editor: BlockNoteEditor<any, any, any> }) => boolean\n  >;\n\n  /**\n   * Add additional prosemirror plugins to the editor.\n   */\n  readonly prosemirrorPlugins?: ReadonlyArray<ProsemirrorPlugin>;\n\n  /**\n   * Add additional tiptap extensions to the editor.\n   */\n  readonly tiptapExtensions?: ReadonlyArray<AnyExtension>;\n}\n\n/**\n * An input rule is what is used to replace text in a block when a regular expression match is found.\n * As an example, typing `#` in a paragraph block will trigger an input rule to replace the text with a heading block.\n */\ntype InputRule = {\n  /**\n   * The regex to match when to trigger the input rule\n   */\n  find: RegExp;\n  /**\n   * The function to call when the input rule is matched\n   * @returns undefined if the input rule should not be triggered, or an object with the type and props to update the block\n   */\n  replace: (props: {\n    /**\n     * The result of the regex match\n     */\n    match: RegExpMatchArray;\n    // TODO this will be a Point, when we have the Location API\n    /**\n     * The range of the text that was matched\n     */\n    range: { from: number; to: number };\n    /**\n     * The editor instance\n     */\n    editor: BlockNoteEditor<any, any, any>;\n  }) => undefined | PartialBlockNoDefaults<any, any, any>;\n};\n\n/**\n * These are the arguments that are passed to an {@link ExtensionFactoryInstance}.\n */\nexport interface ExtensionOptions<\n  Options extends Record<string, any> | undefined =\n    | Record<string, any>\n    | undefined,\n> {\n  options: Options;\n  editor: BlockNoteEditor<any, any, any>;\n}\n\n// a type that maps the extension key to the return type of the extension factory\nexport type ExtensionMap<T extends ReadonlyArray<ExtensionFactoryInstance>> = {\n  [K in T[number] extends ExtensionFactoryInstance<infer Ext>\n    ? Ext[\"key\"]\n    : never]: T[number] extends ExtensionFactoryInstance<infer Ext>\n    ? Ext\n    : never;\n};\n\n/**\n * This is a type that represents the function which will actually create the extension.\n * It requires the editor instance to be passed in, but will already have the options applied automatically.\n *\n * @note Only the BlockNoteEditor should instantiate this function, not the user. Look at {@link createExtension} for user-facing functions.\n */\nexport type ExtensionFactoryInstance<\n  Ext extends Extension<any, any> = Extension<any, any>,\n> = (ctx: Omit<ExtensionOptions<any>, \"options\">) => Ext;\n\n/**\n * This is the return type of the {@link createExtension} function.\n * It is a function that can be invoked with the extension's options to create a new extension factory.\n */\nexport type ExtensionFactory<\n  State = any,\n  Key extends string = string,\n  Factory extends (ctx: any) => Extension<State, Key> = (\n    ctx: ExtensionOptions<any>,\n  ) => Extension<State, Key>,\n> =\n  Parameters<Factory>[0] extends ExtensionOptions<infer Options>\n    ? undefined extends Options\n      ? (\n          options?: Exclude<Options, undefined>,\n        ) => ExtensionFactoryInstance<ReturnType<Factory>>\n      : (options: Options) => ExtensionFactoryInstance<ReturnType<Factory>>\n    : () => ExtensionFactoryInstance<ReturnType<Factory>>;\n\n/**\n * Constructs a BlockNote {@link ExtensionFactory} from a factory function or object\n */\n// This overload is for `createExtension({ key: \"test\", ... })`\nexport function createExtension<\n  const State = any,\n  const Key extends string = string,\n  const Ext extends Extension<State, Key> = Extension<State, Key>,\n>(factory: Ext): ExtensionFactoryInstance<Ext>;\n// This overload is for `createExtension(({editor, options}) => ({ key: \"test\", ... }))`\nexport function createExtension<\n  const State = any,\n  const Options extends Record<string, any> | undefined = any,\n  const Key extends string = string,\n  const Factory extends (ctx: any) => Extension<State, Key> = (\n    ctx: ExtensionOptions<Options>,\n  ) => Extension<State, Key>,\n>(factory: Factory): ExtensionFactory<State, Key, Factory>;\n// This overload is for both of the above overloads as it is the implementation of the function\nexport function createExtension<\n  const State = any,\n  const Options extends Record<string, any> | undefined = any,\n  const Key extends string = string,\n  const Factory extends\n    | Extension<State, Key>\n    | ((ctx: any) => Extension<State, Key>) = (\n    ctx: ExtensionOptions<Options>,\n  ) => Extension<State, Key>,\n>(\n  factory: Factory,\n): Factory extends Extension<State, Key>\n  ? ExtensionFactoryInstance<Factory>\n  : Factory extends (ctx: any) => Extension<State, Key>\n    ? ExtensionFactory<State, Key, Factory>\n    : never {\n  if (typeof factory === \"object\" && \"key\" in factory) {\n    return function factoryFn() {\n      (factory as any)[originalFactorySymbol] = factoryFn;\n      return factory;\n    } as any;\n  }\n\n  if (typeof factory !== \"function\") {\n    throw new Error(\"factory must be a function\");\n  }\n\n  return function factoryFn(options: Options) {\n    return (ctx: { editor: BlockNoteEditor<any, any, any> }) => {\n      const extension = factory({ editor: ctx.editor, options });\n      // We stick a symbol onto the extension to allow us to retrieve the original factory for comparison later.\n      // This enables us to do things like: `editor.getExtension(YSync).prosemirrorPlugins`\n      (extension as any)[originalFactorySymbol] = factoryFn;\n      return extension;\n    };\n  } as any;\n}\n\nexport function createStore<T = any>(\n  initialState: T,\n  options?: StoreOptions<T>,\n): Store<T> {\n  return new Store(initialState, options);\n}\n"],"names":["originalFactorySymbol","createExtension","factory","factoryFn","options","ctx","extension","createStore","initialState","Store"],"mappings":";;;;;;;;;;AAIO,MAAMA,IAAwB,OAAO,iBAAiB;AC4LtD,SAASC,EAUdC,CAAAA,EAKU;IACV,IAAI,OAAOA,KAAY,YAAY,SAASA,GAC1C,OAAO,SAASC,IAAY;QACzB,OAAAD,CAAAA,CAAgBF,CAAqB,CAAA,GAAIG,GACnCD;IACT;IAGF,IAAI,OAAOA,KAAY,YACrB,MAAM,IAAI,MAAM,4BAA4B;IAG9C,OAAO,SAASC,EAAUC,CAAAA,EAAkB;QAC1C,OAAO,CAACC,MAAoD;YAC1D,MAAMC,IAAYJ,EAAQ;gBAAE,QAAQG,EAAI,MAAA;gBAAQ,SAAAD;YAAAA,CAAS;YAGxD,OAAAE,CAAAA,CAAkBN,CAAqB,CAAA,GAAIG,GACrCG;QACT;IACF;AACF;AAEO,SAASC,EACdC,CAAAA,EACAJ,CAAAA,EACU;IACV,OAAO,IAAIK,wRAAAA,CAAMD,GAAcJ,CAAO;AACxC"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/ShowSelection-Dz-NEase.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/ShowSelection/ShowSelection.ts"],"sourcesContent":["import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-show-selection`);\n\n/**\n * Plugin that shows adds a decoration around the current selection\n * This can be used to highlight the current selection in the UI even when the\n * text editor is not focused.\n */\nexport const ShowSelectionExtension = createExtension(({ editor }) => {\n  const store = createStore(\n    { enabled: false },\n    {\n      onUpdate() {\n        editor.transact((tr) => tr.setMeta(PLUGIN_KEY, {}));\n      },\n    },\n  );\n  return {\n    key: \"showSelection\",\n    store,\n    prosemirrorPlugins: [\n      new Plugin({\n        key: PLUGIN_KEY,\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n            if (!store.state.enabled) {\n              return DecorationSet.empty;\n            }\n            const dec = Decoration.inline(selection.from, selection.to, {\n              \"data-show-selection\": \"true\",\n            });\n            return DecorationSet.create(doc, [dec]);\n          },\n        },\n      }),\n    ],\n    /**\n     * Show or hide the selection decoration\n     */\n    showSelection(shouldShow: boolean) {\n      store.setState({ enabled: shouldShow });\n    },\n  } as const;\n});\n"],"names":["PLUGIN_KEY","PluginKey","ShowSelectionExtension","createExtension","editor","store","createStore","tr","Plugin","state","doc","selection","DecorationSet","dec","Decoration","shouldShow"],"mappings":";;;;;;;;;;AAOA,MAAMA,IAAa,IAAIC,uRAAAA,CAAU,0BAA0B,GAO9CC,QAAyBC,mVAAAA,EAAgB,CAAC,EAAE,QAAAC,CAAAA,EAAAA,KAAa;IACpE,MAAMC,QAAQC,mVAAAA,EACZ;QAAE,SAAS,CAAA;IAAA,GACX;QACE,WAAW;YACTF,EAAO,QAAA,CAAS,CAACG,IAAOA,EAAG,OAAA,CAAQP,GAAY,CAAA,CAAE,CAAC;QACpD;IAAA;IAGJ,OAAO;QACL,KAAK;QACL,OAAAK;QACA,oBAAoB;YAClB,IAAIG,oRAAAA,CAAO;gBACT,KAAKR;gBACL,OAAO;oBACL,aAAa,CAACS,MAAU;wBACtB,MAAM,EAAE,KAAAC,CAAAA,EAAK,WAAAC,CAAAA,CAAA,CAAA,GAAcF;wBAC3B,IAAI,CAACJ,EAAM,KAAA,CAAM,OAAA,EACf,OAAOO,0RAAAA,CAAc,KAAA;wBAEvB,MAAMC,IAAMC,uRAAAA,CAAW,MAAA,CAAOH,EAAU,IAAA,EAAMA,EAAU,EAAA,EAAI;4BAC1D,uBAAuB;wBAAA,CACxB;wBACD,OAAOC,0RAAAA,CAAc,MAAA,CAAOF,GAAK;4BAACG,CAAG;yBAAC;oBACxC;gBAAA;YACF,CACD;SAAA;QAAA;;KAAA,GAKH,eAAcE,CAAAA,EAAqB;YACjCV,EAAM,QAAA,CAAS;gBAAE,SAASU;YAAA,CAAY;QACxC;IAAA;AAEJ,CAAC"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/EventEmitter-CjSwpTbz.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/EventEmitter.ts"],"sourcesContent":["// from https://raw.githubusercontent.com/ueberdosis/tiptap/develop/packages/core/src/EventEmitter.ts (MIT)\n\ntype StringKeyOf<T> = Extract<keyof T, string>;\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]];\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any;\n\nexport class EventEmitter<T extends Record<string, any>> {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private callbacks: { [key: string]: Function[] } = {};\n\n  public on<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn: CallbackFunction<T, EventName>,\n  ) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n\n    this.callbacks[event].push(fn);\n\n    return () => this.off(event, fn);\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    ...args: CallbackType<T, EventName>\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n  }\n\n  public off<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn?: CallbackFunction<T, EventName>,\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {};\n  }\n}\n"],"names":["EventEmitter","__publicField","event","fn","args","callbacks","callback"],"mappings":";;;;;;;;;;;;AAYO,MAAMA,EAA4C;IAAlD,aAAA;QAEG,wDAAA;QAAAC,EAAA,IAAA,EAAA,aAA2C,CAAA;IAAA;IAE5C,GACLC,CAAAA,EACAC,CAAAA,EACA;QACA,OAAK,IAAA,CAAK,SAAA,CAAUD,CAAK,CAAA,IAAA,CACvB,IAAA,CAAK,SAAA,CAAUA,CAAK,CAAA,GAAI,CAAA,CAAA,GAG1B,IAAA,CAAK,SAAA,CAAUA,CAAK,CAAA,CAAE,IAAA,CAAKC,CAAE,GAEtB,IAAM,IAAA,CAAK,GAAA,CAAID,GAAOC,CAAE;IACjC;IAEU,KACRD,CAAAA,EAAAA,GACGE,CAAAA,EACH;QACA,MAAMC,IAAY,IAAA,CAAK,SAAA,CAAUH,CAAK,CAAA;QAElCG,KACFA,EAAU,OAAA,CAAQ,CAACC,IAAaA,EAAS,KAAA,CAAM,IAAA,EAAMF,CAAI,CAAC;IAE9D;IAEO,IACLF,CAAAA,EACAC,CAAAA,EACA;QACA,MAAME,IAAY,IAAA,CAAK,SAAA,CAAUH,CAAK,CAAA;QAElCG,KAAAA,CACEF,IACF,IAAA,CAAK,SAAA,CAAUD,CAAK,CAAA,GAAIG,EAAU,MAAA,CAAO,CAACC,IAAaA,MAAaH,CAAE,IAEtE,OAAO,IAAA,CAAK,SAAA,CAAUD,CAAK,CAAA;IAGjC;IAEU,qBAA2B;QACnC,IAAA,CAAK,SAAA,GAAY,CAAA;IACnB;AACF"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/comments.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/mark.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/userstore/UserStore.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/extension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/ThreadStoreAuth.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/DefaultThreadStoreAuth.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/ThreadStore.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/TipTapThreadStore.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/yjs/yjsHelpers.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/yjs/YjsThreadStoreBase.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/yjs/RESTYjsThreadStore.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/comments/threadstore/yjs/YjsThreadStore.ts"],"sourcesContent":["import { Mark, mergeAttributes } from \"@tiptap/core\";\n\nexport const CommentMark = Mark.create({\n  name: \"comment\",\n  excludes: \"\",\n  inclusive: false,\n  keepOnSplit: true,\n\n  addAttributes() {\n    // Return an object with attribute configuration\n    return {\n      // orphans are marks that currently don't have an active thread. It could be\n      // that users have resolved the thread. Resolved threads by default are not shown in the document,\n      // but we need to keep the mark (positioning) data so we can still \"revive\" it when the thread is unresolved\n      // or we enter a \"comments\" view that includes resolved threads.\n      orphan: {\n        parseHTML: (element) => !!element.getAttribute(\"data-orphan\"),\n        renderHTML: (attributes) => {\n          return (attributes as { orphan: boolean }).orphan\n            ? {\n                \"data-orphan\": \"true\",\n              }\n            : {};\n        },\n        default: false,\n      },\n      threadId: {\n        parseHTML: (element) => element.getAttribute(\"data-bn-thread-id\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-bn-thread-id\": (attributes as { threadId: string }).threadId,\n          };\n        },\n        default: \"\",\n      },\n    };\n  },\n\n  renderHTML({ HTMLAttributes }: { HTMLAttributes: Record<string, any> }) {\n    return [\n      \"span\",\n      mergeAttributes(HTMLAttributes, {\n        class: \"bn-thread-mark\",\n      }),\n    ];\n  },\n\n  parseHTML() {\n    return [{ tag: \"span.bn-thread-mark\" }];\n  },\n\n  extendMarkSchema(extension) {\n    if (extension.name === \"comment\") {\n      return {\n        blocknoteIgnore: true,\n      };\n    }\n    return {};\n  },\n});\n","import type { User } from \"../types.js\";\nimport { EventEmitter } from \"../../util/EventEmitter.js\";\n\n/**\n * The `UserStore` is used to retrieve and cache information about users.\n *\n * It does this by calling `resolveUsers` (which is user-defined in the Editor Options)\n * for users that are not yet cached.\n */\nexport class UserStore<U extends User> extends EventEmitter<any> {\n  private userCache: Map<string, U> = new Map();\n\n  // avoid duplicate loads\n  private loadingUsers = new Set<string>();\n\n  public constructor(\n    private readonly resolveUsers: (userIds: string[]) => Promise<U[]>,\n  ) {\n    super();\n  }\n\n  /**\n   * Load information about users based on an array of user ids.\n   */\n  public async loadUsers(userIds: string[]) {\n    const missingUsers = userIds.filter(\n      (id) => !this.userCache.has(id) && !this.loadingUsers.has(id),\n    );\n\n    if (missingUsers.length === 0) {\n      return;\n    }\n\n    for (const id of missingUsers) {\n      this.loadingUsers.add(id);\n    }\n\n    try {\n      const users = await this.resolveUsers(missingUsers);\n      for (const user of users) {\n        this.userCache.set(user.id, user);\n      }\n      this.emit(\"update\", this.userCache);\n    } finally {\n      for (const id of missingUsers) {\n        // delete the users from the loading set\n        // on a next call to `loadUsers` we will either\n        // return the cached user or retry loading the user if the request failed failed\n        this.loadingUsers.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Retrieve information about a user based on their id, if cached.\n   *\n   * The user will have to be loaded via `loadUsers` first\n   */\n  public getUser(userId: string): U | undefined {\n    return this.userCache.get(userId);\n  }\n\n  /**\n   * Subscribe to changes in the user store.\n   *\n   * @param cb - The callback to call when the user store changes.\n   * @returns A function to unsubscribe from the user store.\n   */\n  public subscribe(cb: (users: Map<string, U>) => void): () => void {\n    return this.on(\"update\", cb);\n  }\n}\n","import { Node } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { getRelativeSelection, ySyncPluginKey } from \"y-prosemirror\";\nimport {\n  createExtension,\n  createStore,\n  ExtensionOptions,\n} from \"../editor/BlockNoteExtension.js\";\nimport { ShowSelectionExtension } from \"../extensions/ShowSelection/ShowSelection.js\";\nimport { CustomBlockNoteSchema } from \"../schema/schema.js\";\nimport { CommentMark } from \"./mark.js\";\nimport type { ThreadStore } from \"./threadstore/ThreadStore.js\";\nimport type { CommentBody, ThreadData } from \"./types.js\";\nimport { User } from \"./types.js\";\nimport { UserStore } from \"./userstore/UserStore.js\";\n\nconst PLUGIN_KEY = new PluginKey(\"blocknote-comments\");\n\ntype CommentsPluginState = {\n  /**\n   * Decorations to be rendered, specifically to indicate the selected thread\n   */\n  decorations: DecorationSet;\n};\n\n/**\n * Calculate the thread positions from the current document state\n */\nfunction getUpdatedThreadPositions(doc: Node, markType: string) {\n  const threadPositions = new Map<string, { from: number; to: number }>();\n\n  // find all thread marks and store their position + create decoration for selected thread\n  doc.descendants((node, pos) => {\n    node.marks.forEach((mark) => {\n      if (mark.type.name === markType) {\n        const thisThreadId = (mark.attrs as { threadId: string | undefined })\n          .threadId;\n        if (!thisThreadId) {\n          return;\n        }\n        const from = pos;\n        const to = from + node.nodeSize;\n\n        // FloatingThreads component uses \"to\" as the position, so always store the largest \"to\" found\n        // AnchoredThreads component uses \"from\" as the position, so always store the smallest \"from\" found\n        const currentPosition = threadPositions.get(thisThreadId) ?? {\n          from: Infinity,\n          to: 0,\n        };\n        threadPositions.set(thisThreadId, {\n          from: Math.min(from, currentPosition.from),\n          to: Math.max(to, currentPosition.to),\n        });\n      }\n    });\n  });\n  return threadPositions;\n}\n\nexport const CommentsExtension = createExtension(\n  ({\n    editor,\n    options: { schema: commentEditorSchema, threadStore, resolveUsers },\n  }: ExtensionOptions<{\n    /**\n     * The thread store implementation to use for storing and retrieving comment threads\n     */\n    threadStore: ThreadStore;\n    /**\n     * Resolve user information for comments.\n     *\n     * See [Comments](https://www.blocknotejs.org/docs/features/collaboration/comments) for more info.\n     */\n    resolveUsers: (userIds: string[]) => Promise<User[]>;\n    /**\n     * A schema to use for the comment editor (which allows you to customize the blocks and styles that are available in the comment editor)\n     */\n    schema?: CustomBlockNoteSchema<any, any, any>;\n  }>) => {\n    if (!resolveUsers) {\n      throw new Error(\n        \"resolveUsers is required to be defined when using comments\",\n      );\n    }\n    if (!threadStore) {\n      throw new Error(\n        \"threadStore is required to be defined when using comments\",\n      );\n    }\n    const markType = CommentMark.name;\n\n    const userStore = new UserStore<User>(resolveUsers);\n    const store = createStore(\n      {\n        pendingComment: false,\n        selectedThreadId: undefined as string | undefined,\n        threadPositions: new Map<string, { from: number; to: number }>(),\n      },\n      {\n        onUpdate() {\n          // If the selected thread id changed, we need to update the decorations\n          if (\n            store.state.selectedThreadId !== store.prevState.selectedThreadId\n          ) {\n            // So, we issue a transaction to update the decorations\n            editor.transact((tr) => tr.setMeta(PLUGIN_KEY, true));\n          }\n        },\n      },\n    );\n\n    const updateMarksFromThreads = (threads: Map<string, ThreadData>) => {\n      editor.transact((tr) => {\n        tr.doc.descendants((node, pos) => {\n          node.marks.forEach((mark) => {\n            if (mark.type.name === markType) {\n              const markTypeInstance = mark.type;\n              const markThreadId = mark.attrs.threadId as string;\n              const thread = threads.get(markThreadId);\n              const isOrphan = !!(\n                !thread ||\n                thread.resolved ||\n                thread.deletedAt\n              );\n\n              if (isOrphan !== mark.attrs.orphan) {\n                const trimmedFrom = Math.max(pos, 0);\n                const trimmedTo = Math.min(\n                  pos + node.nodeSize,\n                  tr.doc.content.size - 1,\n                  tr.doc.content.size - 1,\n                );\n                tr.removeMark(trimmedFrom, trimmedTo, mark);\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  markTypeInstance.create({\n                    ...mark.attrs,\n                    orphan: isOrphan,\n                  }),\n                );\n\n                if (isOrphan && store.state.selectedThreadId === markThreadId) {\n                  // unselect\n                  store.setState((prev) => ({\n                    ...prev,\n                    selectedThreadId: undefined,\n                  }));\n                }\n              }\n            }\n          });\n        });\n      });\n    };\n\n    return {\n      key: \"comments\",\n      store,\n      prosemirrorPlugins: [\n        new Plugin<CommentsPluginState>({\n          key: PLUGIN_KEY,\n          state: {\n            init() {\n              return {\n                decorations: DecorationSet.empty,\n              };\n            },\n            apply(tr, state) {\n              const action = tr.getMeta(PLUGIN_KEY);\n\n              if (!tr.docChanged && !action) {\n                return state;\n              }\n\n              // only update threadPositions if the doc changed\n              const newThreadPositions = tr.docChanged\n                ? getUpdatedThreadPositions(tr.doc, markType)\n                : store.state.threadPositions;\n\n              if (\n                newThreadPositions.size > 0 ||\n                store.state.threadPositions.size > 0\n              ) {\n                // small optimization; don't emit event if threadPositions before / after were both empty\n                store.setState((prev) => ({\n                  ...prev,\n                  threadPositions: newThreadPositions,\n                }));\n              }\n\n              // update decorations if doc or selected thread changed\n              const decorations = [] as any[];\n\n              if (store.state.selectedThreadId) {\n                const selectedThreadPosition = newThreadPositions.get(\n                  store.state.selectedThreadId,\n                );\n\n                if (selectedThreadPosition) {\n                  decorations.push(\n                    Decoration.inline(\n                      selectedThreadPosition.from,\n                      selectedThreadPosition.to,\n                      {\n                        class: \"bn-thread-mark-selected\",\n                      },\n                    ),\n                  );\n                }\n              }\n\n              return {\n                decorations: DecorationSet.create(tr.doc, decorations),\n              };\n            },\n          },\n          props: {\n            decorations(state) {\n              return (\n                PLUGIN_KEY.getState(state)?.decorations ?? DecorationSet.empty\n              );\n            },\n            handleClick: (view, pos, event) => {\n              if (event.button !== 0) {\n                return;\n              }\n\n              const node = view.state.doc.nodeAt(pos);\n\n              if (!node) {\n                // unselect\n                store.setState((prev) => ({\n                  ...prev,\n                  selectedThreadId: undefined,\n                }));\n                return;\n              }\n\n              const commentMark = node.marks.find(\n                (mark) =>\n                  mark.type.name === markType && mark.attrs.orphan !== true,\n              );\n\n              const threadId = commentMark?.attrs.threadId as\n                | string\n                | undefined;\n              if (threadId !== store.state.selectedThreadId) {\n                store.setState((prev) => ({\n                  ...prev,\n                  selectedThreadId: threadId,\n                }));\n              }\n            },\n          },\n        }),\n      ],\n      threadStore: threadStore,\n      mount() {\n        const unsubscribe = threadStore.subscribe(updateMarksFromThreads);\n        updateMarksFromThreads(threadStore.getThreads());\n\n        const unsubscribeOnSelectionChange = editor.onSelectionChange(() => {\n          if (store.state.pendingComment) {\n            store.setState((prev) => ({\n              ...prev,\n              pendingComment: false,\n            }));\n          }\n        });\n\n        return () => {\n          unsubscribe();\n          unsubscribeOnSelectionChange();\n        };\n      },\n      selectThread(threadId: string | undefined, scrollToThread = true) {\n        if (store.state.selectedThreadId === threadId) {\n          return;\n        }\n        store.setState((prev) => ({\n          ...prev,\n          pendingComment: false,\n          selectedThreadId: threadId,\n        }));\n\n        if (threadId && scrollToThread) {\n          const selectedThreadPosition =\n            store.state.threadPositions.get(threadId);\n          if (!selectedThreadPosition) {\n            return;\n          }\n          (\n            editor.prosemirrorView?.domAtPos(selectedThreadPosition.from)\n              .node as Element | undefined\n          )?.scrollIntoView({\n            behavior: \"smooth\",\n            block: \"center\",\n          });\n        }\n      },\n      startPendingComment() {\n        store.setState((prev) => ({\n          ...prev,\n          selectedThreadId: undefined,\n          pendingComment: true,\n        }));\n        editor.getExtension(ShowSelectionExtension)?.showSelection(true);\n      },\n      stopPendingComment() {\n        store.setState((prev) => ({\n          ...prev,\n          selectedThreadId: undefined,\n          pendingComment: false,\n        }));\n        editor.getExtension(ShowSelectionExtension)?.showSelection(false);\n      },\n      async createThread(options: {\n        initialComment: { body: CommentBody; metadata?: any };\n        metadata?: any;\n      }) {\n        const thread = await threadStore.createThread(options);\n        if (threadStore.addThreadToDocument) {\n          const view = editor.prosemirrorView!;\n          const pmSelection = view.state.selection;\n          const ystate = ySyncPluginKey.getState(view.state);\n          const selection = {\n            prosemirror: {\n              head: pmSelection.head,\n              anchor: pmSelection.anchor,\n            },\n            yjs: ystate\n              ? getRelativeSelection(ystate.binding, view.state)\n              : undefined,\n          };\n          await threadStore.addThreadToDocument({\n            threadId: thread.id,\n            selection,\n          });\n        } else {\n          (editor as any)._tiptapEditor.commands.setMark(markType, {\n            orphan: false,\n            threadId: thread.id,\n          });\n        }\n      },\n      userStore,\n      commentEditorSchema,\n      tiptapExtensions: [CommentMark],\n    } as const;\n  },\n);\n","import { CommentData, ThreadData } from \"../types.js\";\n\nexport abstract class ThreadStoreAuth {\n  abstract canCreateThread(): boolean;\n  abstract canAddComment(thread: ThreadData): boolean;\n  abstract canUpdateComment(comment: CommentData): boolean;\n  abstract canDeleteComment(comment: CommentData): boolean;\n  abstract canDeleteThread(thread: ThreadData): boolean;\n  abstract canResolveThread(thread: ThreadData): boolean;\n  abstract canUnresolveThread(thread: ThreadData): boolean;\n  abstract canAddReaction(comment: CommentData, emoji?: string): boolean;\n  abstract canDeleteReaction(comment: CommentData, emoji?: string): boolean;\n}\n","import { CommentData, ThreadData } from \"../types.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\n/*\n * The DefaultThreadStoreAuth class defines the authorization rules for interacting with comments.\n * We take a role (\"comment\" or \"editor\") and implement the rules.\n *\n * This class is then used in the UI to show / hide specific interactions.\n *\n * Rules:\n * - View-only users should not be able to see any comments\n * - Comment-only users and editors can:\n * - - create new comments / replies / reactions\n * - - edit / delete their own comments / reactions\n * - - resolve / unresolve threads\n * - Editors can also delete any comment or thread\n */\nexport class DefaultThreadStoreAuth extends ThreadStoreAuth {\n  constructor(\n    private readonly userId: string,\n    private readonly role: \"comment\" | \"editor\",\n  ) {\n    super();\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canCreateThread(): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canAddComment(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should only be possible by the comment author\n   */\n  canUpdateComment(comment: CommentData): boolean {\n    return comment.userId === this.userId;\n  }\n\n  /**\n   * Auth: should be possible by the comment author OR an editor of the document\n   */\n  canDeleteComment(comment: CommentData): boolean {\n    return comment.userId === this.userId || this.role === \"editor\";\n  }\n\n  /**\n   * Auth: should only be possible by an editor of the document\n   */\n  canDeleteThread(_thread: ThreadData): boolean {\n    return this.role === \"editor\";\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canResolveThread(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canUnresolveThread(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   *\n   * Note: will also check if the user has already reacted with the same emoji. TBD: is that a nice design or should this responsibility be outside of auth?\n   */\n  canAddReaction(comment: CommentData, emoji?: string): boolean {\n    if (!emoji) {\n      return true;\n    }\n\n    return !comment.reactions.some(\n      (reaction) =>\n        reaction.emoji === emoji && reaction.userIds.includes(this.userId),\n    );\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   *\n   * Note: will also check if the user has already reacted with the same emoji. TBD: is that a nice design or should this responsibility be outside of auth?\n   */\n  canDeleteReaction(comment: CommentData, emoji?: string): boolean {\n    if (!emoji) {\n      return true;\n    }\n\n    return comment.reactions.some(\n      (reaction) =>\n        reaction.emoji === emoji && reaction.userIds.includes(this.userId),\n    );\n  }\n}\n","import { CommentBody, CommentData, ThreadData } from \"../types.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\n/**\n * ThreadStore is an abstract class that defines the interface\n * to read / add / update / delete threads and comments.\n */\nexport abstract class ThreadStore {\n  public readonly auth: ThreadStoreAuth;\n\n  constructor(auth: ThreadStoreAuth) {\n    this.auth = auth;\n  }\n\n  /**\n   * A \"thread\" in the ThreadStore only contains information about the content\n   * of the thread / comments. It does not contain information about the position.\n   *\n   * This function can be implemented to store the thread in the document (by creating a mark)\n   * If not implemented, default behavior will apply (creating the mark via TipTap)\n   * See CommentsPlugin.ts for more details.\n   */\n  abstract addThreadToDocument?(options: {\n    threadId: string;\n    selection: {\n      prosemirror: {\n        head: number;\n        anchor: number;\n      };\n      yjs?: {\n        head: any;\n        anchor: any;\n      };\n    };\n  }): Promise<void>;\n\n  /**\n   * Creates a new thread with an initial comment.\n   */\n  abstract createThread(options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }): Promise<ThreadData>;\n\n  /**\n   * Adds a comment to a thread.\n   */\n  abstract addComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }): Promise<CommentData>;\n\n  /**\n   * Updates a comment in a thread.\n   */\n  abstract updateComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a comment from a thread.\n   */\n  abstract deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a thread.\n   */\n  abstract deleteThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Marks a thread as resolved.\n   */\n  abstract resolveThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Marks a thread as unresolved.\n   */\n  abstract unresolveThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Adds a reaction to a comment.\n   *\n   * Auth: should be possible by anyone with comment access\n   */\n  abstract addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a reaction from a comment.\n   *\n   * Auth: should be possible by the reaction author\n   */\n  abstract deleteReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Retrieve data for a specific thread.\n   */\n  abstract getThread(threadId: string): ThreadData;\n\n  /**\n   * Retrieve all threads.\n   */\n  abstract getThreads(): Map<string, ThreadData>;\n\n  /**\n   * Subscribe to changes in the thread store.\n   *\n   * @returns a function to unsubscribe from the thread store\n   */\n  abstract subscribe(\n    cb: (threads: Map<string, ThreadData>) => void,\n  ): () => void;\n}\n","import type {\n  TCollabComment,\n  TCollabThread,\n  TiptapCollabProvider,\n} from \"@hocuspocus/provider\";\nimport {\n  CommentBody,\n  CommentData,\n  CommentReactionData,\n  ThreadData,\n} from \"../types.js\";\nimport { ThreadStore } from \"./ThreadStore.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\ntype ReactionAsTiptapData = {\n  emoji: string;\n  createdAt: number;\n  userId: string;\n};\n\n/**\n * The `TiptapThreadStore` integrates with Tiptap's collaboration provider for comment management.\n * You can pass a `TiptapCollabProvider` to the constructor which takes care of storing the comments.\n *\n * Under the hood, this actually works similarly to the `YjsThreadStore` implementation. (comments are stored in the Yjs document)\n */\nexport class TiptapThreadStore extends ThreadStore {\n  constructor(\n    private readonly userId: string,\n    private readonly provider: TiptapCollabProvider,\n    auth: ThreadStoreAuth, // TODO: use?\n  ) {\n    super(auth);\n  }\n\n  /**\n   * Creates a new thread with an initial comment.\n   */\n  public async createThread(options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }): Promise<ThreadData> {\n    let thread = this.provider.createThread({\n      data: options.metadata,\n    });\n\n    thread = this.provider.addComment(thread.id, {\n      content: options.initialComment.body,\n      data: {\n        metadata: options.initialComment.metadata,\n        userId: this.userId,\n      },\n    });\n\n    return this.tiptapThreadToThreadData(thread);\n  }\n\n  // TipTapThreadStore does not support addThreadToDocument\n  public addThreadToDocument = undefined;\n\n  /**\n   * Adds a comment to a thread.\n   */\n  public async addComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }): Promise<CommentBody> {\n    const thread = this.provider.addComment(options.threadId, {\n      content: options.comment.body,\n      data: {\n        metadata: options.comment.metadata,\n        userId: this.userId,\n      },\n    });\n\n    return this.tiptapCommentToCommentData(\n      thread.comments[thread.comments.length - 1],\n    );\n  }\n\n  /**\n   * Updates a comment in a thread.\n   */\n  public async updateComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      content: options.comment.body,\n      data: {\n        ...comment.data,\n        metadata: options.comment.metadata,\n      },\n    });\n  }\n\n  private tiptapCommentToCommentData(comment: TCollabComment): CommentData {\n    const reactions: CommentReactionData[] = [];\n\n    for (const reaction of (comment.data?.reactions ||\n      []) as ReactionAsTiptapData[]) {\n      const existingReaction = reactions.find(\n        (r) => r.emoji === reaction.emoji,\n      );\n      if (existingReaction) {\n        existingReaction.userIds.push(reaction.userId);\n        existingReaction.createdAt = new Date(\n          Math.min(existingReaction.createdAt.getTime(), reaction.createdAt),\n        );\n      } else {\n        reactions.push({\n          emoji: reaction.emoji,\n          createdAt: new Date(reaction.createdAt),\n          userIds: [reaction.userId],\n        });\n      }\n    }\n\n    return {\n      type: \"comment\",\n      id: comment.id,\n      body: comment.content,\n      metadata: comment.data?.metadata,\n      userId: comment.data?.userId,\n      createdAt: new Date(comment.createdAt),\n      updatedAt: new Date(comment.updatedAt),\n      reactions,\n    };\n  }\n\n  private tiptapThreadToThreadData(thread: TCollabThread): ThreadData {\n    return {\n      type: \"thread\",\n      id: thread.id,\n      comments: thread.comments.map((comment) =>\n        this.tiptapCommentToCommentData(comment),\n      ),\n      resolved: !!thread.resolvedAt,\n      metadata: thread.data?.metadata,\n      createdAt: new Date(thread.createdAt),\n      updatedAt: new Date(thread.updatedAt),\n    };\n  }\n\n  /**\n   * Deletes a comment from a thread.\n   */\n  public async deleteComment(options: { threadId: string; commentId: string }) {\n    this.provider.deleteComment(options.threadId, options.commentId);\n  }\n\n  /**\n   * Deletes a thread.\n   */\n  public async deleteThread(options: { threadId: string }) {\n    this.provider.deleteThread(options.threadId);\n  }\n\n  /**\n   * Marks a thread as resolved.\n   */\n  public async resolveThread(options: { threadId: string }) {\n    this.provider.updateThread(options.threadId, {\n      resolvedAt: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Marks a thread as unresolved.\n   */\n  public async unresolveThread(options: { threadId: string }) {\n    this.provider.updateThread(options.threadId, {\n      resolvedAt: null,\n    });\n  }\n\n  /**\n   * Adds a reaction to a comment.\n   *\n   * Auth: should be possible by anyone with comment access\n   */\n  public async addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      data: {\n        ...comment.data,\n        reactions: [\n          ...((comment.data?.reactions || []) as ReactionAsTiptapData[]),\n          {\n            emoji: options.emoji,\n            createdAt: Date.now(),\n            userId: this.userId,\n          },\n        ],\n      },\n    });\n  }\n\n  /**\n   * Deletes a reaction from a comment.\n   *\n   * Auth: should be possible by the reaction author\n   */\n  public async deleteReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      data: {\n        ...comment.data,\n        reactions: (\n          (comment.data?.reactions || []) as ReactionAsTiptapData[]\n        ).filter(\n          (reaction) =>\n            reaction.emoji !== options.emoji && reaction.userId !== this.userId,\n        ),\n      },\n    });\n  }\n\n  public getThread(threadId: string): ThreadData {\n    const thread = this.provider.getThread(threadId);\n\n    if (!thread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    return this.tiptapThreadToThreadData(thread);\n  }\n\n  public getThreads(): Map<string, ThreadData> {\n    return new Map(\n      this.provider\n        .getThreads()\n        .map((thread) => [thread.id, this.tiptapThreadToThreadData(thread)]),\n    );\n  }\n\n  public subscribe(cb: (threads: Map<string, ThreadData>) => void): () => void {\n    const newCb = () => {\n      cb(this.getThreads());\n    };\n    this.provider.watchThreads(newCb);\n    return () => {\n      this.provider.unwatchThreads(newCb);\n    };\n  }\n}\n","import * as Y from \"yjs\";\nimport { CommentData, CommentReactionData, ThreadData } from \"../../types.js\";\n\nexport function commentToYMap(comment: CommentData) {\n  const yMap = new Y.Map<any>();\n  yMap.set(\"id\", comment.id);\n  yMap.set(\"userId\", comment.userId);\n  yMap.set(\"createdAt\", comment.createdAt.getTime());\n  yMap.set(\"updatedAt\", comment.updatedAt.getTime());\n  if (comment.deletedAt) {\n    yMap.set(\"deletedAt\", comment.deletedAt.getTime());\n    yMap.set(\"body\", undefined);\n  } else {\n    yMap.set(\"body\", comment.body);\n  }\n  if (comment.reactions.length > 0) {\n    throw new Error(\"Reactions should be empty in commentToYMap\");\n  }\n\n  /**\n   * Reactions are stored in a map keyed by {userId-emoji},\n   * this makes it easy to add / remove reactions and in a way that works local-first.\n   * The cost is that \"reading\" the reactions is a bit more complex (see yMapToReactions).\n   */\n  yMap.set(\"reactionsByUser\", new Y.Map());\n  yMap.set(\"metadata\", comment.metadata);\n\n  return yMap;\n}\n\nexport function threadToYMap(thread: ThreadData) {\n  const yMap = new Y.Map();\n  yMap.set(\"id\", thread.id);\n  yMap.set(\"createdAt\", thread.createdAt.getTime());\n  yMap.set(\"updatedAt\", thread.updatedAt.getTime());\n  const commentsArray = new Y.Array<Y.Map<any>>();\n\n  commentsArray.push(thread.comments.map((comment) => commentToYMap(comment)));\n\n  yMap.set(\"comments\", commentsArray);\n  yMap.set(\"resolved\", thread.resolved);\n  yMap.set(\"resolvedUpdatedAt\", thread.resolvedUpdatedAt?.getTime());\n  yMap.set(\"resolvedBy\", thread.resolvedBy);\n  yMap.set(\"metadata\", thread.metadata);\n  return yMap;\n}\n\ntype SingleUserCommentReactionData = {\n  emoji: string;\n  createdAt: Date;\n  userId: string;\n};\n\nexport function yMapToReaction(\n  yMap: Y.Map<any>,\n): SingleUserCommentReactionData {\n  return {\n    emoji: yMap.get(\"emoji\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    userId: yMap.get(\"userId\"),\n  };\n}\n\nfunction yMapToReactions(yMap: Y.Map<any>): CommentReactionData[] {\n  const flatReactions = [...yMap.values()].map((reaction: Y.Map<any>) =>\n    yMapToReaction(reaction),\n  );\n  // combine reactions by the same emoji\n  return flatReactions.reduce(\n    (acc: CommentReactionData[], reaction: SingleUserCommentReactionData) => {\n      const existingReaction = acc.find((r) => r.emoji === reaction.emoji);\n      if (existingReaction) {\n        existingReaction.userIds.push(reaction.userId);\n        existingReaction.createdAt = new Date(\n          Math.min(\n            existingReaction.createdAt.getTime(),\n            reaction.createdAt.getTime(),\n          ),\n        );\n      } else {\n        acc.push({\n          emoji: reaction.emoji,\n          createdAt: reaction.createdAt,\n          userIds: [reaction.userId],\n        });\n      }\n      return acc;\n    },\n    [] as CommentReactionData[],\n  );\n}\n\nexport function yMapToComment(yMap: Y.Map<any>): CommentData {\n  return {\n    type: \"comment\",\n    id: yMap.get(\"id\"),\n    userId: yMap.get(\"userId\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    updatedAt: new Date(yMap.get(\"updatedAt\")),\n    deletedAt: yMap.get(\"deletedAt\")\n      ? new Date(yMap.get(\"deletedAt\"))\n      : undefined,\n    reactions: yMapToReactions(yMap.get(\"reactionsByUser\")),\n    metadata: yMap.get(\"metadata\"),\n    body: yMap.get(\"body\"),\n  };\n}\n\nexport function yMapToThread(yMap: Y.Map<any>): ThreadData {\n  return {\n    type: \"thread\",\n    id: yMap.get(\"id\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    updatedAt: new Date(yMap.get(\"updatedAt\")),\n    comments: ((yMap.get(\"comments\") as Y.Array<Y.Map<any>>) || []).map(\n      (comment) => yMapToComment(comment),\n    ),\n    resolved: yMap.get(\"resolved\"),\n    resolvedUpdatedAt: new Date(yMap.get(\"resolvedUpdatedAt\")),\n    resolvedBy: yMap.get(\"resolvedBy\"),\n    metadata: yMap.get(\"metadata\"),\n  };\n}\n","import * as Y from \"yjs\";\nimport { ThreadData } from \"../../types.js\";\nimport { ThreadStore } from \"../ThreadStore.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { yMapToThread } from \"./yjsHelpers.js\";\n\n/**\n * This is an abstract class that only implements the READ methods required by the ThreadStore interface.\n * The data is read from a Yjs Map.\n */\nexport abstract class YjsThreadStoreBase extends ThreadStore {\n  constructor(\n    protected readonly threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(auth);\n  }\n\n  // TODO: async / reactive interface?\n  public getThread(threadId: string) {\n    const yThread = this.threadsYMap.get(threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n    const thread = yMapToThread(yThread);\n    return thread;\n  }\n\n  public getThreads(): Map<string, ThreadData> {\n    const threadMap = new Map<string, ThreadData>();\n    this.threadsYMap.forEach((yThread, id) => {\n      if (yThread instanceof Y.Map) {\n        threadMap.set(id, yMapToThread(yThread));\n      }\n    });\n    return threadMap;\n  }\n\n  public subscribe(cb: (threads: Map<string, ThreadData>) => void) {\n    const observer = () => {\n      cb(this.getThreads());\n    };\n\n    this.threadsYMap.observeDeep(observer);\n\n    return () => {\n      this.threadsYMap.unobserveDeep(observer);\n    };\n  }\n}\n","import * as Y from \"yjs\";\nimport { CommentBody } from \"../../types.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { YjsThreadStoreBase } from \"./YjsThreadStoreBase.js\";\n\n/**\n * This is a REST-based implementation of the YjsThreadStoreBase.\n * It Reads data directly from the underlying document (same as YjsThreadStore),\n * but for Writes, it sends data to a REST API that should:\n * - check the user has the correct permissions to make the desired changes\n * - apply the updates to the underlying Yjs document\n *\n * (see https://github.com/TypeCellOS/BlockNote-demo-nextjs-hocuspocus)\n *\n * The reason we still use the Yjs document as underlying storage is that it makes it easy to\n * sync updates in real-time to other collaborators.\n * (but technically, you could also implement a different storage altogether\n * and not store the thread related data in the Yjs document)\n */\nexport class RESTYjsThreadStore extends YjsThreadStoreBase {\n  constructor(\n    private readonly BASE_URL: string,\n    private readonly headers: Record<string, string>,\n    threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(threadsYMap, auth);\n  }\n\n  private doRequest = async (path: string, method: string, body?: any) => {\n    const response = await fetch(`${this.BASE_URL}${path}`, {\n      method,\n      body: JSON.stringify(body),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...this.headers,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to ${method} ${path}: ${response.statusText}`);\n    }\n\n    return response.json();\n  };\n\n  public addThreadToDocument = async (options: {\n    threadId: string;\n    selection: {\n      prosemirror: {\n        head: number;\n        anchor: number;\n      };\n      yjs: {\n        head: any;\n        anchor: any;\n      };\n    };\n  }) => {\n    const { threadId, ...rest } = options;\n    return this.doRequest(`/${threadId}/addToDocument`, \"POST\", rest);\n  };\n\n  public createThread = async (options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }) => {\n    return this.doRequest(\"\", \"POST\", options);\n  };\n\n  public addComment = (options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }) => {\n    const { threadId, ...rest } = options;\n    return this.doRequest(`/${threadId}/comments`, \"POST\", rest);\n  };\n\n  public updateComment = (options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(`/${threadId}/comments/${commentId}`, \"PUT\", rest);\n  };\n\n  public deleteComment = (options: {\n    threadId: string;\n    commentId: string;\n    softDelete?: boolean;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(\n      `/${threadId}/comments/${commentId}?soft=${!!rest.softDelete}`,\n      \"DELETE\",\n    );\n  };\n\n  public deleteThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}`, \"DELETE\");\n  };\n\n  public resolveThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}/resolve`, \"POST\");\n  };\n\n  public unresolveThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}/unresolve`, \"POST\");\n  };\n\n  public addReaction = (options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(\n      `/${threadId}/comments/${commentId}/reactions`,\n      \"POST\",\n      rest,\n    );\n  };\n\n  public deleteReaction = (options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) => {\n    return this.doRequest(\n      `/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      \"DELETE\",\n    );\n  };\n}\n","import { v4 } from \"uuid\";\nimport * as Y from \"yjs\";\nimport { CommentBody, CommentData, ThreadData } from \"../../types.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { YjsThreadStoreBase } from \"./YjsThreadStoreBase.js\";\nimport {\n  commentToYMap,\n  threadToYMap,\n  yMapToComment,\n  yMapToThread,\n} from \"./yjsHelpers.js\";\n\n/**\n * This is a Yjs-based implementation of the ThreadStore interface.\n *\n * It reads and writes thread / comments information directly to the underlying Yjs Document.\n *\n * @important While this is the easiest to add to your app, there are two challenges:\n * - The user needs to be able to write to the Yjs document to store the information.\n *   So a user without write access to the Yjs document cannot leave any comments.\n * - Even with write access, the operations are not secure. Unless your Yjs server\n *   guards against malicious operations, it's technically possible for one user to make changes to another user's comments, etc.\n *   (even though these options are not visible in the UI, a malicious user can make unauthorized changes to the underlying Yjs document)\n */\nexport class YjsThreadStore extends YjsThreadStoreBase {\n  constructor(\n    private readonly userId: string,\n    threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(threadsYMap, auth);\n  }\n\n  private transact = <T, R>(\n    fn: (options: T) => R,\n  ): ((options: T) => Promise<R>) => {\n    return async (options: T) => {\n      return this.threadsYMap.doc!.transact(() => {\n        return fn(options);\n      });\n    };\n  };\n\n  public createThread = this.transact(\n    (options: {\n      initialComment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      metadata?: any;\n    }) => {\n      if (!this.auth.canCreateThread()) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n\n      const comment: CommentData = {\n        type: \"comment\",\n        id: v4(),\n        userId: this.userId,\n        createdAt: date,\n        updatedAt: date,\n        reactions: [],\n        metadata: options.initialComment.metadata,\n        body: options.initialComment.body,\n      };\n\n      const thread: ThreadData = {\n        type: \"thread\",\n        id: v4(),\n        createdAt: date,\n        updatedAt: date,\n        comments: [comment],\n        resolved: false,\n        metadata: options.metadata,\n      };\n\n      this.threadsYMap.set(thread.id, threadToYMap(thread));\n\n      return thread;\n    },\n  );\n\n  // YjsThreadStore does not support addThreadToDocument\n  public addThreadToDocument = undefined;\n\n  public addComment = this.transact(\n    (options: {\n      comment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      threadId: string;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      if (!this.auth.canAddComment(yMapToThread(yThread))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n      const comment: CommentData = {\n        type: \"comment\",\n        id: v4(),\n        userId: this.userId,\n        createdAt: date,\n        updatedAt: date,\n        deletedAt: undefined,\n        reactions: [],\n        metadata: options.comment.metadata,\n        body: options.comment.body,\n      };\n\n      (yThread.get(\"comments\") as Y.Array<Y.Map<any>>).push([\n        commentToYMap(comment),\n      ]);\n\n      yThread.set(\"updatedAt\", new Date().getTime());\n      return comment;\n    },\n  );\n\n  public updateComment = this.transact(\n    (options: {\n      comment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      threadId: string;\n      commentId: string;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canUpdateComment(yMapToComment(yComment))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      yComment.set(\"body\", options.comment.body);\n      yComment.set(\"updatedAt\", new Date().getTime());\n      yComment.set(\"metadata\", options.comment.metadata);\n    },\n  );\n\n  public deleteComment = this.transact(\n    (options: {\n      threadId: string;\n      commentId: string;\n      softDelete?: boolean;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canDeleteComment(yMapToComment(yComment))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      if (yComment.get(\"deletedAt\")) {\n        throw new Error(\"Comment already deleted\");\n      }\n\n      if (options.softDelete) {\n        yComment.set(\"deletedAt\", new Date().getTime());\n        yComment.set(\"body\", undefined);\n      } else {\n        yThread.get(\"comments\").delete(yCommentIndex);\n      }\n\n      if (\n        (yThread.get(\"comments\") as Y.Array<any>)\n          .toArray()\n          .every((comment) => comment.get(\"deletedAt\"))\n      ) {\n        // all comments deleted\n        if (options.softDelete) {\n          yThread.set(\"deletedAt\", new Date().getTime());\n        } else {\n          this.threadsYMap.delete(options.threadId);\n        }\n      }\n\n      yThread.set(\"updatedAt\", new Date().getTime());\n    },\n  );\n\n  public deleteThread = this.transact((options: { threadId: string }) => {\n    if (\n      !this.auth.canDeleteThread(\n        yMapToThread(this.threadsYMap.get(options.threadId)),\n      )\n    ) {\n      throw new Error(\"Not authorized\");\n    }\n\n    this.threadsYMap.delete(options.threadId);\n  });\n\n  public resolveThread = this.transact((options: { threadId: string }) => {\n    const yThread = this.threadsYMap.get(options.threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    if (!this.auth.canResolveThread(yMapToThread(yThread))) {\n      throw new Error(\"Not authorized\");\n    }\n\n    yThread.set(\"resolved\", true);\n    yThread.set(\"resolvedUpdatedAt\", new Date().getTime());\n    yThread.set(\"resolvedBy\", this.userId);\n  });\n\n  public unresolveThread = this.transact((options: { threadId: string }) => {\n    const yThread = this.threadsYMap.get(options.threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    if (!this.auth.canUnresolveThread(yMapToThread(yThread))) {\n      throw new Error(\"Not authorized\");\n    }\n\n    yThread.set(\"resolved\", false);\n    yThread.set(\"resolvedUpdatedAt\", new Date().getTime());\n  });\n\n  public addReaction = this.transact(\n    (options: { threadId: string; commentId: string; emoji: string }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canAddReaction(yMapToComment(yComment), options.emoji)) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n\n      const key = `${this.userId}-${options.emoji}`;\n\n      const reactionsByUser = yComment.get(\"reactionsByUser\");\n\n      if (reactionsByUser.has(key)) {\n        // already exists\n        return;\n      } else {\n        const reaction = new Y.Map();\n        reaction.set(\"emoji\", options.emoji);\n        reaction.set(\"createdAt\", date.getTime());\n        reaction.set(\"userId\", this.userId);\n        reactionsByUser.set(key, reaction);\n      }\n    },\n  );\n\n  public deleteReaction = this.transact(\n    (options: { threadId: string; commentId: string; emoji: string }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (\n        !this.auth.canDeleteReaction(yMapToComment(yComment), options.emoji)\n      ) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const key = `${this.userId}-${options.emoji}`;\n\n      const reactionsByUser = yComment.get(\"reactionsByUser\");\n\n      reactionsByUser.delete(key);\n    },\n  );\n}\n\nfunction yArrayFindIndex(\n  yArray: Y.Array<any>,\n  predicate: (item: any) => boolean,\n) {\n  for (let i = 0; i < yArray.length; i++) {\n    if (predicate(yArray.get(i))) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"names":["CommentMark","Mark","element","attributes","HTMLAttributes","mergeAttributes","extension","UserStore","EventEmitter","resolveUsers","__publicField","userIds","missingUsers","id","users","user","userId","cb","PLUGIN_KEY","PluginKey","getUpdatedThreadPositions","doc","markType","threadPositions","node","pos","mark","thisThreadId","from","to","currentPosition","CommentsExtension","createExtension","editor","commentEditorSchema","threadStore","userStore","store","createStore","tr","updateMarksFromThreads","threads","markTypeInstance","markThreadId","thread","isOrphan","trimmedFrom","trimmedTo","prev","Plugin","DecorationSet","state","action","newThreadPositions","decorations","selectedThreadPosition","Decoration","_a","view","event","commentMark","threadId","unsubscribe","unsubscribeOnSelectionChange","scrollToThread","_b","ShowSelectionExtension","options","pmSelection","ystate","ySyncPluginKey","selection","getRelativeSelection","ThreadStoreAuth","DefaultThreadStoreAuth","role","_thread","comment","emoji","reaction","ThreadStore","auth","TiptapThreadStore","provider","reactions","existingReaction","r","_c","newCb","commentToYMap","yMap","Y","threadToYMap","commentsArray","yMapToReaction","yMapToReactions","acc","yMapToComment","yMapToThread","YjsThreadStoreBase","threadsYMap","yThread","threadMap","observer","RESTYjsThreadStore","BASE_URL","headers","path","method","body","response","rest","commentId","YjsThreadStore","fn","date","v4","yCommentIndex","yArrayFindIndex","yComment","key","reactionsByUser","yArray","predicate","i"],"mappings":"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"}},
    {"offset": {"line": 915, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/blockToNode-DBNbhwwC.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/UniqueID/UniqueID.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/inlineContent/types.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/table.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/typescript.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/getBlockInfoFromPos.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/pmUtil.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/nodeConversions/nodeToBlock.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/tables/tables.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/nodeConversions/blockToNode.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  Extension,\n  findChildrenInRange,\n  getChangedRanges,\n} from \"@tiptap/core\";\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { v4 } from \"uuid\";\n\n/**\n * Code from Tiptap UniqueID extension (https://tiptap.dev/api/extensions/unique-id)\n * This extension is licensed under MIT (even though it's part of Tiptap pro).\n *\n * If you're a user of BlockNote, we still recommend to support their awesome work and become a sponsor!\n * https://tiptap.dev/pro\n */\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array: any, by = JSON.stringify) {\n  const seen: any = {};\n  return array.filter((item: any) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true);\n  });\n}\n\n/**\n * Returns a list of duplicated items within an array.\n */\nfunction findDuplicates(items: any) {\n  const filtered = items.filter(\n    (el: any, index: number) => items.indexOf(el) !== index,\n  );\n  const duplicates = removeDuplicates(filtered);\n  return duplicates;\n}\n\nconst UniqueID = Extension.create({\n  name: \"uniqueID\",\n  // weâ€™ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      setIdAttribute: false,\n      generateID: () => {\n        // Use mock ID if tests are running.\n        if (typeof window !== \"undefined\" && (window as any).__TEST_OPTIONS) {\n          const testOptions = (window as any).__TEST_OPTIONS;\n          if (testOptions.mockID === undefined) {\n            testOptions.mockID = 0;\n          } else {\n            testOptions.mockID++;\n          }\n\n          return testOptions.mockID.toString() as string;\n        }\n\n        return v4();\n      },\n      filterTransaction: null,\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (element) =>\n              element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (attributes) => {\n              const defaultIdAttributes = {\n                [`data-${this.options.attributeName}`]:\n                  attributes[this.options.attributeName],\n              };\n              if (this.options.setIdAttribute) {\n                return {\n                  ...defaultIdAttributes,\n                  id: attributes[this.options.attributeName],\n                };\n              } else {\n                return defaultIdAttributes;\n              }\n            },\n          },\n        },\n      },\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Donâ€™t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let dragSourceElement: any = null;\n    let transformPasted = false;\n    return [\n      new Plugin({\n        key: new PluginKey(\"uniqueID\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges =\n            transactions.some((transaction) => transaction.docChanged) &&\n            !oldState.doc.eq(newState.doc);\n          const filterTransactions =\n            this.options.filterTransaction &&\n            transactions.some((tr) => !this.options.filterTransaction?.(tr));\n          if (!docChanges || filterTransactions) {\n            return;\n          }\n          const { tr } = newState;\n          const { types, attributeName, generateID } = this.options;\n          const transform = combineTransactionSteps(\n            oldState.doc,\n            transactions as any,\n          );\n          const { mapping } = transform;\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform);\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(\n              newState.doc,\n              newRange,\n              (node) => {\n                return types.includes(node.type.name);\n              },\n            );\n            const newIds = newNodes\n              .map(({ node }) => node.attrs[attributeName])\n              .filter((id) => id !== null);\n            const duplicatedNewIds = findDuplicates(newIds);\n\n            newNodes.forEach(({ node, pos }) => {\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id = tr.doc.nodeAt(pos)?.attrs[attributeName];\n\n              if (id === null) {\n                // edge case, when using collaboration, yjs will set the id to null in `_forceRerender`\n                // when loading the editor\n                // this checks for this case and keeps it at initialBlockId so there will be no change\n                const initialDoc = oldState.doc.type.createAndFill()!.content;\n                const wasInitial =\n                  oldState.doc.content.findDiffStart(initialDoc) === null;\n\n                if (wasInitial) {\n                  // the old state was the \"initial content\"\n                  const jsonNode = JSON.parse(\n                    JSON.stringify(newState.doc.toJSON()),\n                  );\n                  jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n                  // would the new state with the fix also be the \"initial content\"?\n                  if (\n                    JSON.stringify(jsonNode.content) ===\n                    JSON.stringify(initialDoc.toJSON())\n                  ) {\n                    // yes, apply the fix\n                    tr.setNodeMarkup(pos, undefined, {\n                      ...node.attrs,\n                      [attributeName]: \"initialBlockId\",\n                    });\n                    return;\n                  }\n                }\n\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n                return;\n              }\n              // check if the node doesnâ€™t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos);\n              const newNode = deleted && duplicatedNewIds.includes(id);\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n              }\n            });\n          });\n          if (!tr.steps.length) {\n            return;\n          }\n          // mark the transaction as having been processed by the uniqueID plugin\n          tr.setMeta(\"uniqueID\", true);\n          return tr;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: any) => {\n            let _a;\n            dragSourceElement = (\n              (_a = view.dom.parentElement) === null || _a === void 0\n                ? void 0\n                : _a.contains(event.target)\n            )\n              ? view.dom.parentElement\n              : null;\n          };\n          window.addEventListener(\"dragstart\", handleDragstart);\n          return {\n            destroy() {\n              window.removeEventListener(\"dragstart\", handleDragstart);\n            },\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted` so we can do\n          // some checks before. However, `transformPasted` only runs when\n          // editor content is pasted - not external content.\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event: any) => {\n              let _a;\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                ((_a = event.dataTransfer) === null || _a === void 0\n                  ? void 0\n                  : _a.effectAllowed) === \"copy\"\n              ) {\n                transformPasted = true;\n              } else {\n                transformPasted = false;\n              }\n\n              dragSourceElement = null;\n\n              return false;\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true;\n              return false;\n            },\n          },\n          // weâ€™ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (slice) => {\n            if (!transformPasted) {\n              return slice;\n            }\n            const { types, attributeName } = this.options;\n            const removeId = (fragment: any) => {\n              const list: any[] = [];\n              fragment.forEach((node: any) => {\n                // donâ€™t touch text nodes\n                if (node.isText) {\n                  list.push(node);\n                  return;\n                }\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)));\n                  return;\n                }\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks,\n                );\n                list.push(nodeWithoutId);\n              });\n              return Fragment.from(list);\n            };\n            // reset check\n            transformPasted = false;\n            return new Slice(\n              removeId(slice.content),\n              slice.openStart,\n              slice.openEnd,\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport { UniqueID as default, UniqueID };\n","import { Node } from \"@tiptap/core\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport { StyleSchema, Styles } from \"../styles/types.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { ViewMutationRecord } from \"prosemirror-view\";\n\nexport type CustomInlineContentConfig = {\n  type: string;\n  content: \"styled\" | \"none\"; // | \"plain\"\n  readonly propSchema: PropSchema;\n};\n// InlineContentConfig contains the \"schema\" info about an InlineContent type\n// i.e. what props it supports, what content it supports, etc.\nexport type InlineContentConfig = CustomInlineContentConfig | \"text\" | \"link\";\n\n// InlineContentImplementation contains the \"implementation\" info about an InlineContent element\n// such as the functions / Nodes required to render and / or serialize it\n// @ts-ignore\nexport type InlineContentImplementation<T extends InlineContentConfig> =\n  T extends \"link\" | \"text\"\n    ? undefined\n    : {\n        meta?: {\n          draggable?: boolean;\n        };\n        node: Node;\n        toExternalHTML?: (\n          inlineContent: any,\n          editor: BlockNoteEditor<any, any, any>,\n        ) =>\n          | {\n              dom: HTMLElement | DocumentFragment;\n              contentDOM?: HTMLElement;\n            }\n          | undefined;\n        render: (\n          inlineContent: any,\n          updateInlineContent: (update: any) => void,\n          editor: BlockNoteEditor<any, any, any>,\n        ) => {\n          dom: HTMLElement | DocumentFragment;\n          contentDOM?: HTMLElement;\n          ignoreMutation?: (mutation: ViewMutationRecord) => boolean;\n          destroy?: () => void;\n        };\n        runsBefore?: string[];\n      };\n\nexport type InlineContentSchemaWithInlineContent<\n  IType extends string,\n  C extends InlineContentConfig,\n> = {\n  [k in IType]: C;\n};\n\n// Container for both the config and implementation of InlineContent,\n// and the type of `implementation` is based on that of the config\nexport type InlineContentSpec<T extends InlineContentConfig> = {\n  config: T;\n  implementation: InlineContentImplementation<T>;\n};\n\n// A Schema contains all the types (Configs) supported in an editor\n// The keys are the \"type\" of InlineContent elements\nexport type InlineContentSchema = Record<string, InlineContentConfig>;\n\nexport type InlineContentSpecs = {\n  text: { config: \"text\"; implementation: undefined };\n  link: { config: \"link\"; implementation: undefined };\n} & Record<string, InlineContentSpec<InlineContentConfig>>;\n\nexport type InlineContentSchemaFromSpecs<T extends InlineContentSpecs> = {\n  [K in keyof T]: T[K][\"config\"];\n};\n\nexport type CustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  type: I[\"type\"];\n  props: Props<I[\"propSchema\"]>;\n  content: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[]\n    : I[\"content\"] extends \"plain\"\n      ? string\n      : I[\"content\"] extends \"none\"\n        ? undefined\n        : never;\n};\n\nexport type InlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema,\n> = I extends \"text\"\n  ? StyledText<S>\n  : I extends \"link\"\n    ? Link<S>\n    : I extends CustomInlineContentConfig\n      ? CustomInlineContentFromConfig<I, S>\n      : never;\n\nexport type PartialCustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  type: I[\"type\"];\n  props?: Props<I[\"propSchema\"]>;\n  content?: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[] | string\n    : I[\"content\"] extends \"plain\"\n      ? string\n      : I[\"content\"] extends \"none\"\n        ? undefined\n        : never;\n};\n\nexport type PartialInlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema,\n> = I extends \"text\"\n  ? string | StyledText<S>\n  : I extends \"link\"\n    ? PartialLink<S>\n    : I extends CustomInlineContentConfig\n      ? PartialCustomInlineContentFromConfig<I, S>\n      : never;\n\nexport type StyledText<T extends StyleSchema> = {\n  type: \"text\";\n  text: string;\n  styles: Styles<T>;\n};\n\nexport type Link<T extends StyleSchema> = {\n  type: \"link\";\n  href: string;\n  content: StyledText<T>[];\n};\n\nexport type PartialLink<T extends StyleSchema> = Omit<Link<T>, \"content\"> & {\n  content: string | Link<T>[\"content\"];\n};\n\nexport type InlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = InlineContentFromConfig<I[keyof I], T>;\n\ntype PartialInlineContentElement<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = PartialInlineContentFromConfig<I[keyof I], T>;\n\nexport type PartialInlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = PartialInlineContentElement<I, T>[] | string;\n\nexport function isLinkInlineContent<T extends StyleSchema>(\n  content: InlineContent<any, T>,\n): content is Link<T> {\n  return content.type === \"link\";\n}\n\nexport function isPartialLinkInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>,\n): content is PartialLink<T> {\n  return typeof content !== \"string\" && content.type === \"link\";\n}\n\nexport function isStyledTextInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>,\n): content is StyledText<T> {\n  return typeof content !== \"string\" && content.type === \"text\";\n}\n","import type {\n  InlineContentSchema,\n  StyleSchema,\n  PartialInlineContent,\n  InlineContent,\n} from \"../schema\";\nimport { PartialTableCell, TableCell } from \"../schema/blocks/types.js\";\n\n/**\n * This will map a table cell to a TableCell object.\n * This is useful for when we want to get the full table cell object from a partial table cell.\n * It is guaranteed to return a new TableCell object.\n */\nexport function mapTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | TableCell<T, S>,\n): TableCell<T, S> {\n  return isTableCell(content)\n    ? { ...content }\n    : isPartialTableCell(content)\n      ? {\n          type: \"tableCell\",\n          content: ([] as InlineContent<T, S>[]).concat(content.content as any),\n          props: {\n            backgroundColor: content.props?.backgroundColor ?? \"default\",\n            textColor: content.props?.textColor ?? \"default\",\n            textAlignment: content.props?.textAlignment ?? \"left\",\n            colspan: content.props?.colspan ?? 1,\n            rowspan: content.props?.rowspan ?? 1,\n          },\n        }\n      : {\n          type: \"tableCell\",\n          content: ([] as InlineContent<T, S>[]).concat(content as any),\n          props: {\n            backgroundColor: \"default\",\n            textColor: \"default\",\n            textAlignment: \"left\",\n            colspan: 1,\n            rowspan: 1,\n          },\n        };\n}\n\nexport function isPartialTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | TableCell<T, S>\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | undefined\n    | null,\n): content is PartialTableCell<T, S> {\n  return (\n    content !== undefined &&\n    content !== null &&\n    typeof content !== \"string\" &&\n    !Array.isArray(content) &&\n    content.type === \"tableCell\"\n  );\n}\n\nexport function isTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | TableCell<T, S>\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | undefined\n    | null,\n): content is TableCell<T, S> {\n  return (\n    isPartialTableCell(content) &&\n    content.props !== undefined &&\n    content.content !== undefined\n  );\n}\n\nexport function getColspan(\n  cell:\n    | TableCell<any, any>\n    | PartialTableCell<any, any>\n    | PartialInlineContent<any, any>,\n): number {\n  if (isTableCell(cell)) {\n    return cell.props.colspan ?? 1;\n  }\n  return 1;\n}\n\nexport function getRowspan(\n  cell:\n    | TableCell<any, any>\n    | PartialTableCell<any, any>\n    | PartialInlineContent<any, any>,\n): number {\n  if (isTableCell(cell)) {\n    return cell.props.rowspan ?? 1;\n  }\n  return 1;\n}\n","export class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n\nexport function assertEmpty(obj: Record<string, never>, throwError = true) {\n  const { \"data-test\": dataTest, ...rest } = obj; // exclude data-test\n\n  if (Object.keys(rest).length > 0 && throwError) {\n    throw new Error(\"Object must be empty \" + JSON.stringify(obj));\n  }\n}\n\n// TODO: change for built-in version of typescript 5.4 after upgrade\nexport type NoInfer<T> = [T][T extends any ? 0 : never];\n","import { Node, ResolvedPos } from \"prosemirror-model\";\nimport { EditorState, Transaction } from \"prosemirror-state\";\n\ntype SingleBlockInfo = {\n  node: Node;\n  beforePos: number;\n  afterPos: number;\n};\n\nexport type BlockInfo = {\n  /**\n   * The outer node that represents a BlockNote block. This is the node that has the ID.\n   * Most of the time, this will be a blockContainer node, but it could also be a Column or ColumnList\n   */\n  bnBlock: SingleBlockInfo;\n  /**\n   * The type of BlockNote block that this node represents.\n   * When dealing with a blockContainer, this is retrieved from the blockContent node, otherwise it's retrieved from the bnBlock node.\n   */\n  blockNoteType: string;\n} & (\n  | {\n      // In case we're not dealing with a BlockContainer, we're dealing with a \"wrapper node\" (like a Column or ColumnList), so it will always have children\n\n      /**\n       * The Prosemirror node that holds block.children. For non-blockContainer, this node will be the same as bnBlock.\n       */\n      childContainer: SingleBlockInfo;\n      isBlockContainer: false;\n    }\n  | {\n      /**\n       * The Prosemirror node that holds block.children. For blockContainers, this is the blockGroup node, if it exists.\n       */\n      childContainer?: SingleBlockInfo;\n      /**\n       * The Prosemirror node that wraps block.content and has most of the props\n       */\n      blockContent: SingleBlockInfo;\n      /**\n       * Whether bnBlock is a blockContainer node\n       */\n      isBlockContainer: true;\n    }\n);\n\n/**\n * Retrieves the position just before the nearest block node in a ProseMirror\n * doc, relative to a position. If the position is within a block node or its\n * descendants, the position just before it is returned. If the position is not\n * within a block node or its descendants, the position just before the next\n * closest block node is returned. If the position is beyond the last block, the\n * position just before the last block is returned.\n * @param doc The ProseMirror doc.\n * @param pos An integer position in the document.\n * @returns The position just before the nearest blockContainer node.\n */\nexport function getNearestBlockPos(doc: Node, pos: number) {\n  const $pos = doc.resolve(pos);\n\n  // Checks if the position provided is already just before a block node, in\n  // which case we return the position.\n  if ($pos.nodeAfter && $pos.nodeAfter.type.isInGroup(\"bnBlock\")) {\n    return {\n      posBeforeNode: $pos.pos,\n      node: $pos.nodeAfter,\n    };\n  }\n\n  // Checks the node containing the position and its ancestors until a\n  // block node is found and returned.\n  let depth = $pos.depth;\n  let node = $pos.node(depth);\n  while (depth > 0) {\n    if (node.type.isInGroup(\"bnBlock\")) {\n      return {\n        posBeforeNode: $pos.before(depth),\n        node: node,\n      };\n    }\n\n    depth--;\n    node = $pos.node(depth);\n  }\n\n  // If the position doesn't lie within a block node, we instead find the\n  // position of the next closest one. If the position is beyond the last block,\n  // we return the position of the last block. While running `doc.descendants`\n  // is expensive, this case should be very rarely triggered. However, it's\n  // possible for the position to sometimes be beyond the last block node. This\n  // is a problem specifically when using the collaboration plugin.\n  const allBlockContainerPositions: number[] = [];\n  doc.descendants((node, pos) => {\n    if (node.type.isInGroup(\"bnBlock\")) {\n      allBlockContainerPositions.push(pos);\n    }\n  });\n\n  // eslint-disable-next-line no-console\n  console.warn(`Position ${pos} is not within a blockContainer node.`);\n\n  const resolvedPos = doc.resolve(\n    allBlockContainerPositions.find((position) => position >= pos) ||\n      allBlockContainerPositions[allBlockContainerPositions.length - 1],\n  );\n  return {\n    posBeforeNode: resolvedPos.pos,\n    node: resolvedPos.nodeAfter!,\n  };\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block in a\n * BlockNote document. This includes the main `blockContainer` node, the\n * `blockContent` node with the block's main body, and the optional `blockGroup`\n * node which contains the block's children. As well as the nodes, also returns\n * the ProseMirror positions just before & after each node.\n * @param node The main `blockContainer` node that the block information should\n * be retrieved from,\n * @param bnBlockBeforePosOffset the position just before the\n * `blockContainer` node in the document.\n */\nexport function getBlockInfoWithManualOffset(\n  node: Node,\n  bnBlockBeforePosOffset: number,\n): BlockInfo {\n  if (!node.type.isInGroup(\"bnBlock\")) {\n    throw new Error(\n      `Attempted to get bnBlock node at position but found node of different type ${node.type.name}`,\n    );\n  }\n\n  const bnBlockNode = node;\n  const bnBlockBeforePos = bnBlockBeforePosOffset;\n  const bnBlockAfterPos = bnBlockBeforePos + bnBlockNode.nodeSize;\n\n  const bnBlock: SingleBlockInfo = {\n    node: bnBlockNode,\n    beforePos: bnBlockBeforePos,\n    afterPos: bnBlockAfterPos,\n  };\n\n  if (bnBlockNode.type.name === \"blockContainer\") {\n    let blockContent: SingleBlockInfo | undefined;\n    let blockGroup: SingleBlockInfo | undefined;\n\n    bnBlockNode.forEach((node, offset) => {\n      if (node.type.spec.group === \"blockContent\") {\n        // console.log(beforePos, offset);\n        const blockContentNode = node;\n        const blockContentBeforePos = bnBlockBeforePos + offset + 1;\n        const blockContentAfterPos = blockContentBeforePos + node.nodeSize;\n\n        blockContent = {\n          node: blockContentNode,\n          beforePos: blockContentBeforePos,\n          afterPos: blockContentAfterPos,\n        };\n      } else if (node.type.name === \"blockGroup\") {\n        const blockGroupNode = node;\n        const blockGroupBeforePos = bnBlockBeforePos + offset + 1;\n        const blockGroupAfterPos = blockGroupBeforePos + node.nodeSize;\n\n        blockGroup = {\n          node: blockGroupNode,\n          beforePos: blockGroupBeforePos,\n          afterPos: blockGroupAfterPos,\n        };\n      }\n    });\n\n    if (!blockContent) {\n      throw new Error(\n        `blockContainer node does not contain a blockContent node in its children: ${bnBlockNode}`,\n      );\n    }\n\n    return {\n      isBlockContainer: true,\n      bnBlock,\n      blockContent,\n      childContainer: blockGroup,\n      blockNoteType: blockContent.node.type.name,\n    };\n  } else {\n    if (!bnBlock.node.type.isInGroup(\"childContainer\")) {\n      throw new Error(\n        `bnBlock node is not in the childContainer group: ${bnBlock.node}`,\n      );\n    }\n\n    return {\n      isBlockContainer: false,\n      bnBlock: bnBlock,\n      childContainer: bnBlock,\n      blockNoteType: bnBlock.node.type.name,\n    };\n  }\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block in a\n * BlockNote document. This includes the main `blockContainer` node, the\n * `blockContent` node with the block's main body, and the optional `blockGroup`\n * node which contains the block's children. As well as the nodes, also returns\n * the ProseMirror positions just before & after each node.\n * @param posInfo An object with the main `blockContainer` node that the block\n * information should be retrieved from, and the position just before it in the\n * document.\n */\nexport function getBlockInfo(posInfo: { posBeforeNode: number; node: Node }) {\n  return getBlockInfoWithManualOffset(posInfo.node, posInfo.posBeforeNode);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block from a\n * resolved position just before the `blockContainer` node in the document that\n * corresponds to it.\n * @param resolvedPos The resolved position just before the `blockContainer`\n * node.\n */\nexport function getBlockInfoFromResolvedPos(resolvedPos: ResolvedPos) {\n  if (!resolvedPos.nodeAfter) {\n    throw new Error(\n      `Attempted to get blockContainer node at position ${resolvedPos.pos} but a node at this position does not exist`,\n    );\n  }\n  return getBlockInfoWithManualOffset(resolvedPos.nodeAfter, resolvedPos.pos);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block. The\n * block chosen is the one currently containing the current ProseMirror\n * selection.\n * @param state The ProseMirror editor state.\n */\nexport function getBlockInfoFromSelection(state: EditorState) {\n  const posInfo = getNearestBlockPos(state.doc, state.selection.anchor);\n\n  return getBlockInfo(posInfo);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block. The\n * block chosen is the one currently containing the current ProseMirror\n * selection.\n * @param tr The ProseMirror transaction.\n */\nexport function getBlockInfoFromTransaction(tr: Transaction) {\n  const posInfo = getNearestBlockPos(tr.doc, tr.selection.anchor);\n\n  return getBlockInfo(posInfo);\n}\n","import type { Node, Schema } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport type { BlockSchema } from \"../schema/blocks/types.js\";\nimport type { InlineContentSchema } from \"../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../schema/styles/types.js\";\n\nexport function getPmSchema(trOrNode: Transform | Node) {\n  if (\"doc\" in trOrNode) {\n    return trOrNode.doc.type.schema;\n  }\n  return trOrNode.type.schema;\n}\n\nfunction getBlockNoteEditor<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(schema: Schema): BlockNoteEditor<BSchema, I, S> {\n  return schema.cached.blockNoteEditor as BlockNoteEditor<BSchema, I, S>;\n}\n\nexport function getBlockNoteSchema<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(schema: Schema): BlockNoteSchema<BSchema, I, S> {\n  return getBlockNoteEditor(schema).schema as unknown as BlockNoteSchema<\n    BSchema,\n    I,\n    S\n  >;\n}\n\nexport function getBlockSchema<BSchema extends BlockSchema>(\n  schema: Schema,\n): BSchema {\n  return getBlockNoteSchema(schema).blockSchema as BSchema;\n}\n\nexport function getInlineContentSchema<I extends InlineContentSchema>(\n  schema: Schema,\n): I {\n  return getBlockNoteSchema(schema).inlineContentSchema as I;\n}\n\nexport function getStyleSchema<S extends StyleSchema>(schema: Schema): S {\n  return getBlockNoteSchema(schema).styleSchema as S;\n}\n\nexport function getBlockCache(schema: Schema) {\n  return getBlockNoteEditor(schema).blockCache;\n}\n","import { Mark, Node, Schema, Slice } from \"@tiptap/pm/model\";\nimport type { Block } from \"../../blocks/defaultBlocks.js\";\nimport UniqueID from \"../../extensions/tiptap-extensions/UniqueID/UniqueID.js\";\nimport type {\n  BlockSchema,\n  CustomInlineContentConfig,\n  CustomInlineContentFromConfig,\n  InlineContent,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n  Styles,\n  TableCell,\n  TableContent,\n} from \"../../schema/index.js\";\nimport {\n  isLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types.js\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { getBlockInfoWithManualOffset } from \"../getBlockInfoFromPos.js\";\nimport {\n  getBlockCache,\n  getBlockSchema,\n  getInlineContentSchema,\n  getPmSchema,\n  getStyleSchema,\n} from \"../pmUtil.js\";\n\n/**\n * Converts an internal (prosemirror) table node contentto a BlockNote Tablecontent\n */\nexport function contentNodeToTableContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const ret: TableContent<I, S> = {\n    type: \"tableContent\",\n    columnWidths: [],\n    headerRows: undefined,\n    headerCols: undefined,\n    rows: [],\n  };\n\n  /**\n   * A matrix of boolean values indicating whether a cell is a header.\n   * The first index is the row index, the second index is the cell index.\n   */\n  const headerMatrix: boolean[][] = [];\n\n  contentNode.content.forEach((rowNode, _offset, rowIndex) => {\n    const row: TableContent<I, S>[\"rows\"][0] = {\n      cells: [],\n    };\n\n    if (rowIndex === 0) {\n      rowNode.content.forEach((cellNode) => {\n        let colWidth = cellNode.attrs.colwidth as null | undefined | number[];\n        if (colWidth === undefined || colWidth === null) {\n          colWidth = new Array(cellNode.attrs.colspan ?? 1).fill(undefined);\n        }\n        ret.columnWidths.push(...colWidth);\n      });\n    }\n\n    row.cells = rowNode.content.content.map((cellNode, cellIndex) => {\n      if (!headerMatrix[rowIndex]) {\n        headerMatrix[rowIndex] = [];\n      }\n      // Mark the cell as a header if it is a tableHeader node.\n      headerMatrix[rowIndex][cellIndex] = cellNode.type.name === \"tableHeader\";\n      // Convert cell content to inline content and merge adjacent styled text nodes\n      const content = cellNode.content.content\n        .map((child) =>\n          contentNodeToInlineContent(child, inlineContentSchema, styleSchema),\n        )\n        // The reason that we merge this content is that we allow table cells to contain multiple tableParagraph nodes\n        // So that we can leverage prosemirror-tables native merging\n        // If the schema only allowed a single tableParagraph node, then the merging would not work and cause prosemirror to fit the content into a new cell\n        .reduce(\n          (acc, contentPartial) => {\n            if (!acc.length) {\n              return contentPartial;\n            }\n\n            const last = acc[acc.length - 1];\n            const first = contentPartial[0];\n\n            // Only merge if the last and first content are both styled text nodes and have the same styles\n            if (\n              first &&\n              isStyledTextInlineContent(last) &&\n              isStyledTextInlineContent(first) &&\n              JSON.stringify(last.styles) === JSON.stringify(first.styles)\n            ) {\n              // Join them together if they have the same styles\n              last.text += \"\\n\" + first.text;\n              acc.push(...contentPartial.slice(1));\n              return acc;\n            }\n            acc.push(...contentPartial);\n            return acc;\n          },\n          [] as InlineContent<I, S>[],\n        );\n\n      return {\n        type: \"tableCell\",\n        content,\n        props: {\n          colspan: cellNode.attrs.colspan,\n          rowspan: cellNode.attrs.rowspan,\n          backgroundColor: cellNode.attrs.backgroundColor,\n          textColor: cellNode.attrs.textColor,\n          textAlignment: cellNode.attrs.textAlignment,\n        },\n      } satisfies TableCell<I, S>;\n    });\n\n    ret.rows.push(row);\n  });\n\n  for (let i = 0; i < headerMatrix.length; i++) {\n    if (headerMatrix[i]?.every((isHeader) => isHeader)) {\n      ret.headerRows = (ret.headerRows ?? 0) + 1;\n    }\n  }\n\n  for (let i = 0; i < headerMatrix[0]?.length; i++) {\n    if (headerMatrix?.every((row) => row[i])) {\n      ret.headerCols = (ret.headerCols ?? 0) + 1;\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Converts an internal (prosemirror) content node to a BlockNote InlineContent array.\n */\nexport function contentNodeToInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const content: InlineContent<any, S>[] = [];\n  let currentContent: InlineContent<any, S> | undefined = undefined;\n\n  // Most of the logic below is for handling links because in ProseMirror links are marks\n  // while in BlockNote links are a type of inline content\n  contentNode.content.forEach((node) => {\n    // hardBreak nodes do not have an InlineContent equivalent, instead we\n    // add a newline to the previous node.\n    if (node.type.name === \"hardBreak\") {\n      if (currentContent) {\n        // Current content exists.\n        if (isStyledTextInlineContent(currentContent)) {\n          // Current content is text.\n          currentContent.text += \"\\n\";\n        } else if (isLinkInlineContent(currentContent)) {\n          // Current content is a link.\n          currentContent.content[currentContent.content.length - 1].text +=\n            \"\\n\";\n        } else {\n          throw new Error(\"unexpected\");\n        }\n      } else {\n        // Current content does not exist.\n        currentContent = {\n          type: \"text\",\n          text: \"\\n\",\n          styles: {},\n        };\n      }\n\n      return;\n    }\n\n    if (node.type.name !== \"link\" && node.type.name !== \"text\") {\n      if (!inlineContentSchema[node.type.name]) {\n        // eslint-disable-next-line no-console\n        console.warn(\"unrecognized inline content type\", node.type.name);\n        return;\n      }\n      if (currentContent) {\n        content.push(currentContent);\n        currentContent = undefined;\n      }\n\n      content.push(\n        nodeToCustomInlineContent(node, inlineContentSchema, styleSchema),\n      );\n\n      return;\n    }\n\n    const styles: Styles<S> = {};\n    let linkMark: Mark | undefined;\n\n    for (const mark of node.marks) {\n      if (mark.type.name === \"link\") {\n        linkMark = mark;\n      } else {\n        const config = styleSchema[mark.type.name];\n        if (!config) {\n          if (mark.type.spec.blocknoteIgnore) {\n            // at this point, we don't want to show certain marks (such as comments)\n            // in the BlockNote JSON output. These marks should be tagged with \"blocknoteIgnore\" in the spec\n            continue;\n          }\n          throw new Error(`style ${mark.type.name} not found in styleSchema`);\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else if (config.propSchema === \"string\") {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        } else {\n          throw new UnreachableCaseError(config.propSchema);\n        }\n      }\n    }\n\n    // Parsing links and text.\n    // Current content exists.\n    if (currentContent) {\n      // Current content is text.\n      if (isStyledTextInlineContent(currentContent)) {\n        if (!linkMark) {\n          // Node is text (same type as current content).\n          if (\n            JSON.stringify(currentContent.styles) === JSON.stringify(styles)\n          ) {\n            // Styles are the same.\n            currentContent.text += node.textContent;\n          } else {\n            // Styles are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            };\n          }\n        } else {\n          // Node is a link (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"link\",\n            href: linkMark.attrs.href,\n            content: [\n              {\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              },\n            ],\n          };\n        }\n      } else if (isLinkInlineContent(currentContent)) {\n        // Current content is a link.\n        if (linkMark) {\n          // Node is a link (same type as current content).\n          // Link URLs are the same.\n          if (currentContent.href === linkMark.attrs.href) {\n            // Styles are the same.\n            if (\n              JSON.stringify(\n                currentContent.content[currentContent.content.length - 1]\n                  .styles,\n              ) === JSON.stringify(styles)\n            ) {\n              currentContent.content[currentContent.content.length - 1].text +=\n                node.textContent;\n            } else {\n              // Styles are different.\n              currentContent.content.push({\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              });\n            }\n          } else {\n            // Link URLs are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"link\",\n              href: linkMark.attrs.href,\n              content: [\n                {\n                  type: \"text\",\n                  text: node.textContent,\n                  styles,\n                },\n              ],\n            };\n          }\n        } else {\n          // Node is text (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"text\",\n            text: node.textContent,\n            styles,\n          };\n        }\n      } else {\n        // TODO\n      }\n    }\n    // Current content does not exist.\n    else {\n      // Node is text.\n      if (!linkMark) {\n        currentContent = {\n          type: \"text\",\n          text: node.textContent,\n          styles,\n        };\n      }\n      // Node is a link.\n      else {\n        currentContent = {\n          type: \"link\",\n          href: linkMark.attrs.href,\n          content: [\n            {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            },\n          ],\n        };\n      }\n    }\n  });\n\n  if (currentContent) {\n    content.push(currentContent);\n  }\n\n  return content as InlineContent<I, S>[];\n}\n\nexport function nodeToCustomInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(node: Node, inlineContentSchema: I, styleSchema: S): InlineContent<I, S> {\n  if (node.type.name === \"text\" || node.type.name === \"link\") {\n    throw new Error(\"unexpected\");\n  }\n  const props: any = {};\n  const icConfig = inlineContentSchema[\n    node.type.name\n  ] as CustomInlineContentConfig;\n  for (const [attr, value] of Object.entries(node.attrs)) {\n    if (!icConfig) {\n      throw Error(\"ic node is of an unrecognized type: \" + node.type.name);\n    }\n\n    const propSchema = icConfig.propSchema;\n\n    if (attr in propSchema) {\n      props[attr] = value;\n    }\n  }\n\n  let content: CustomInlineContentFromConfig<any, any>[\"content\"];\n\n  if (icConfig.content === \"styled\") {\n    content = contentNodeToInlineContent(\n      node,\n      inlineContentSchema,\n      styleSchema,\n    ) as any; // TODO: is this safe? could we have Links here that are undesired?\n  } else {\n    content = undefined;\n  }\n\n  const ic = {\n    type: node.type.name,\n    props,\n    content,\n  } as InlineContentFromConfig<I[keyof I], S>;\n  return ic;\n}\n\n/**\n * Convert a Prosemirror node to a BlockNote block.\n *\n * TODO: test changes\n */\nexport function nodeToBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  node: Node,\n  schema: Schema,\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache = getBlockCache(schema),\n): Block<BSchema, I, S> {\n  if (!node.type.isInGroup(\"bnBlock\")) {\n    throw Error(\"Node should be a bnBlock, but is instead: \" + node.type.name);\n  }\n\n  const cachedBlock = blockCache?.get(node);\n\n  if (cachedBlock) {\n    return cachedBlock;\n  }\n\n  const blockInfo = getBlockInfoWithManualOffset(node, 0);\n\n  let id = blockInfo.bnBlock.node.attrs.id;\n\n  // Only used for blocks converted from other formats.\n  if (id === null) {\n    id = UniqueID.options.generateID();\n  }\n\n  const blockSpec = blockSchema[blockInfo.blockNoteType];\n\n  if (!blockSpec) {\n    throw Error(\"Block is of an unrecognized type: \" + blockInfo.blockNoteType);\n  }\n\n  const props: any = {};\n  for (const [attr, value] of Object.entries({\n    ...node.attrs,\n    ...(blockInfo.isBlockContainer ? blockInfo.blockContent.node.attrs : {}),\n  })) {\n    const propSchema = blockSpec.propSchema;\n\n    if (\n      attr in propSchema &&\n      !(propSchema[attr].default === undefined && value === undefined)\n    ) {\n      props[attr] = value;\n    }\n  }\n\n  const blockConfig = blockSchema[blockInfo.blockNoteType];\n\n  const children: Block<BSchema, I, S>[] = [];\n  blockInfo.childContainer?.node.forEach((child) => {\n    children.push(\n      nodeToBlock(\n        child,\n        schema,\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache,\n      ),\n    );\n  });\n\n  let content: Block<any, any, any>[\"content\"];\n\n  if (blockConfig.content === \"inline\") {\n    if (!blockInfo.isBlockContainer) {\n      throw new Error(\"impossible\");\n    }\n    content = contentNodeToInlineContent(\n      blockInfo.blockContent.node,\n      inlineContentSchema,\n      styleSchema,\n    );\n  } else if (blockConfig.content === \"table\") {\n    if (!blockInfo.isBlockContainer) {\n      throw new Error(\"impossible\");\n    }\n    content = contentNodeToTableContent(\n      blockInfo.blockContent.node,\n      inlineContentSchema,\n      styleSchema,\n    );\n  } else if (blockConfig.content === \"none\") {\n    content = undefined;\n  } else {\n    throw new UnreachableCaseError(blockConfig.content);\n  }\n\n  const block = {\n    id,\n    type: blockConfig.type,\n    props,\n    content,\n    children,\n  } as Block<BSchema, I, S>;\n\n  blockCache?.set(node, block);\n\n  return block;\n}\n\n/**\n * Convert a Prosemirror document to a BlockNote document (array of blocks)\n */\nexport function docToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  schema: Schema = getPmSchema(doc),\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache = getBlockCache(schema),\n) {\n  const blocks: Block<BSchema, I, S>[] = [];\n  if (doc.firstChild) {\n    doc.firstChild.descendants((node) => {\n      blocks.push(\n        nodeToBlock(\n          node,\n          schema,\n          blockSchema,\n          inlineContentSchema,\n          styleSchema,\n          blockCache,\n        ),\n      );\n      return false;\n    });\n  }\n  return blocks;\n}\n\n/**\n *\n * Parse a Prosemirror Slice into a BlockNote selection. The prosemirror schema looks like this:\n *\n * <blockGroup>\n *   <blockContainer> (main content of block)\n *       <p, heading, etc.>\n *   <blockGroup> (only if blocks has children)\n *     <blockContainer> (child block)\n *       <p, heading, etc.>\n *     </blockContainer>\n *    <blockContainer> (child block 2)\n *       <p, heading, etc.>\n *     </blockContainer>\n *   </blockContainer>\n *  </blockGroup>\n * </blockGroup>\n *\n */\nexport function prosemirrorSliceToSlicedBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  slice: Slice,\n  schema: Schema,\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache: WeakMap<Node, Block<BSchema, I, S>> = getBlockCache(schema),\n): {\n  /**\n   * The blocks that are included in the selection.\n   */\n  blocks: Block<BSchema, I, S>[];\n  /**\n   * If a block was \"cut\" at the start of the selection, this will be the id of the block that was cut.\n   */\n  blockCutAtStart: string | undefined;\n  /**\n   * If a block was \"cut\" at the end of the selection, this will be the id of the block that was cut.\n   */\n  blockCutAtEnd: string | undefined;\n} {\n  // console.log(JSON.stringify(slice.toJSON()));\n  function processNode(\n    node: Node,\n    openStart: number,\n    openEnd: number,\n  ): {\n    blocks: Block<BSchema, I, S>[];\n    blockCutAtStart: string | undefined;\n    blockCutAtEnd: string | undefined;\n  } {\n    if (node.type.name !== \"blockGroup\") {\n      throw new Error(\"unexpected\");\n    }\n    const blocks: Block<BSchema, I, S>[] = [];\n    let blockCutAtStart: string | undefined;\n    let blockCutAtEnd: string | undefined;\n\n    node.forEach((blockContainer, _offset, index) => {\n      if (blockContainer.type.name !== \"blockContainer\") {\n        throw new Error(\"unexpected\");\n      }\n      if (blockContainer.childCount === 0) {\n        return;\n      }\n      if (blockContainer.childCount === 0 || blockContainer.childCount > 2) {\n        throw new Error(\n          \"unexpected, blockContainer.childCount: \" + blockContainer.childCount,\n        );\n      }\n\n      const isFirstBlock = index === 0;\n      const isLastBlock = index === node.childCount - 1;\n\n      if (blockContainer.firstChild!.type.name === \"blockGroup\") {\n        // this is the parent where a selection starts within one of its children,\n        // e.g.:\n        // A\n        // â”œâ”€â”€ B\n        // selection starts within B, then this blockContainer is A, but we don't care about A\n        // so let's descend into B and continue processing\n        if (!isFirstBlock) {\n          throw new Error(\"unexpected\");\n        }\n        const ret = processNode(\n          blockContainer.firstChild!,\n          Math.max(0, openStart - 1),\n          isLastBlock ? Math.max(0, openEnd - 1) : 0,\n        );\n        blockCutAtStart = ret.blockCutAtStart;\n        if (isLastBlock) {\n          blockCutAtEnd = ret.blockCutAtEnd;\n        }\n        blocks.push(...ret.blocks);\n        return;\n      }\n\n      const block = nodeToBlock(\n        blockContainer,\n        schema,\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache,\n      );\n      const childGroup =\n        blockContainer.childCount > 1 ? blockContainer.child(1) : undefined;\n\n      let childBlocks: Block<BSchema, I, S>[] = [];\n      if (childGroup) {\n        const ret = processNode(\n          childGroup,\n          0, // TODO: can this be anything other than 0?\n          isLastBlock ? Math.max(0, openEnd - 1) : 0,\n        );\n        childBlocks = ret.blocks;\n        if (isLastBlock) {\n          blockCutAtEnd = ret.blockCutAtEnd;\n        }\n      }\n\n      if (isLastBlock && !childGroup && openEnd > 1) {\n        blockCutAtEnd = block.id;\n      }\n\n      if (isFirstBlock && openStart > 1) {\n        blockCutAtStart = block.id;\n      }\n\n      blocks.push({\n        ...(block as any),\n        children: childBlocks,\n      });\n    });\n\n    return { blocks, blockCutAtStart, blockCutAtEnd };\n  }\n\n  if (slice.content.childCount === 0) {\n    return {\n      blocks: [],\n      blockCutAtStart: undefined,\n      blockCutAtEnd: undefined,\n    };\n  }\n\n  if (slice.content.childCount !== 1) {\n    throw new Error(\n      \"slice must be a single block, did you forget includeParents=true?\",\n    );\n  }\n\n  return processNode(\n    slice.content.firstChild!,\n    Math.max(slice.openStart - 1, 0),\n    Math.max(slice.openEnd - 1, 0),\n  );\n}\n","import { DefaultBlockSchema } from \"../../../blocks/defaultBlocks.js\";\nimport {\n  BlockFromConfigNoChildren,\n  PartialTableContent,\n  TableCell,\n  TableContent,\n} from \"../../../schema/blocks/types.js\";\nimport {\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../../schema/index.js\";\nimport {\n  getColspan,\n  getRowspan,\n  isPartialTableCell,\n  mapTableCell,\n} from \"../../../util/table.js\";\n\n/**\n * Here be dragons.\n *\n * Tables are complex because of rowspan and colspan behavior.\n * The majority of this file is concerned with translating between \"relative\" and \"absolute\" indices.\n *\n * The following diagram may help explain the relationship between the different indices:\n *\n *  One-based indexing of rows and columns in a table:\n *  | 1-1 | 1-2 | 1-3 |\n *  | 2-1 | 2-2 | 2-3 |\n *  | 3-1 | 3-2 | 3-3 |\n *\n *  A complicated table with colspans and rowspans:\n *  | 1-1 | 1-2 | 1-2 |\n *  | 2-1 | 2-1 | 2-2 |\n *  | 2-1 | 2-1 | 3-1 |\n *\n * You can see here that we have:\n *  - two cells that contain the value \"1-2\", because it has a colspan of 2.\n *  - four cells that contain the value \"2-1\", because it has a rowspan of 2 and a colspan of 2.\n *\n * This would be represented in block note json (roughly) as:\n *  [\n *      {\n *       \"cells\": [\n *         {\n *           \"type\": \"tableCell\",\n *             \"content\": [\"1,1\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1\n *             },\n *           },\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"1,2\"],\n *             \"props\": {\n *               \"colspan\": 2,\n *               \"rowspan\": 1\n *             }\n *           }\n *         ],\n *       },\n *       {\n *         \"cells\": [\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"2,1\"],\n *             \"props\": {\n *                 \"colspan\": 2,\n *                 \"rowspan\": 2\n *               }\n *             },\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"2,2\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1\n *            }\n *         ],\n *       },\n *       {\n *         \"cells\": [\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"3,1\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1,\n *             }\n *           }\n *         ]\n *       }\n *     ]\n *\n * Which maps cleanly to the following HTML:\n *\n * <table>\n *   <tr>\n *     <td>1-1</td>\n *     <td colspan=\"2\">1-2</td>\n *   </tr>\n *   <tr>\n *     <td rowspan=\"2\" colspan=\"2\">2-1</td>\n *     <td>2-2</td>\n *   </tr>\n *   <tr>\n *     <td>3-1</td>\n *   </tr>\n * </table>\n *\n * We have a problem though, from the block json, there is no way to tell that the cell \"2-1\" is the second cell in the second row.\n * To resolve this, we created the occupancy grid, which is a grid of all the cells in the table, as though they were only 1x1 cells.\n * See {@link OccupancyGrid} for more information.\n *\n */\n\n/**\n * Relative cell indices are relative to the table block's content.\n *\n * This is a sparse representation of the table and is how HTML and BlockNote JSON represent tables.\n *\n * For example, if we have a table with a rowspan of 2, the second row may only have 1 element in a 2x2 table.\n *\n * ```\n * // Visual representation of the table\n *     | 1-1 | 1-2 | // has 2 cells\n *     | 1-1 | 2-2 | // has only 1 cell\n * // Relative cell indices\n *     [{ row: 1, col: 1, rowspan: 2 }, { row: 1, col: 2 }] // has 2 cells\n *     [{ row: 1, col: 2 }] // has only 1 cell\n * ```\n */\nexport type RelativeCellIndices = {\n  row: number;\n  col: number;\n};\n\n/**\n * Absolute cell indices are relative to the table's layout (it's {@link OccupancyGrid}).\n *\n * It is as though the table is a grid of 1x1 cells, and any colspan or rowspan results in multiple 1x1 cells being occupied.\n *\n * For example, if we have a table with a colspan of 2, it will occupy 2 cells in the layout grid.\n *\n * ```\n * // Visual representation of the table\n *     | 1-1 | 1-1 | // has 2 cells\n *     | 2-1 | 2-2 | // has 2 cell\n * // Absolute cell indices\n *     [{ row: 1, col: 1, colspan: 2 }, { row: 1, col: 2, colspan: 2 }] // has 2 cells\n *     [{ row: 1, col: 1 }, { row: 1, col: 2 }] // has 2 cells\n * ```\n */\nexport type AbsoluteCellIndices = {\n  row: number;\n  col: number;\n};\n\n/**\n * An occupancy grid is a grid of the occupied cells in the table.\n * It is used to track the occupied cells in the table to know where to place the next cell.\n *\n * Since it allows us to resolve cell indices both {@link RelativeCellIndices} and {@link AbsoluteCellIndices}, it is the core data structure for table operations.\n */\ntype OccupancyGrid = (RelativeCellIndices & {\n  /**\n   * The rowspan of the cell.\n   */\n  rowspan: number;\n  /**\n   * The colspan of the cell.\n   */\n  colspan: number;\n  /**\n   * The cell.\n   */\n  cell: TableCell<any, any>;\n})[][];\n\n/**\n * This will return the {@link OccupancyGrid} of the table.\n * By laying out the table as though it were a grid of 1x1 cells, we can easily track where the cells are located (both relatively and absolutely).\n *\n * @returns an {@link OccupancyGrid}\n */\nexport function getTableCellOccupancyGrid(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n): OccupancyGrid {\n  const { height, width } = getDimensionsOfTable(block);\n\n  /**\n   * Create a grid to track occupied cells\n   * This is used because rowspans and colspans take up multiple spaces\n   * So, we need to track the occupied cells in the grid to know where to place the next cell\n   */\n  const grid: OccupancyGrid = new Array(height)\n    .fill(false)\n    .map(() => new Array(width).fill(null));\n\n  // Find the next unoccupied cell in the table, row-major order\n  const findNextAvailable = (row: number, col: number) => {\n    for (let i = row; i < height; i++) {\n      for (let j = col; j < width; j++) {\n        if (!grid[i][j]) {\n          return { row: i, col: j };\n        }\n      }\n    }\n\n    throw new Error(\n      \"Unable to create occupancy grid for table, no more available cells\",\n    );\n  };\n\n  // Build up the grid, trying to fill in the cells with the correct relative row and column indices\n  for (let row = 0; row < block.content.rows.length; row++) {\n    for (let col = 0; col < block.content.rows[row].cells.length; col++) {\n      const cell = mapTableCell(block.content.rows[row].cells[col]);\n      const rowspan = getRowspan(cell);\n      const colspan = getColspan(cell);\n\n      // Rowspan and colspan complicate things, by taking up multiple cells in the grid\n      // We need to iterate over the cells that the rowspan and colspan take up\n      // and fill in the grid with the correct relative row and column indices\n      const { row: startRow, col: startCol } = findNextAvailable(row, col);\n\n      // Fill in the rowspan X colspan cells, starting from the next available cell, with the correct relative row and column indices\n      for (let i = startRow; i < startRow + rowspan; i++) {\n        for (let j = startCol; j < startCol + colspan; j++) {\n          if (grid[i][j]) {\n            // The cell is already occupied, the table is malformed\n            throw new Error(\n              `Unable to create occupancy grid for table, cell at ${i},${j} is already occupied`,\n            );\n          }\n\n          grid[i][j] = {\n            row,\n            col,\n            rowspan,\n            colspan,\n            cell,\n          };\n        }\n      }\n    }\n  }\n\n  // console.log(grid);\n\n  return grid;\n}\n\n/**\n * Given an {@link OccupancyGrid}, this will return the {@link TableContent} rows.\n *\n * @note This will remove duplicates from the occupancy grid. And does no bounds checking for validity of the occupancy grid.\n */\nexport function getTableRowsFromOccupancyGrid(\n  occupancyGrid: OccupancyGrid,\n): TableContent<any, any>[\"rows\"] {\n  // Because a cell can have a rowspan or colspan, it can occupy multiple cells in the occupancy grid\n  // So, we need to remove duplicates from the occupancy grid before we can return the table rows\n  const seen = new Set<string>();\n\n  return occupancyGrid.map((row) => {\n    // Just read out the cells in the occupancy grid, removing duplicates\n    return {\n      cells: row\n        .map((cell) => {\n          if (seen.has(cell.row + \":\" + cell.col)) {\n            return false;\n          }\n          seen.add(cell.row + \":\" + cell.col);\n          return cell.cell;\n        })\n        .filter((cell): cell is TableCell<any, any> => cell !== false),\n    };\n  });\n}\n\n/**\n * This will resolve the relative cell indices within the table block to the absolute cell indices within the table, accounting for colspan and rowspan.\n *\n * @note It will return only the first cell (i.e. top-left) that matches the relative cell indices. To find the other absolute cell indices this cell occupies, you can assume it is the rowspan and colspan number of cells away from the top-left cell.\n *\n * @returns The {@link AbsoluteCellIndices} and the {@link TableCell} at the absolute position.\n */\nexport function getAbsoluteTableCells(\n  /**\n   * The relative position of the cell in the table.\n   */\n  relativeCellIndices: RelativeCellIndices,\n  /**\n   * The table block containing the cell.\n   */\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  /**\n   * The occupancy grid of the table.\n   */\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): AbsoluteCellIndices & {\n  cell: TableCell<any, any>;\n} {\n  for (let r = 0; r < occupancyGrid.length; r++) {\n    for (let c = 0; c < occupancyGrid[r].length; c++) {\n      // console.log(r, c, occupancyGrid);\n      const cell = occupancyGrid[r][c];\n      if (\n        cell.row === relativeCellIndices.row &&\n        cell.col === relativeCellIndices.col\n      ) {\n        return { row: r, col: c, cell: cell.cell };\n      }\n    }\n  }\n\n  throw new Error(\n    `Unable to resolve relative table cell indices for table, cell at ${relativeCellIndices.row},${relativeCellIndices.col} is not occupied`,\n  );\n}\n\n/**\n * This will get the dimensions of the table block.\n *\n * @returns The height and width of the table.\n */\nexport function getDimensionsOfTable(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n): {\n  /**\n   * The number of rows in the table.\n   */\n  height: number;\n  /**\n   * The number of columns in the table.\n   */\n  width: number;\n} {\n  // Due to the way we store the table, the height is always the number of rows\n  const height = block.content.rows.length;\n\n  // Calculating the width is a bit more complex, as it is the maximum width of any row\n  let width = 0;\n  block.content.rows.forEach((row) => {\n    // Find the width of the row by summing the colspan of each cell\n    let rowWidth = 0;\n    row.cells.forEach((cell) => {\n      rowWidth += getColspan(cell);\n    });\n\n    // Update the width if the row is wider than the current width\n    width = Math.max(width, rowWidth);\n  });\n\n  return { height, width };\n}\n\n/**\n * This will resolve the absolute cell indices within the table block to the relative cell indices within the table, accounting for colspan and rowspan.\n *\n * @returns The {@link RelativeCellIndices} and the {@link TableCell} at the relative position.\n */\nexport function getRelativeTableCells(\n  /**\n   * The {@link AbsoluteCellIndices} of the cell in the table.\n   */\n  absoluteCellIndices: AbsoluteCellIndices,\n  /**\n   * The table block containing the cell.\n   */\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  /**\n   * The occupancy grid of the table.\n   */\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n):\n  | (RelativeCellIndices & {\n      cell: TableContent<any, any>[\"rows\"][number][\"cells\"][number];\n    })\n  | undefined {\n  const occupancyCell =\n    occupancyGrid[absoluteCellIndices.row]?.[absoluteCellIndices.col];\n\n  // Double check that the cell can be accessed\n  if (!occupancyCell) {\n    // The cell is not occupied, so it is invalid\n    return undefined;\n  }\n\n  return {\n    row: occupancyCell.row,\n    col: occupancyCell.col,\n    cell: occupancyCell.cell,\n  };\n}\n\n/**\n * This will get all the cells within a relative row of a table block.\n *\n * This method always starts the search for the row at the first column of the table.\n *\n * ```\n * // Visual representation of a table\n * | A | B | C |\n * |   | D | E |\n * | F | G | H |\n * // \"A\" has a rowspan of 2\n *\n * // getCellsAtRowHandle(0)\n * // returns [\n *  { row: 0, col: 0, cell: \"A\" },\n *  { row: 0, col: 1, cell: \"B\" },\n *  { row: 0, col: 2, cell: \"C\" },\n * ]\n *\n * // getCellsAtColumnHandle(1)\n * // returns [\n *  { row: 1, col: 0, cell: \"F\" },\n *  { row: 1, col: 1, cell: \"G\" },\n *  { row: 1, col: 2, cell: \"H\" },\n * ]\n * ```\n *\n * As you can see, you may not be able to retrieve all nodes given a relative row index, as cells can span multiple rows.\n *\n * @returns All of the cells associated with the relative row of the table. (All cells that have the same relative row index)\n */\nexport function getCellsAtRowHandle(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  relativeRowIndex: RelativeCellIndices[\"row\"],\n) {\n  const occupancyGrid = getTableCellOccupancyGrid(block);\n\n  if (relativeRowIndex < 0 || relativeRowIndex >= occupancyGrid.length) {\n    return [];\n  }\n\n  // First need to resolve the relative row index to an absolute row index\n  let absoluteRow = 0;\n\n  // Jump through the occupied cells ${relativeCellIndices.row} times to find the absolute row position\n  for (let i = 0; i < relativeRowIndex; i++) {\n    const cell = occupancyGrid[absoluteRow]?.[0];\n\n    if (!cell) {\n      return [];\n    }\n\n    // Skip the cells that the rowspan takes up\n    absoluteRow += cell.rowspan;\n  }\n\n  // Then for each column, get the cell at the absolute row index as a relative cell index\n  const cells = new Array(occupancyGrid[0].length)\n    .fill(false)\n    .map((_v, col) => {\n      return getRelativeTableCells(\n        { row: absoluteRow, col },\n        block,\n        occupancyGrid,\n      );\n    })\n    .filter(\n      (a): a is RelativeCellIndices & { cell: TableCell<any, any> } =>\n        a !== undefined,\n    );\n\n  // Filter out duplicates based on row and col properties\n  return cells.filter((cell, index) => {\n    return (\n      cells.findIndex((c) => c.row === cell.row && c.col === cell.col) === index\n    );\n  });\n}\n\n/**\n * This will get all the cells within a relative column of a table block.\n *\n * This method always starts the search for the column at the first row of the table.\n *\n * ```\n * // Visual representation of a table\n * |   A   | B |\n * | C | D | E |\n * | F | G | H |\n * // \"A\" has a colspan of 2\n *\n * // getCellsAtColumnHandle(0)\n * // returns [\n *  { row: 0, col: 0, cell: \"A\" },\n *  { row: 1, col: 0, cell: \"C\" },\n *  { row: 2, col: 0, cell: \"F\" },\n * ]\n *\n * // getCellsAtColumnHandle(1)\n * // returns [\n *  { row: 0, col: 1, cell: \"B\" },\n *  { row: 1, col: 2, cell: \"E\" },\n *  { row: 2, col: 2, cell: \"F\" },\n * ]\n * ```\n *\n * As you can see, you may not be able to retrieve all nodes given a relative column index, as cells can span multiple columns.\n *\n * @returns All of the cells associated with the relative column of the table. (All cells that have the same relative column index)\n */\nexport function getCellsAtColumnHandle(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  relativeColumnIndex: RelativeCellIndices[\"col\"],\n) {\n  const occupancyGrid = getTableCellOccupancyGrid(block);\n\n  if (\n    relativeColumnIndex < 0 ||\n    relativeColumnIndex >= occupancyGrid[0].length\n  ) {\n    return [];\n  }\n\n  // First need to resolve the relative column index to an absolute column index\n  let absoluteCol = 0;\n\n  // Now that we've already resolved the absolute row position, we can jump through the occupied cells ${relativeCellIndices.col} times to find the absolute column position\n  for (let i = 0; i < relativeColumnIndex; i++) {\n    const cell = occupancyGrid[0]?.[absoluteCol];\n\n    if (!cell) {\n      return [];\n    }\n\n    // Skip the cells that the colspan takes up\n    absoluteCol += cell.colspan;\n  }\n\n  // Then for each row, get the cell at the absolute column index as a relative cell index\n  const cells = new Array(occupancyGrid.length)\n    .fill(false)\n    .map((_v, row) => {\n      return getRelativeTableCells(\n        { row, col: absoluteCol },\n        block,\n        occupancyGrid,\n      );\n    })\n    .filter(\n      (a): a is RelativeCellIndices & { cell: TableCell<any, any> } =>\n        a !== undefined,\n    );\n\n  // Filter out duplicates based on row and col properties\n  return cells.filter((cell, index) => {\n    return (\n      cells.findIndex((c) => c.row === cell.row && c.col === cell.col) === index\n    );\n  });\n}\n\n/**\n * This moves a column from one index to another.\n *\n * @note This is a destructive operation, it will modify the provided {@link OccupancyGrid} in place.\n */\nexport function moveColumn(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  fromColIndex: RelativeCellIndices[\"col\"],\n  toColIndex: RelativeCellIndices[\"col\"],\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  // To move cells in a column, we need to layout the whole table\n  // and then move the cells accordingly.\n  const { col: absoluteSourceCol } = getAbsoluteTableCells(\n    {\n      row: 0,\n      col: fromColIndex,\n    },\n    block,\n    occupancyGrid,\n  );\n  const { col: absoluteTargetCol } = getAbsoluteTableCells(\n    {\n      row: 0,\n      col: toColIndex,\n    },\n    block,\n    occupancyGrid,\n  );\n\n  /**\n   * Currently, this function assumes that the caller has already checked that the source and target columns are valid.\n   * Such as by using {@link canColumnBeDraggedInto}. In the future, we may want to have the move logic be smarter\n   * and handle invalid column indices in some way.\n   */\n  occupancyGrid.forEach((row) => {\n    // Move the cell to the target column\n    const [sourceCell] = row.splice(absoluteSourceCol, 1);\n    row.splice(absoluteTargetCol, 0, sourceCell);\n  });\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This moves a row from one index to another.\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function moveRow(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  fromRowIndex: RelativeCellIndices[\"row\"],\n  toRowIndex: RelativeCellIndices[\"row\"],\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  // To move cells in a column, we need to layout the whole table\n  // and then move the cells accordingly.\n  const { row: absoluteSourceRow } = getAbsoluteTableCells(\n    {\n      row: fromRowIndex,\n      col: 0,\n    },\n    block,\n    occupancyGrid,\n  );\n  const { row: absoluteTargetRow } = getAbsoluteTableCells(\n    {\n      row: toRowIndex,\n      col: 0,\n    },\n    block,\n    occupancyGrid,\n  );\n\n  /**\n   * Currently, this function assumes that the caller has already checked that the source and target rows are valid.\n   * Such as by using {@link canRowBeDraggedInto}. In the future, we may want to have the move logic be smarter\n   * and handle invalid row indices in some way.\n   */\n  const [sourceRow] = occupancyGrid.splice(absoluteSourceRow, 1);\n  occupancyGrid.splice(absoluteTargetRow, 0, sourceRow);\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This will check if a cell is empty.\n *\n * @returns True if the cell is empty, false otherwise.\n */\nfunction isCellEmpty(\n  cell:\n    | PartialTableContent<any, any>[\"rows\"][number][\"cells\"][number]\n    | undefined,\n): boolean {\n  if (!cell) {\n    return true;\n  }\n  if (isPartialTableCell(cell)) {\n    return isCellEmpty(cell.content);\n  } else if (typeof cell === \"string\") {\n    return cell.length === 0;\n  } else if (Array.isArray(cell)) {\n    return cell.every((c) =>\n      typeof c === \"string\"\n        ? c.length === 0\n        : isStyledTextInlineContent(c)\n          ? c.text.length === 0\n          : isPartialLinkInlineContent(c)\n            ? typeof c.content === \"string\"\n              ? c.content.length === 0\n              : c.content.every((s) => s.text.length === 0)\n            : false,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * This will remove empty rows or columns from the table.\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function cropEmptyRowsOrColumns(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  removeEmpty: \"columns\" | \"rows\",\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  if (removeEmpty === \"columns\") {\n    // strips empty columns on the right\n    let emptyColsOnRight = 0;\n    for (\n      let cellIndex = occupancyGrid[0].length - 1;\n      cellIndex >= 0;\n      cellIndex--\n    ) {\n      const isEmpty = occupancyGrid.every(\n        (row) =>\n          isCellEmpty(row[cellIndex].cell) && row[cellIndex].colspan === 1,\n      );\n      if (!isEmpty) {\n        break;\n      }\n\n      emptyColsOnRight++;\n    }\n\n    for (let i = occupancyGrid.length - 1; i >= 0; i--) {\n      // We maintain at least one cell, even if all the cells are empty\n      const cellsToRemove = Math.max(\n        occupancyGrid[i].length - emptyColsOnRight,\n        1,\n      );\n      occupancyGrid[i] = occupancyGrid[i].slice(0, cellsToRemove);\n    }\n\n    return getTableRowsFromOccupancyGrid(occupancyGrid);\n  }\n\n  // strips empty rows at the bottom\n  let emptyRowsOnBottom = 0;\n  for (let rowIndex = occupancyGrid.length - 1; rowIndex >= 0; rowIndex--) {\n    const isEmpty = occupancyGrid[rowIndex].every(\n      (cell) => isCellEmpty(cell.cell) && cell.rowspan === 1,\n    );\n    if (!isEmpty) {\n      break;\n    }\n\n    emptyRowsOnBottom++;\n  }\n\n  // We maintain at least one row, even if all the rows are empty\n  const rowsToRemove = Math.min(emptyRowsOnBottom, occupancyGrid.length - 1);\n\n  occupancyGrid.splice(occupancyGrid.length - rowsToRemove, rowsToRemove);\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This will add a specified number of rows or columns to the table (filling with empty cells).\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function addRowsOrColumns(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  addType: \"columns\" | \"rows\",\n  /**\n   * The number of rows or columns to add.\n   *\n   * @note if negative, it will remove rows or columns.\n   */\n  numToAdd: number,\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  const { width, height } = getDimensionsOfTable(block);\n\n  if (addType === \"columns\") {\n    // Add empty columns to the right\n    occupancyGrid.forEach((row, rowIndex) => {\n      if (numToAdd >= 0) {\n        for (let i = 0; i < numToAdd; i++) {\n          row.push({\n            row: rowIndex,\n            col: Math.max(...row.map((r) => r.col)) + 1,\n            rowspan: 1,\n            colspan: 1,\n            cell: mapTableCell(\"\"),\n          });\n        }\n      } else {\n        // Remove columns on the right\n        row.splice(width + numToAdd, -1 * numToAdd);\n      }\n    });\n  } else {\n    if (numToAdd > 0) {\n      // Add empty rows to the bottom\n      for (let i = 0; i < numToAdd; i++) {\n        const newRow = new Array(width).fill(null).map((_, colIndex) => ({\n          row: height + i,\n          col: colIndex,\n          rowspan: 1,\n          colspan: 1,\n          cell: mapTableCell(\"\"),\n        }));\n        occupancyGrid.push(newRow);\n      }\n    } else if (numToAdd < 0) {\n      // Remove rows at the bottom\n      occupancyGrid.splice(height + numToAdd, -1 * numToAdd);\n    }\n  }\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * Checks if a row can be safely dropped at the target row index without splitting merged cells.\n */\nexport function canRowBeDraggedInto(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  draggingIndex: RelativeCellIndices[\"row\"],\n  targetRowIndex: RelativeCellIndices[\"row\"],\n) {\n  // Check cells at the target row\n  const targetCells = getCellsAtRowHandle(block, targetRowIndex);\n\n  // If no cells have rowspans > 1, dragging is always allowed\n  const hasMergedCells = targetCells.some((cell) => getRowspan(cell.cell) > 1);\n  if (!hasMergedCells) {\n    return true;\n  }\n\n  let endRowIndex = targetRowIndex;\n  let startRowIndex = targetRowIndex;\n  targetCells.forEach((cell) => {\n    const rowspan = getRowspan(cell.cell);\n    endRowIndex = Math.max(endRowIndex, cell.row + rowspan - 1);\n    startRowIndex = Math.min(startRowIndex, cell.row);\n  });\n\n  // Check the direction of the drag\n  const isDraggingDown = draggingIndex < targetRowIndex;\n\n  // Allow dragging only at the start/end of merged cells\n  // Otherwise, the target row was within a merged cell which we don't allow\n  return isDraggingDown\n    ? targetRowIndex === endRowIndex\n    : targetRowIndex === startRowIndex;\n}\n\n/**\n * Checks if a column can be safely dropped at the target column index without splitting merged cells.\n */\nexport function canColumnBeDraggedInto(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  draggingIndex: RelativeCellIndices[\"col\"],\n  targetColumnIndex: RelativeCellIndices[\"col\"],\n) {\n  // Check cells at the target column\n  const targetCells = getCellsAtColumnHandle(block, targetColumnIndex);\n\n  // If no cells have colspans > 1, dragging is always allowed\n  const hasMergedCells = targetCells.some((cell) => getColspan(cell.cell) > 1);\n  if (!hasMergedCells) {\n    return true;\n  }\n\n  let endColumnIndex = targetColumnIndex;\n  let startColumnIndex = targetColumnIndex;\n  targetCells.forEach((cell) => {\n    const colspan = getColspan(cell.cell);\n    endColumnIndex = Math.max(endColumnIndex, cell.col + colspan - 1);\n    startColumnIndex = Math.min(startColumnIndex, cell.col);\n  });\n\n  // Check the direction of the drag\n  const isDraggingRight = draggingIndex < targetColumnIndex;\n\n  // Allow dragging only at the start/end of merged cells\n  // Otherwise, the target column was within a merged cell which we don't allow\n  return isDraggingRight\n    ? targetColumnIndex === endColumnIndex\n    : targetColumnIndex === startColumnIndex;\n}\n\n/**\n * Checks if two cells are in the same column.\n *\n * @returns True if the cells are in the same column, false otherwise.\n */\nexport function areInSameColumn(\n  from: RelativeCellIndices,\n  to: RelativeCellIndices,\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n) {\n  // Table indices are relative to the table, so we need to resolve the absolute cell indices\n  const anchorAbsoluteCellIndices = getAbsoluteTableCells(from, block);\n\n  // Table indices are relative to the table, so we need to resolve the absolute cell indices\n  const headAbsoluteCellIndices = getAbsoluteTableCells(to, block);\n\n  // Compare the column indices to determine the merge direction\n  return anchorAbsoluteCellIndices.col === headAbsoluteCellIndices.col;\n}\n","import { Attrs, Fragment, Mark, Node, Schema } from \"@tiptap/pm/model\";\n\nimport UniqueID from \"../../extensions/tiptap-extensions/UniqueID/UniqueID.js\";\nimport type {\n  InlineContentSchema,\n  PartialCustomInlineContentFromConfig,\n  PartialInlineContent,\n  PartialLink,\n  PartialTableContent,\n  StyleSchema,\n  StyledText,\n} from \"../../schema\";\n\nimport type { PartialBlock } from \"../../blocks/defaultBlocks\";\nimport {\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types.js\";\nimport { getColspan, isPartialTableCell } from \"../../util/table.js\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { getAbsoluteTableCells } from \"../blockManipulation/tables/tables.js\";\nimport { getStyleSchema } from \"../pmUtil.js\";\n\n/**\n * Convert a StyledText inline element to a\n * prosemirror text node with the appropriate marks\n */\nfunction styledTextToNodes<T extends StyleSchema>(\n  styledText: StyledText<T>,\n  schema: Schema,\n  styleSchema: T,\n  blockType?: string,\n): Node[] {\n  const marks: Mark[] = [];\n\n  for (const [style, value] of Object.entries(styledText.styles || {})) {\n    const config = styleSchema[style];\n    if (!config) {\n      throw new Error(`style ${style} not found in styleSchema`);\n    }\n\n    if (config.propSchema === \"boolean\") {\n      if (value) {\n        marks.push(schema.mark(style));\n      }\n    } else if (config.propSchema === \"string\") {\n      if (value) {\n        marks.push(schema.mark(style, { stringValue: value }));\n      }\n    } else {\n      throw new UnreachableCaseError(config.propSchema);\n    }\n  }\n\n  const parseHardBreaks = !blockType || !schema.nodes[blockType].spec.code;\n\n  if (!parseHardBreaks) {\n    return styledText.text.length > 0\n      ? [schema.text(styledText.text, marks)]\n      : [];\n  }\n\n  return (\n    styledText.text\n      // Splits text & line breaks.\n      .split(/(\\n)/g)\n      // If the content ends with a line break, an empty string is added to the\n      // end, which this removes.\n      .filter((text) => text.length > 0)\n      // Converts text & line breaks to nodes.\n      .map((text) => {\n        if (text === \"\\n\") {\n          return schema.nodes[\"hardBreak\"].createChecked();\n        } else {\n          return schema.text(text, marks);\n        }\n      })\n  );\n}\n\n/**\n * Converts a Link inline content element to\n * prosemirror text nodes with the appropriate marks\n */\nfunction linkToNodes(\n  link: PartialLink<StyleSchema>,\n  schema: Schema,\n  styleSchema: StyleSchema,\n): Node[] {\n  const linkMark = schema.marks.link.create({\n    href: link.href,\n  });\n\n  return styledTextArrayToNodes(link.content, schema, styleSchema).map(\n    (node) => {\n      if (node.type.name === \"text\") {\n        return node.mark([...node.marks, linkMark]);\n      }\n\n      if (node.type.name === \"hardBreak\") {\n        return node;\n      }\n      throw new Error(\"unexpected node type\");\n    },\n  );\n}\n\n/**\n * Converts an array of StyledText inline content elements to\n * prosemirror text nodes with the appropriate marks\n */\nfunction styledTextArrayToNodes<S extends StyleSchema>(\n  content: string | StyledText<S>[],\n  schema: Schema,\n  styleSchema: S,\n  blockType?: string,\n): Node[] {\n  const nodes: Node[] = [];\n\n  if (typeof content === \"string\") {\n    nodes.push(\n      ...styledTextToNodes(\n        { type: \"text\", text: content, styles: {} },\n        schema,\n        styleSchema,\n        blockType,\n      ),\n    );\n    return nodes;\n  }\n\n  for (const styledText of content) {\n    nodes.push(\n      ...styledTextToNodes(styledText, schema, styleSchema, blockType),\n    );\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function inlineContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  blockContent: PartialInlineContent<I, S>,\n  schema: Schema,\n  blockType?: string,\n  styleSchema: S = getStyleSchema(schema),\n): Node[] {\n  const nodes: Node[] = [];\n\n  for (const content of blockContent) {\n    if (typeof content === \"string\") {\n      nodes.push(\n        ...styledTextArrayToNodes(content, schema, styleSchema, blockType),\n      );\n    } else if (isPartialLinkInlineContent(content)) {\n      nodes.push(...linkToNodes(content, schema, styleSchema));\n    } else if (isStyledTextInlineContent(content)) {\n      nodes.push(\n        ...styledTextArrayToNodes([content], schema, styleSchema, blockType),\n      );\n    } else {\n      nodes.push(\n        blockOrInlineContentToContentNode(content, schema, styleSchema),\n      );\n    }\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function tableContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tableContent: PartialTableContent<I, S>,\n  schema: Schema,\n  styleSchema: StyleSchema = getStyleSchema(schema),\n): Node[] {\n  const rowNodes: Node[] = [];\n  // Header rows and columns are used to determine the type of the cell\n  // If headerRows is 1, then the first row is a header row\n  const headerRows = new Array(tableContent.headerRows ?? 0).fill(true);\n  // If headerCols is 1, then the first column is a header column\n  const headerCols = new Array(tableContent.headerCols ?? 0).fill(true);\n\n  const columnWidths: (number | undefined)[] = tableContent.columnWidths ?? [];\n\n  for (let rowIndex = 0; rowIndex < tableContent.rows.length; rowIndex++) {\n    const row = tableContent.rows[rowIndex];\n    const columnNodes: Node[] = [];\n    const isHeaderRow = headerRows[rowIndex];\n    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\n      const cell = row.cells[cellIndex];\n      const isHeaderCol = headerCols[cellIndex];\n      /**\n       * The attributes of the cell to apply to the node\n       */\n      const attrs: Attrs | undefined = undefined;\n      /**\n       * The content of the cell to apply to the node\n       */\n      let content: Fragment | Node | readonly Node[] | null = null;\n\n      // Colwidths are absolutely referenced to the table, so we need to resolve the relative cell index to the absolute cell index\n      const absoluteCellIndex = getAbsoluteTableCells(\n        {\n          row: rowIndex,\n          col: cellIndex,\n        },\n        { type: \"table\", content: tableContent } as any,\n      );\n\n      // Assume the column width is the width of the cell at the absolute cell index\n      let colwidth: (number | undefined)[] | null = columnWidths[\n        absoluteCellIndex.col\n      ]\n        ? [columnWidths[absoluteCellIndex.col]]\n        : null;\n\n      if (!cell) {\n        // No-op\n      } else if (typeof cell === \"string\") {\n        content = schema.text(cell);\n      } else if (isPartialTableCell(cell)) {\n        if (cell.content) {\n          content = inlineContentToNodes(\n            cell.content,\n            schema,\n            \"tableParagraph\",\n            styleSchema,\n          );\n        }\n        const colspan = getColspan(cell);\n\n        if (colspan > 1) {\n          // If the cell has a > 1 colspan, we need to get the column width for each cell in the span\n          colwidth = new Array(colspan).fill(false).map((_, i) => {\n            // Starting from the absolute column index, get the column width for each cell in the span\n            return columnWidths[absoluteCellIndex.col + i] ?? undefined;\n          });\n        }\n      } else {\n        content = inlineContentToNodes(\n          cell,\n          schema,\n          \"tableParagraph\",\n          styleSchema,\n        );\n      }\n\n      const cellNode = schema.nodes[\n        isHeaderCol || isHeaderRow ? \"tableHeader\" : \"tableCell\"\n      ].createChecked(\n        {\n          ...(isPartialTableCell(cell) ? cell.props : {}),\n          colwidth,\n        },\n        schema.nodes[\"tableParagraph\"].createChecked(attrs, content),\n      );\n      columnNodes.push(cellNode);\n    }\n\n    const rowNode = schema.nodes[\"tableRow\"].createChecked({}, columnNodes);\n    rowNodes.push(rowNode);\n  }\n  return rowNodes;\n}\n\nfunction blockOrInlineContentToContentNode(\n  block:\n    | PartialBlock<any, any, any>\n    | PartialCustomInlineContentFromConfig<any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema,\n) {\n  let contentNode: Node;\n  let type = block.type;\n\n  // TODO: needed? came from previous code\n  if (type === undefined) {\n    type = \"paragraph\";\n  }\n\n  if (!schema.nodes[type]) {\n    throw new Error(`node type ${type} not found in schema`);\n  }\n\n  if (!block.content) {\n    contentNode = schema.nodes[type].createChecked(block.props);\n  } else if (typeof block.content === \"string\") {\n    const nodes = inlineContentToNodes(\n      [block.content],\n      schema,\n      type,\n      styleSchema,\n    );\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else if (Array.isArray(block.content)) {\n    const nodes = inlineContentToNodes(\n      block.content,\n      schema,\n      type,\n      styleSchema,\n    );\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else if (block.content.type === \"tableContent\") {\n    const nodes = tableContentToNodes(block.content, schema, styleSchema);\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else {\n    throw new UnreachableCaseError(block.content.type);\n  }\n  return contentNode;\n}\n\n/**\n * Converts a BlockNote block to a Prosemirror node.\n */\nexport function blockToNode(\n  block: PartialBlock<any, any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema = getStyleSchema(schema),\n) {\n  let id = block.id;\n\n  if (id === undefined) {\n    id = UniqueID.options.generateID();\n  }\n\n  const children: Node[] = [];\n\n  if (block.children) {\n    for (const child of block.children) {\n      children.push(blockToNode(child, schema, styleSchema));\n    }\n  }\n\n  const isBlockContent =\n    !block.type || // can happen if block.type is not defined (this should create the default node)\n    schema.nodes[block.type].isInGroup(\"blockContent\");\n\n  if (isBlockContent) {\n    // Blocks with a type that matches \"blockContent\" group always need to be wrapped in a blockContainer\n\n    const contentNode = blockOrInlineContentToContentNode(\n      block,\n      schema,\n      styleSchema,\n    );\n\n    const groupNode =\n      children.length > 0\n        ? schema.nodes[\"blockGroup\"].createChecked({}, children)\n        : undefined;\n\n    return schema.nodes[\"blockContainer\"].createChecked(\n      {\n        id: id,\n        ...block.props,\n      },\n      groupNode ? [contentNode, groupNode] : contentNode,\n    );\n  } else if (schema.nodes[block.type].isInGroup(\"bnBlock\")) {\n    // this is a bnBlock node like Column or ColumnList that directly translates to a prosemirror node\n    return schema.nodes[block.type].createChecked(\n      {\n        id: id,\n        ...block.props,\n      },\n      children,\n    );\n  } else {\n    throw new Error(\n      `block type ${block.type} doesn't match blockContent or bnBlock group`,\n    );\n  }\n}\n"],"names":["removeDuplicates","array","by","seen","item","key","findDuplicates","items","filtered","el","index","UniqueID","Extension","testOptions","v4","element","attributes","defaultIdAttributes","dragSourceElement","transformPasted","Plugin","PluginKey","transactions","oldState","newState","docChanges","transaction","filterTransactions","tr","_b","_a","types","attributeName","generateID","transform","combineTransactionSteps","mapping","getChangedRanges","newRange","newNodes","findChildrenInRange","node","newIds","id","duplicatedNewIds","pos","initialDoc","jsonNode","deleted","view","handleDragstart","event","slice","removeId","fragment","list","nodeWithoutId","Fragment","Slice","isLinkInlineContent","content","isPartialLinkInlineContent","isStyledTextInlineContent","mapTableCell","isTableCell","isPartialTableCell","_c","_d","_e","getColspan","cell","getRowspan","UnreachableCaseError","val","assertEmpty","obj","throwError","dataTest","rest","getNearestBlockPos","doc","$pos","depth","allBlockContainerPositions","resolvedPos","position","getBlockInfoWithManualOffset","bnBlockBeforePosOffset","bnBlockNode","bnBlockBeforePos","bnBlockAfterPos","bnBlock","blockContent","blockGroup","offset","blockContentNode","blockContentBeforePos","blockContentAfterPos","blockGroupNode","blockGroupBeforePos","blockGroupAfterPos","getBlockInfo","posInfo","getBlockInfoFromResolvedPos","getBlockInfoFromSelection","state","getBlockInfoFromTransaction","getPmSchema","trOrNode","getBlockNoteEditor","schema","getBlockNoteSchema","getBlockSchema","getInlineContentSchema","getStyleSchema","getBlockCache","contentNodeToTableContent","contentNode","inlineContentSchema","styleSchema","ret","headerMatrix","rowNode","_offset","rowIndex","row","cellNode","colWidth","cellIndex","child","contentNodeToInlineContent","acc","contentPartial","last","first","i","isHeader","currentContent","nodeToCustomInlineContent","styles","linkMark","mark","config","props","icConfig","attr","value","propSchema","nodeToBlock","blockSchema","blockCache","cachedBlock","blockInfo","blockSpec","blockConfig","children","block","docToBlocks","blocks","prosemirrorSliceToSlicedBlocks","processNode","openStart","openEnd","blockCutAtStart","blockCutAtEnd","blockContainer","isFirstBlock","isLastBlock","childGroup","childBlocks","getTableCellOccupancyGrid","height","width","getDimensionsOfTable","grid","findNextAvailable","col","j","rowspan","colspan","startRow","startCol","getTableRowsFromOccupancyGrid","occupancyGrid","getAbsoluteTableCells","relativeCellIndices","r","c","rowWidth","getRelativeTableCells","absoluteCellIndices","occupancyCell","getCellsAtRowHandle","relativeRowIndex","absoluteRow","cells","_v","a","getCellsAtColumnHandle","relativeColumnIndex","absoluteCol","moveColumn","fromColIndex","toColIndex","absoluteSourceCol","absoluteTargetCol","sourceCell","moveRow","fromRowIndex","toRowIndex","absoluteSourceRow","absoluteTargetRow","sourceRow","isCellEmpty","s","cropEmptyRowsOrColumns","removeEmpty","emptyColsOnRight","cellsToRemove","emptyRowsOnBottom","rowsToRemove","addRowsOrColumns","addType","numToAdd","newRow","_","colIndex","canRowBeDraggedInto","draggingIndex","targetRowIndex","targetCells","endRowIndex","startRowIndex","canColumnBeDraggedInto","targetColumnIndex","endColumnIndex","startColumnIndex","areInSameColumn","from","to","anchorAbsoluteCellIndices","headAbsoluteCellIndices","styledTextToNodes","styledText","blockType","marks","style","text","linkToNodes","link","styledTextArrayToNodes","nodes","inlineContentToNodes","blockOrInlineContentToContentNode","tableContentToNodes","tableContent","rowNodes","headerRows","headerCols","columnWidths","columnNodes","isHeaderRow","isHeaderCol","attrs","absoluteCellIndex","colwidth","type","blockToNode","groupNode"],"mappings":"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"}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/defaultBlocks-DgA_mtQV.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/browser.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/defaultBlockHelpers.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/string.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/blocks/internal.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/blocks/createSpec.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/inlineContent/internal.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/styles/internal.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/styles/createSpec.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/nodeUtil.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/updateBlock/updateBlock.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/defaultColors.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/defaultProps.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/parse/parseFigureElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/FilePanel/FilePanel.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/render/createAddFileButton.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/render/createFileNameWithIcon.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/render/createFileBlockWrapper.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/toExternalHTML/createFigureWithCaption.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/toExternalHTML/createLinkWithCaption.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Audio/parseAudioElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Audio/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Code/shiki.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Code/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Divider/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/parse/parseEmbedElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ToggleWrapper/createToggleWrapper.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Heading/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/render/createResizableFileBlockWrapper.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Image/parseImageElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Image/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/splitBlock/splitBlock.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/utils/listItemEnterHandler.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/getListItemContent.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/BulletListItem/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/CheckListItem/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/NumberedListItem/IndexingPlugin.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/NumberedListItem/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/ListItem/ToggleListItem/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Paragraph/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Quote/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Table/TableExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Table/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Video/parseVideoElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/Video/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/defaultBlockTypeGuards.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/positionMapping.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SuggestionMenu/SuggestionMenu.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SuggestionMenu/getDefaultSlashMenuItems.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/defaultBlocks.ts"],"sourcesContent":["export const isAppleOS = () =>\n  typeof navigator !== \"undefined\" &&\n  (/Mac/.test(navigator.platform) ||\n    (/AppleWebKit/.test(navigator.userAgent) &&\n      /Mobile\\/\\w+/.test(navigator.userAgent)));\n\nexport function formatKeyboardShortcut(shortcut: string, ctrlText = \"Ctrl\") {\n  if (isAppleOS()) {\n    return shortcut.replace(\"Mod\", \"âŒ˜\");\n  } else {\n    return shortcut.replace(\"Mod\", ctrlText);\n  }\n}\n\nexport function mergeCSSClasses(...classes: (string | false | undefined)[]) {\n  return [\n    // Converts to & from set to remove duplicates.\n    ...new Set(\n      classes\n        .filter((c) => c)\n        // Ensures that if multiple classes are passed as a single string, they\n        // are split.\n        .join(\" \")\n        .split(\" \"),\n    ),\n  ].join(\" \");\n}\n\nexport const isSafari = () =>\n  /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n","import { blockToNode } from \"../api/nodeConversions/blockToNode.js\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport type {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\n// Function that creates a ProseMirror `DOMOutputSpec` for a default block.\n// Since all default blocks have the same structure (`blockContent` div with a\n// `inlineContent` element inside), this function only needs the block's name\n// for the `data-content-type` attribute of the `blockContent` element and the\n// HTML tag of the `inlineContent` element, as well as any HTML attributes to\n// add to those.\nexport function createDefaultBlockDOMOutputSpec(\n  blockName: string,\n  htmlTag: string,\n  blockContentHTMLAttributes: Record<string, string>,\n  inlineContentHTMLAttributes: Record<string, string>,\n) {\n  const blockContent = document.createElement(\"div\");\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    blockContentHTMLAttributes.class,\n  );\n  blockContent.setAttribute(\"data-content-type\", blockName);\n  for (const [attribute, value] of Object.entries(blockContentHTMLAttributes)) {\n    if (attribute !== \"class\") {\n      blockContent.setAttribute(attribute, value);\n    }\n  }\n\n  const inlineContent = document.createElement(htmlTag);\n  inlineContent.className = mergeCSSClasses(\n    \"bn-inline-content\",\n    inlineContentHTMLAttributes.class,\n  );\n  for (const [attribute, value] of Object.entries(\n    inlineContentHTMLAttributes,\n  )) {\n    if (attribute !== \"class\") {\n      inlineContent.setAttribute(attribute, value);\n    }\n  }\n\n  blockContent.appendChild(inlineContent);\n\n  return {\n    dom: blockContent,\n    contentDOM: inlineContent,\n  };\n}\n\n// Function used to convert default blocks to HTML. It uses the corresponding\n// node's `renderHTML` method to do the conversion by using a default\n// `DOMSerializer`.\nexport const defaultBlockToHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  block: BlockNoDefaults<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} => {\n  let node = blockToNode(block, editor.pmSchema);\n\n  if (node.type.name === \"blockContainer\") {\n    // for regular blocks, get the toDOM spec from the blockContent node\n    node = node.firstChild!;\n  }\n\n  const toDOM = editor.pmSchema.nodes[node.type.name].spec.toDOM;\n\n  if (toDOM === undefined) {\n    throw new Error(\n      \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n    );\n  }\n\n  const renderSpec = toDOM(node);\n\n  if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n    throw new Error(\n      \"Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.\",\n    );\n  }\n\n  return renderSpec as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n};\n\n// Function that merges all paragraphs into a single one separated by line breaks.\n// This is used when parsing blocks like list items and table cells, as they may\n// contain multiple paragraphs that ProseMirror will not be able to handle\n// properly.\nexport function mergeParagraphs(element: HTMLElement, separator = \"<br>\") {\n  const paragraphs = element.querySelectorAll(\"p\");\n  if (paragraphs.length > 1) {\n    const firstParagraph = paragraphs[0];\n    for (let i = 1; i < paragraphs.length; i++) {\n      const paragraph = paragraphs[i];\n      firstParagraph.innerHTML += separator + paragraph.innerHTML;\n      paragraph.remove();\n    }\n  }\n}\n","export function camelToDataKebab(str: string): string {\n  return \"data-\" + str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nexport function filenameFromURL(url: string): string {\n  const parts = url.split(\"/\");\n  if (\n    !parts.length || // invalid?\n    parts[parts.length - 1] === \"\" // for example, URL ends in a directory-like trailing slash\n  ) {\n    // in this case just return the original url\n    return url;\n  }\n  return parts[parts.length - 1];\n}\n\nexport function isVideoUrl(url: string) {\n  const videoExtensions = [\n    \"mp4\",\n    \"webm\",\n    \"ogg\",\n    \"mov\",\n    \"mkv\",\n    \"flv\",\n    \"avi\",\n    \"wmv\",\n    \"m4v\",\n  ];\n  try {\n    const pathname = new URL(url).pathname;\n    const ext = pathname.split(\".\").pop()?.toLowerCase() || \"\";\n    return videoExtensions.includes(ext);\n  } catch (_) {\n    return false;\n  }\n}\n","import { Attribute, Attributes, Editor, Node } from \"@tiptap/core\";\nimport { defaultBlockToHTML } from \"../../blocks/defaultBlockHelpers.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport type { ExtensionFactoryInstance } from \"../../editor/BlockNoteExtension.js\";\nimport { mergeCSSClasses } from \"../../util/browser.js\";\nimport { camelToDataKebab } from \"../../util/string.js\";\nimport { InlineContentSchema } from \"../inlineContent/types.js\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport { StyleSchema } from \"../styles/types.js\";\nimport {\n  BlockConfig,\n  BlockSchemaWithBlock,\n  LooseBlockSpec,\n  SpecificBlock,\n} from \"./types.js\";\n\n// Function that uses the 'propSchema' of a blockConfig to create a TipTap\n// node's `addAttributes` property.\n// TODO: extract function\nexport function propsToAttributes(propSchema: PropSchema): Attributes {\n  const tiptapAttributes: Record<string, Attribute> = {};\n\n  Object.entries(propSchema).forEach(([name, spec]) => {\n    tiptapAttributes[name] = {\n      default: spec.default,\n      keepOnSplit: true,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (element) => {\n        const value = element.getAttribute(camelToDataKebab(name));\n\n        if (value === null) {\n          return null;\n        }\n\n        if (\n          (spec.default === undefined && spec.type === \"boolean\") ||\n          (spec.default !== undefined && typeof spec.default === \"boolean\")\n        ) {\n          if (value === \"true\") {\n            return true;\n          }\n\n          if (value === \"false\") {\n            return false;\n          }\n\n          return null;\n        }\n\n        if (\n          (spec.default === undefined && spec.type === \"number\") ||\n          (spec.default !== undefined && typeof spec.default === \"number\")\n        ) {\n          const asNumber = parseFloat(value);\n          const isNumeric =\n            !Number.isNaN(asNumber) && Number.isFinite(asNumber);\n\n          if (isNumeric) {\n            return asNumber;\n          }\n\n          return null;\n        }\n\n        return value;\n      },\n      renderHTML: (attributes) => {\n        // don't render to html if the value is the same as the default\n        return attributes[name] !== spec.default\n          ? {\n              [camelToDataKebab(name)]: attributes[name],\n            }\n          : {};\n      },\n    };\n  });\n\n  return tiptapAttributes;\n}\n\n// Used to figure out which block should be rendered. This block is then used to\n// create the node view.\nexport function getBlockFromPos<\n  BType extends string,\n  Config extends BlockConfig,\n  BSchema extends BlockSchemaWithBlock<BType, Config>,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  getPos: () => number | undefined,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  tipTapEditor: Editor,\n  type: BType,\n) {\n  const pos = getPos();\n  // Gets position of the node\n  if (pos === undefined) {\n    throw new Error(\"Cannot find node position\");\n  }\n  // Gets parent blockContainer node\n  const blockContainer = tipTapEditor.state.doc.resolve(pos!).node();\n  // Gets block identifier\n  const blockIdentifier = blockContainer.attrs.id;\n\n  if (!blockIdentifier) {\n    throw new Error(\"Block doesn't have id\");\n  }\n\n  // Gets the block\n  const block = editor.getBlock(blockIdentifier)! as SpecificBlock<\n    BSchema,\n    BType,\n    I,\n    S\n  >;\n  if (block.type !== type) {\n    throw new Error(\"Block type does not match\");\n  }\n\n  return block;\n}\n\n// Function that wraps the `dom` element returned from 'blockConfig.render' in a\n// `blockContent` div, which contains the block type and props as HTML\n// attributes. If `blockConfig.render` also returns a `contentDOM`, it also adds\n// an `inlineContent` class to it.\nexport function wrapInBlockStructure<\n  BType extends string,\n  PSchema extends PropSchema,\n>(\n  element: {\n    dom: HTMLElement | DocumentFragment;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  },\n  blockType: BType,\n  blockProps: Partial<Props<PSchema>>,\n  propSchema: PSchema,\n  isFileBlock = false,\n  domAttributes?: Record<string, string>,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n  destroy?: () => void;\n} {\n  // Creates `blockContent` element\n  const blockContent = document.createElement(\"div\");\n\n  // Adds custom HTML attributes\n  if (domAttributes !== undefined) {\n    for (const [attr, value] of Object.entries(domAttributes)) {\n      if (attr !== \"class\") {\n        blockContent.setAttribute(attr, value);\n      }\n    }\n  }\n  // Sets blockContent class\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    domAttributes?.class || \"\",\n  );\n  // Sets content type attribute\n  blockContent.setAttribute(\"data-content-type\", blockType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // which are already added as HTML attributes to the parent `blockContent`\n  // element (inheritedProps) and props set to their default values.\n  for (const [prop, value] of Object.entries(blockProps)) {\n    const spec = propSchema[prop];\n    const defaultValue = spec.default;\n    if (value !== defaultValue) {\n      blockContent.setAttribute(camelToDataKebab(prop), value);\n    }\n  }\n  // Adds file block attribute\n  if (isFileBlock) {\n    blockContent.setAttribute(\"data-file-block\", \"\");\n  }\n\n  blockContent.appendChild(element.dom);\n\n  if (element.contentDOM) {\n    element.contentDOM.className = mergeCSSClasses(\n      \"bn-inline-content\",\n      element.contentDOM.className,\n    );\n  }\n\n  return {\n    ...element,\n    dom: blockContent,\n  };\n}\n\nexport function createBlockSpecFromTiptapNode<\n  const T extends {\n    node: Node;\n    type: string;\n    content: \"inline\" | \"table\" | \"none\";\n  },\n  P extends PropSchema,\n>(\n  config: T,\n  propSchema: P,\n  extensions?: ExtensionFactoryInstance[],\n): LooseBlockSpec<T[\"type\"], P, T[\"content\"]> {\n  return {\n    config: {\n      type: config.type as T[\"type\"],\n      content: config.content,\n      propSchema,\n    },\n    implementation: {\n      node: config.node,\n      render: defaultBlockToHTML,\n      toExternalHTML: defaultBlockToHTML,\n    },\n    extensions,\n  };\n}\n","import { Editor, Node } from \"@tiptap/core\";\nimport { DOMParser, Fragment, TagParseRule } from \"@tiptap/pm/model\";\nimport { NodeView } from \"@tiptap/pm/view\";\nimport { mergeParagraphs } from \"../../blocks/defaultBlockHelpers.js\";\nimport {\n  Extension,\n  ExtensionFactoryInstance,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { PropSchema } from \"../propTypes.js\";\nimport {\n  getBlockFromPos,\n  propsToAttributes,\n  wrapInBlockStructure,\n} from \"./internal.js\";\nimport {\n  BlockConfig,\n  BlockImplementation,\n  BlockSpec,\n  LooseBlockSpec,\n} from \"./types.js\";\n\n// Function that causes events within non-selectable blocks to be handled by the\n// browser instead of the editor.\nexport function applyNonSelectableBlockFix(nodeView: NodeView, editor: Editor) {\n  nodeView.stopEvent = (event) => {\n    // Blurs the editor on mouse down as the block is non-selectable. This is\n    // mainly done to prevent UI elements like the formatting toolbar from being\n    // visible while content within a non-selectable block is selected.\n    if (event.type === \"mousedown\") {\n      setTimeout(() => {\n        editor.view.dom.blur();\n      }, 10);\n    }\n\n    return true;\n  };\n}\n\n// Function that uses the 'parse' function of a blockConfig to create a\n// TipTap node's `parseHTML` property. This is only used for parsing content\n// from the clipboard.\nexport function getParseRules<\n  TName extends string,\n  TProps extends PropSchema,\n  TContent extends \"inline\" | \"none\" | \"table\",\n>(\n  config: BlockConfig<TName, TProps, TContent>,\n  implementation: BlockImplementation<TName, TProps, TContent>,\n) {\n  const rules: TagParseRule[] = [\n    {\n      tag: \"[data-content-type=\" + config.type + \"]\",\n      contentElement: \".bn-inline-content\",\n    },\n  ];\n\n  if (implementation.parse) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = implementation.parse?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n      getContent:\n        config.content === \"inline\" || config.content === \"none\"\n          ? (node, schema) => {\n              if (implementation.parseContent) {\n                return implementation.parseContent({\n                  el: node as HTMLElement,\n                  schema,\n                });\n              }\n\n              if (config.content === \"inline\") {\n                // Parse the inline content if it exists\n                const element = node as HTMLElement;\n\n                // Clone to avoid modifying the original\n                const clone = element.cloneNode(true) as HTMLElement;\n\n                // Merge multiple paragraphs into one with line breaks\n                mergeParagraphs(\n                  clone,\n                  implementation.meta?.code ? \"\\n\" : \"<br>\",\n                );\n\n                // Parse the content directly as a paragraph to extract inline content\n                const parser = DOMParser.fromSchema(schema);\n                const parsed = parser.parse(clone, {\n                  topNode: schema.nodes.paragraph.create(),\n                });\n\n                return parsed.content;\n              }\n              return Fragment.empty;\n            }\n          : undefined,\n    });\n  }\n  //     getContent(node, schema) {\n  //       const block = blockConfig.parse?.(node as HTMLElement);\n  //\n  //       if (block !== undefined && block.content !== undefined) {\n  //         return Fragment.from(\n  //           typeof block.content === \"string\"\n  //             ? schema.text(block.content)\n  //             : inlineContentToNodes(block.content, schema)\n  //         );\n  //       }\n  //\n  //       return Fragment.empty;\n  //     },\n  //   });\n  // }\n\n  return rules;\n}\n\n// A function to create custom block for API consumers\n// we want to hide the tiptap node from API consumers and provide a simpler API surface instead\nexport function addNodeAndExtensionsToSpec<\n  TName extends string,\n  TProps extends PropSchema,\n  TContent extends \"inline\" | \"none\" | \"table\",\n>(\n  blockConfig: BlockConfig<TName, TProps, TContent>,\n  blockImplementation: BlockImplementation<TName, TProps, TContent>,\n  extensions?: (ExtensionFactoryInstance | Extension)[],\n  priority?: number,\n): LooseBlockSpec<TName, TProps, TContent> {\n  const node =\n    ((blockImplementation as any).node as Node) ||\n    Node.create({\n      name: blockConfig.type,\n      content: (blockConfig.content === \"inline\"\n        ? \"inline*\"\n        : blockConfig.content === \"none\"\n          ? \"\"\n          : blockConfig.content) as TContent extends \"inline\" ? \"inline*\" : \"\",\n      group: \"blockContent\",\n      selectable: blockImplementation.meta?.selectable ?? true,\n      isolating: blockImplementation.meta?.isolating ?? true,\n      code: blockImplementation.meta?.code ?? false,\n      defining: blockImplementation.meta?.defining ?? true,\n      priority,\n      addAttributes() {\n        return propsToAttributes(blockConfig.propSchema);\n      },\n\n      parseHTML() {\n        return getParseRules(blockConfig, blockImplementation);\n      },\n\n      renderHTML({ HTMLAttributes }) {\n        // renderHTML is used for copy/pasting content from the editor back into\n        // the editor, so we need to make sure the `blockContent` element is\n        // structured correctly as this is what's used for parsing blocks. We\n        // just render a placeholder div inside as the `blockContent` element\n        // already has all the information needed for proper parsing.\n        const div = document.createElement(\"div\");\n        return wrapInBlockStructure(\n          {\n            dom: div,\n            contentDOM: blockConfig.content === \"inline\" ? div : undefined,\n          },\n          blockConfig.type,\n          {},\n          blockConfig.propSchema,\n          blockImplementation.meta?.fileBlockAccept !== undefined,\n          HTMLAttributes,\n        );\n      },\n\n      addNodeView() {\n        return (props) => {\n          // Gets the BlockNote editor instance\n          const editor = this.options.editor;\n          // Gets the block\n          const block = getBlockFromPos(\n            props.getPos,\n            editor,\n            this.editor,\n            blockConfig.type,\n          );\n          // Gets the custom HTML attributes for `blockContent` nodes\n          const blockContentDOMAttributes =\n            this.options.domAttributes?.blockContent || {};\n\n          const nodeView = blockImplementation.render.call(\n            { blockContentDOMAttributes, props, renderType: \"nodeView\" },\n            block as any,\n            editor as any,\n          );\n\n          if (blockImplementation.meta?.selectable === false) {\n            applyNonSelectableBlockFix(nodeView, this.editor);\n          }\n\n          // See explanation for why `update` is not implemented for NodeViews\n          // https://github.com/TypeCellOS/BlockNote/pull/1904#discussion_r2313461464\n          return nodeView;\n        };\n      },\n    });\n\n  if (node.name !== blockConfig.type) {\n    throw new Error(\n      \"Node name does not match block type. This is a bug in BlockNote.\",\n    );\n  }\n\n  return {\n    config: blockConfig,\n    implementation: {\n      ...blockImplementation,\n      node,\n      render(block, editor) {\n        const blockContentDOMAttributes =\n          node.options.domAttributes?.blockContent || {};\n\n        return blockImplementation.render.call(\n          {\n            blockContentDOMAttributes,\n            props: undefined,\n            renderType: \"dom\",\n          },\n          block as any,\n          editor as any,\n        );\n      },\n      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler\n      // post-processing in externalHTMLExporter should not be necessary\n      toExternalHTML: (block, editor) => {\n        const blockContentDOMAttributes =\n          node.options.domAttributes?.blockContent || {};\n\n        return (\n          blockImplementation.toExternalHTML?.call(\n            { blockContentDOMAttributes },\n            block as any,\n            editor as any,\n          ) ??\n          blockImplementation.render.call(\n            { blockContentDOMAttributes, renderType: \"dom\", props: undefined },\n            block as any,\n            editor as any,\n          )\n        );\n      },\n    },\n    extensions,\n  };\n}\n\n/**\n * Helper function to create a block config.\n */\nexport function createBlockConfig<\n  TCallback extends (\n    options: Partial<Record<string, any>>,\n  ) => BlockConfig<any, any, any>,\n  TOptions extends Parameters<TCallback>[0],\n  TName extends ReturnType<TCallback>[\"type\"],\n  TProps extends ReturnType<TCallback>[\"propSchema\"],\n  TContent extends ReturnType<TCallback>[\"content\"],\n>(\n  callback: TCallback,\n): TOptions extends undefined\n  ? () => BlockConfig<TName, TProps, TContent>\n  : (options: TOptions) => BlockConfig<TName, TProps, TContent> {\n  return callback as any;\n}\n\n/**\n * Helper function to create a block definition.\n * Can accept either functions that return the required objects, or the objects directly.\n */\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const TOptions extends Partial<Record<string, any>> | undefined = undefined,\n>(\n  blockConfigOrCreator: BlockConfig<TName, TProps, TContent>,\n  blockImplementationOrCreator:\n    | BlockImplementation<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockImplementation<TName, TProps, TContent>\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<TName, TProps, TContent>),\n  extensionsOrCreator?:\n    | ExtensionFactoryInstance[]\n    | (TOptions extends undefined\n        ? () => ExtensionFactoryInstance[]\n        : (options: Partial<TOptions>) => ExtensionFactoryInstance[]),\n): (options?: Partial<TOptions>) => BlockSpec<TName, TProps, TContent>;\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const BlockConf extends BlockConfig<TName, TProps, TContent>,\n  const TOptions extends Partial<Record<string, any>>,\n>(\n  blockCreator: (options: Partial<TOptions>) => BlockConf,\n  blockImplementationOrCreator:\n    | BlockImplementation<\n        BlockConf[\"type\"],\n        BlockConf[\"propSchema\"],\n        BlockConf[\"content\"]\n      >\n    | (TOptions extends undefined\n        ? () => BlockImplementation<\n            BlockConf[\"type\"],\n            BlockConf[\"propSchema\"],\n            BlockConf[\"content\"]\n          >\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<\n            BlockConf[\"type\"],\n            BlockConf[\"propSchema\"],\n            BlockConf[\"content\"]\n          >),\n  extensionsOrCreator?:\n    | ExtensionFactoryInstance[]\n    | (TOptions extends undefined\n        ? () => ExtensionFactoryInstance[]\n        : (options: Partial<TOptions>) => ExtensionFactoryInstance[]),\n): (\n  options?: Partial<TOptions>,\n) => BlockSpec<\n  BlockConf[\"type\"],\n  BlockConf[\"propSchema\"],\n  BlockConf[\"content\"]\n>;\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const TOptions extends Partial<Record<string, any>> | undefined = undefined,\n>(\n  blockConfigOrCreator:\n    | BlockConfig<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockConfig<TName, TProps, TContent>\n        : (options: Partial<TOptions>) => BlockConfig<TName, TProps, TContent>),\n  blockImplementationOrCreator:\n    | BlockImplementation<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockImplementation<TName, TProps, TContent>\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<TName, TProps, TContent>),\n  extensionsOrCreator?:\n    | ExtensionFactoryInstance[]\n    | (TOptions extends undefined\n        ? () => ExtensionFactoryInstance[]\n        : (options: Partial<TOptions>) => ExtensionFactoryInstance[]),\n): (options?: Partial<TOptions>) => BlockSpec<TName, TProps, TContent> {\n  return (options = {} as TOptions) => {\n    const blockConfig =\n      typeof blockConfigOrCreator === \"function\"\n        ? blockConfigOrCreator(options as any)\n        : blockConfigOrCreator;\n\n    const blockImplementation =\n      typeof blockImplementationOrCreator === \"function\"\n        ? blockImplementationOrCreator(options as any)\n        : blockImplementationOrCreator;\n\n    const extensions = extensionsOrCreator\n      ? typeof extensionsOrCreator === \"function\"\n        ? extensionsOrCreator(options as any)\n        : extensionsOrCreator\n      : undefined;\n\n    return {\n      config: blockConfig,\n      implementation: {\n        ...blockImplementation,\n        // TODO: this should not have wrapInBlockStructure and generally be a lot simpler\n        // post-processing in externalHTMLExporter should not be necessary\n        toExternalHTML(block, editor) {\n          const output = blockImplementation.toExternalHTML?.call(\n            { blockContentDOMAttributes: this.blockContentDOMAttributes },\n            block as any,\n            editor as any,\n          );\n\n          if (output === undefined) {\n            return undefined;\n          }\n\n          return wrapInBlockStructure(\n            output,\n            block.type,\n            block.props,\n            blockConfig.propSchema,\n            blockImplementation.meta?.fileBlockAccept !== undefined,\n          );\n        },\n        render(block, editor) {\n          const output = blockImplementation.render.call(\n            {\n              blockContentDOMAttributes: this.blockContentDOMAttributes,\n              renderType: this.renderType,\n              props: this.props as any,\n            },\n            block as any,\n            editor as any,\n          );\n\n          const nodeView = wrapInBlockStructure(\n            output,\n            block.type,\n            block.props,\n            blockConfig.propSchema,\n            blockImplementation.meta?.fileBlockAccept !== undefined,\n            this.blockContentDOMAttributes,\n          ) satisfies NodeView;\n\n          return nodeView;\n        },\n      },\n      extensions: extensions,\n    };\n  };\n}\n","import { KeyboardShortcutCommand, Node } from \"@tiptap/core\";\n\nimport { camelToDataKebab } from \"../../util/string.js\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentImplementation,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpec,\n  InlineContentSpecs,\n} from \"./types.js\";\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom inline content's 'render' function, to ensure no data\n// is lost on internal copy & paste.\nexport function addInlineContentAttributes<\n  IType extends string,\n  PSchema extends PropSchema,\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  inlineContentType: IType,\n  inlineContentProps: Props<PSchema>,\n  propSchema: PSchema,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-inline-content-type\", inlineContentType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // set to their default values.\n  Object.entries(inlineContentProps)\n    .filter(([prop, value]) => {\n      const spec = propSchema[prop];\n      return value !== spec.default;\n    })\n    .map(([prop, value]) => {\n      return [camelToDataKebab(prop), value];\n    })\n    .forEach(([prop, value]) => element.dom.setAttribute(prop, value));\n\n  if (element.contentDOM) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// see https://github.com/TypeCellOS/BlockNote/pull/435\nexport function addInlineContentKeyboardShortcuts<\n  T extends CustomInlineContentConfig,\n>(\n  config: T,\n): {\n  [p: string]: KeyboardShortcutCommand;\n} {\n  return {\n    Backspace: ({ editor }) => {\n      const resolvedPos = editor.state.selection.$from;\n\n      return (\n        editor.state.selection.empty &&\n        resolvedPos.node().type.name === config.type &&\n        resolvedPos.parentOffset === 0\n      );\n    },\n  };\n}\n\n// This helper function helps to instantiate a InlineContentSpec with a\n// config and implementation that conform to the type of Config\nexport function createInternalInlineContentSpec<\n  const T extends CustomInlineContentConfig,\n>(\n  config: T,\n  implementation: InlineContentImplementation<NoInfer<T>>,\n): InlineContentSpec<T> {\n  return {\n    config,\n    implementation,\n  } as const;\n}\n\nexport function createInlineContentSpecFromTipTapNode<\n  T extends Node,\n  P extends PropSchema,\n>(\n  node: T,\n  propSchema: P,\n  implementation: Omit<\n    InlineContentImplementation<CustomInlineContentConfig>,\n    \"node\"\n  >,\n) {\n  return createInternalInlineContentSpec(\n    {\n      type: node.name as T[\"name\"],\n      propSchema,\n      content: node.config.content === \"inline*\" ? \"styled\" : \"none\",\n    },\n    {\n      ...implementation,\n      node,\n    },\n  );\n}\n\nexport function getInlineContentSchemaFromSpecs<T extends InlineContentSpecs>(\n  specs: T,\n) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config]),\n  ) as InlineContentSchemaFromSpecs<T>;\n}\n","import { Attributes, Mark } from \"@tiptap/core\";\nimport { DOMSerializer } from \"@tiptap/pm/model\";\nimport {\n  StyleConfig,\n  StyleImplementation,\n  StylePropSchema,\n  StyleSchemaFromSpecs,\n  StyleSpec,\n  StyleSpecs,\n} from \"./types.js\";\n\nexport function stylePropsToAttributes(\n  propSchema: StylePropSchema,\n): Attributes {\n  if (propSchema === \"boolean\") {\n    return {};\n  }\n  return {\n    stringValue: {\n      default: undefined,\n      keepOnSplit: true,\n      parseHTML: (element) => element.getAttribute(\"data-value\"),\n      renderHTML: (attributes) =>\n        attributes.stringValue !== undefined\n          ? {\n              \"data-value\": attributes.stringValue,\n            }\n          : {},\n    },\n  };\n}\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom style's 'render' function, to ensure no data is lost\n// on internal copy & paste.\nexport function addStyleAttributes<\n  SType extends string,\n  PSchema extends StylePropSchema,\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  styleType: SType,\n  styleValue: PSchema extends \"boolean\" ? undefined : string,\n  propSchema: PSchema,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-style-type\", styleType);\n  // Adds style value as an HTML attribute in kebab-case with \"data-\" prefix, if\n  // the style takes a string value.\n  if (propSchema === \"string\") {\n    element.dom.setAttribute(\"data-value\", styleValue as string);\n  }\n\n  if (element.contentDOM) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// This helper function helps to instantiate a stylespec with a\n// config and implementation that conform to the type of Config\nexport function createInternalStyleSpec<T extends StyleConfig>(\n  config: T,\n  implementation: StyleImplementation<T>,\n) {\n  return {\n    config,\n    implementation,\n  } satisfies StyleSpec<T>;\n}\n\nexport function createStyleSpecFromTipTapMark<\n  T extends Mark,\n  P extends StylePropSchema,\n>(mark: T, propSchema: P) {\n  return createInternalStyleSpec(\n    {\n      type: mark.name as T[\"name\"],\n      propSchema,\n    },\n    {\n      mark,\n      render(value, editor) {\n        const toDOM = editor.pmSchema.marks[mark.name].spec.toDOM;\n\n        if (toDOM === undefined) {\n          throw new Error(\n            \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n          );\n        }\n\n        const markInstance = editor.pmSchema.mark(mark.name, {\n          stringValue: value,\n        });\n\n        const renderSpec = DOMSerializer.renderSpec(\n          document,\n          toDOM(markInstance, true),\n        );\n\n        if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n          throw new Error(\n            \"Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property.\",\n          );\n        }\n\n        return renderSpec as {\n          dom: HTMLElement;\n          contentDOM?: HTMLElement;\n        };\n      },\n      toExternalHTML(value, editor) {\n        const toDOM = editor.pmSchema.marks[mark.name].spec.toDOM;\n\n        if (toDOM === undefined) {\n          throw new Error(\n            \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n          );\n        }\n\n        const markInstance = editor.pmSchema.mark(mark.name, {\n          stringValue: value,\n        });\n\n        const renderSpec = DOMSerializer.renderSpec(\n          document,\n          toDOM(markInstance, true),\n        );\n\n        if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n          throw new Error(\n            \"Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property.\",\n          );\n        }\n\n        return renderSpec as {\n          dom: HTMLElement;\n          contentDOM?: HTMLElement;\n        };\n      },\n    },\n  );\n}\n\nexport function getStyleSchemaFromSpecs<T extends StyleSpecs>(specs: T) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config]),\n  ) as StyleSchemaFromSpecs<T>;\n}\n","import { Mark } from \"@tiptap/core\";\n\nimport { ParseRule, TagParseRule } from \"@tiptap/pm/model\";\nimport {\n  addStyleAttributes,\n  createInternalStyleSpec,\n  stylePropsToAttributes,\n} from \"./internal.js\";\nimport { StyleConfig, StyleSpec } from \"./types.js\";\n\nexport type CustomStyleImplementation<T extends StyleConfig> = {\n  render: (value: T[\"propSchema\"] extends \"boolean\" ? undefined : string) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n  toExternalHTML?: (\n    value: T[\"propSchema\"] extends \"boolean\" ? undefined : string,\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n  parse?: (\n    element: HTMLElement,\n  ) => (T[\"propSchema\"] extends \"boolean\" ? true : string) | undefined;\n  runsBefore?: string[];\n};\n\nexport function getStyleParseRules<T extends StyleConfig>(\n  config: T,\n  customParseFunction?: CustomStyleImplementation<T>[\"parse\"],\n): ParseRule[] {\n  const rules: TagParseRule[] = [\n    {\n      tag: `[data-style-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      // By default, styles can overlap each other, so the rules should not\n      // completely consume the element they parse (which can have multiple\n      // styles).\n      consuming: false,\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const stringValue = customParseFunction?.(node);\n\n        if (stringValue === undefined) {\n          return false;\n        }\n\n        return { stringValue };\n      },\n    });\n  }\n  return rules;\n}\n\nexport function createStyleSpec<const T extends StyleConfig>(\n  styleConfig: T,\n  styleImplementation: CustomStyleImplementation<T>,\n): StyleSpec<T> {\n  const mark = Mark.create({\n    name: styleConfig.type,\n\n    addAttributes() {\n      return stylePropsToAttributes(styleConfig.propSchema);\n    },\n\n    parseHTML() {\n      return getStyleParseRules(styleConfig, styleImplementation.parse);\n    },\n\n    renderHTML({ mark }) {\n      const renderResult = (\n        styleImplementation.toExternalHTML || styleImplementation.render\n      )(mark.attrs.stringValue);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        mark.attrs.stringValue,\n        styleConfig.propSchema,\n      );\n    },\n\n    addMarkView() {\n      return ({ mark }) => {\n        const renderResult = styleImplementation.render(mark.attrs.stringValue);\n\n        return addStyleAttributes(\n          renderResult,\n          styleConfig.type,\n          mark.attrs.stringValue,\n          styleConfig.propSchema,\n        );\n      };\n    },\n  });\n\n  return createInternalStyleSpec(styleConfig, {\n    ...styleImplementation,\n    mark,\n    render: (value) => {\n      const renderResult = styleImplementation.render(value as any);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        value,\n        styleConfig.propSchema,\n      );\n    },\n    toExternalHTML: (value) => {\n      const renderResult = (\n        styleImplementation.toExternalHTML || styleImplementation.render\n      )(value as any);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        value,\n        styleConfig.propSchema,\n      );\n    },\n  });\n}\n","import type { Node } from \"prosemirror-model\";\n\n/**\n * Get a TipTap node by id\n */\nexport function getNodeById(\n  id: string,\n  doc: Node,\n): { node: Node; posBeforeNode: number } | undefined {\n  let targetNode: Node | undefined = undefined;\n  let posBeforeNode: number | undefined = undefined;\n\n  doc.firstChild!.descendants((node, pos) => {\n    // Skips traversing nodes after node with target ID has been found.\n    if (targetNode) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (!isNodeBlock(node) || node.attrs.id !== id) {\n      return true;\n    }\n\n    targetNode = node;\n    posBeforeNode = pos + 1;\n\n    return false;\n  });\n\n  if (targetNode === undefined || posBeforeNode === undefined) {\n    return undefined;\n  }\n\n  return {\n    node: targetNode,\n    posBeforeNode: posBeforeNode,\n  };\n}\n\nexport function isNodeBlock(node: Node): boolean {\n  return node.type.isInGroup(\"bnBlock\");\n}\n","import {\n  Fragment,\n  type NodeType,\n  type Node as PMNode,\n  Slice,\n} from \"prosemirror-model\";\nimport { TextSelection, Transaction } from \"prosemirror-state\";\nimport { TableMap } from \"prosemirror-tables\";\nimport { ReplaceStep, Transform } from \"prosemirror-transform\";\n\nimport type { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n} from \"../../../../schema/blocks/types.js\";\nimport type { InlineContentSchema } from \"../../../../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../../../../schema/styles/types.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  type BlockInfo,\n  getBlockInfoFromResolvedPos,\n} from \"../../../getBlockInfoFromPos.js\";\nimport {\n  blockToNode,\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\n// for compatibility with tiptap. TODO: remove as we want to remove dependency on tiptap command interface\nexport const updateBlockCommand = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  posBeforeBlock: number,\n  block: PartialBlock<BSchema, I, S>,\n) => {\n  return ({\n    tr,\n    dispatch,\n  }: {\n    tr: Transaction;\n    dispatch?: () => void;\n  }): boolean => {\n    if (dispatch) {\n      updateBlockTr(tr, posBeforeBlock, block);\n    }\n    return true;\n  };\n};\n\nexport function updateBlockTr<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transform | Transaction,\n  posBeforeBlock: number,\n  block: PartialBlock<BSchema, I, S>,\n  replaceFromPos?: number,\n  replaceToPos?: number,\n) {\n  const blockInfo = getBlockInfoFromResolvedPos(tr.doc.resolve(posBeforeBlock));\n\n  let cellAnchor: CellAnchor | null = null;\n  if (blockInfo.blockNoteType === \"table\") {\n    cellAnchor = captureCellAnchor(tr);\n  }\n\n  const pmSchema = getPmSchema(tr);\n\n  if (\n    replaceFromPos !== undefined &&\n    replaceToPos !== undefined &&\n    replaceFromPos > replaceToPos\n  ) {\n    throw new Error(\"Invalid replaceFromPos or replaceToPos\");\n  }\n\n  // Adds blockGroup node with child blocks if necessary.\n\n  const oldNodeType = pmSchema.nodes[blockInfo.blockNoteType];\n  const newNodeType = pmSchema.nodes[block.type || blockInfo.blockNoteType];\n  const newBnBlockNodeType = newNodeType.isInGroup(\"bnBlock\")\n    ? newNodeType\n    : pmSchema.nodes[\"blockContainer\"];\n\n  if (blockInfo.isBlockContainer && newNodeType.isInGroup(\"blockContent\")) {\n    const replaceFromOffset =\n      replaceFromPos !== undefined &&\n      replaceFromPos > blockInfo.blockContent.beforePos &&\n      replaceFromPos < blockInfo.blockContent.afterPos\n        ? replaceFromPos - blockInfo.blockContent.beforePos - 1\n        : undefined;\n\n    const replaceToOffset =\n      replaceToPos !== undefined &&\n      replaceToPos > blockInfo.blockContent.beforePos &&\n      replaceToPos < blockInfo.blockContent.afterPos\n        ? replaceToPos - blockInfo.blockContent.beforePos - 1\n        : undefined;\n\n    updateChildren(block, tr, blockInfo);\n    // The code below determines the new content of the block.\n    // or \"keep\" to keep as-is\n    updateBlockContentNode(\n      block,\n      tr,\n      oldNodeType,\n      newNodeType,\n      blockInfo,\n      replaceFromOffset,\n      replaceToOffset,\n    );\n  } else if (!blockInfo.isBlockContainer && newNodeType.isInGroup(\"bnBlock\")) {\n    updateChildren(block, tr, blockInfo);\n    // old node was a bnBlock type (like column or columnList) and new block as well\n    // No op, we just update the bnBlock below (at end of function) and have already updated the children\n  } else {\n    // switching from blockContainer to non-blockContainer or v.v.\n    // currently breaking for column slash menu items converting empty block\n    // to column.\n\n    // currently, we calculate the new node and replace the entire node with the desired new node.\n    // for this, we do a nodeToBlock on the existing block to get the children.\n    // it would be cleaner to use a ReplaceAroundStep, but this is a bit simpler and it's quite an edge case\n    const existingBlock = nodeToBlock(blockInfo.bnBlock.node, pmSchema);\n    tr.replaceWith(\n      blockInfo.bnBlock.beforePos,\n      blockInfo.bnBlock.afterPos,\n      blockToNode(\n        {\n          children: existingBlock.children, // if no children are passed in, use existing children\n          ...block,\n        },\n        pmSchema,\n      ),\n    );\n\n    return;\n  }\n\n  // Adds all provided props as attributes to the parent blockContainer node too, and also preserves existing\n  // attributes.\n  tr.setNodeMarkup(blockInfo.bnBlock.beforePos, newBnBlockNodeType, {\n    ...blockInfo.bnBlock.node.attrs,\n    ...block.props,\n  });\n\n  if (cellAnchor) {\n    restoreCellAnchor(tr, blockInfo, cellAnchor);\n  }\n}\n\nfunction updateBlockContentNode<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  block: PartialBlock<BSchema, I, S>,\n  tr: Transform,\n  oldNodeType: NodeType,\n  newNodeType: NodeType,\n  blockInfo: {\n    childContainer?:\n      | { node: PMNode; beforePos: number; afterPos: number }\n      | undefined;\n    blockContent: { node: PMNode; beforePos: number; afterPos: number };\n  },\n  replaceFromOffset?: number,\n  replaceToOffset?: number,\n) {\n  const pmSchema = getPmSchema(tr);\n  let content: PMNode[] | \"keep\" = \"keep\";\n\n  // Has there been any custom content provided?\n  if (block.content) {\n    if (typeof block.content === \"string\") {\n      // Adds a single text node with no marks to the content.\n      content = inlineContentToNodes(\n        [block.content],\n        pmSchema,\n        newNodeType.name,\n      );\n    } else if (Array.isArray(block.content)) {\n      // Adds a text node with the provided styles converted into marks to the content,\n      // for each InlineContent object.\n      content = inlineContentToNodes(block.content, pmSchema, newNodeType.name);\n    } else if (block.content.type === \"tableContent\") {\n      content = tableContentToNodes(block.content, pmSchema);\n    } else {\n      throw new UnreachableCaseError(block.content.type);\n    }\n  } else {\n    // no custom content has been provided, use existing content IF possible\n    // Since some block types contain inline content and others don't,\n    // we either need to call setNodeMarkup to just update type &\n    // attributes, or replaceWith to replace the whole blockContent.\n    if (oldNodeType.spec.content === \"\") {\n      // keep old content, because it's empty anyway and should be compatible with\n      // any newContentType\n    } else if (newNodeType.spec.content !== oldNodeType.spec.content) {\n      // the content type changed, replace the previous content\n      content = [];\n    } else {\n      // keep old content, because the content type is the same and should be compatible\n    }\n  }\n\n  // Now, changes the blockContent node type and adds the provided props\n  // as attributes. Also preserves all existing attributes that are\n  // compatible with the new type.\n  //\n  // Use either setNodeMarkup or replaceWith depending on whether the\n  // content is being replaced or not.\n  if (content === \"keep\") {\n    // use setNodeMarkup to only update the type and attributes\n    tr.setNodeMarkup(blockInfo.blockContent.beforePos, newNodeType, {\n      ...blockInfo.blockContent.node.attrs,\n      ...block.props,\n    });\n  } else if (replaceFromOffset !== undefined || replaceToOffset !== undefined) {\n    // first update markup of the containing node\n    tr.setNodeMarkup(blockInfo.blockContent.beforePos, newNodeType, {\n      ...blockInfo.blockContent.node.attrs,\n      ...block.props,\n    });\n\n    const start =\n      blockInfo.blockContent.beforePos + 1 + (replaceFromOffset ?? 0);\n    const end =\n      blockInfo.blockContent.beforePos +\n      1 +\n      (replaceToOffset ?? blockInfo.blockContent.node.content.size);\n\n    // for content like table cells (where the blockcontent has nested PM nodes),\n    // we need to figure out the correct openStart and openEnd for the slice when replacing\n\n    const contentDepth = tr.doc.resolve(blockInfo.blockContent.beforePos).depth;\n    const startDepth = tr.doc.resolve(start).depth;\n    const endDepth = tr.doc.resolve(end).depth;\n\n    tr.replace(\n      start,\n      end,\n      new Slice(\n        Fragment.from(content),\n        startDepth - contentDepth - 1,\n        endDepth - contentDepth - 1,\n      ),\n    );\n  } else {\n    // use replaceWith to replace the content and the block itself\n    // also reset the selection since replacing the block content\n    // sets it to the next block.\n    tr.replaceWith(\n      blockInfo.blockContent.beforePos,\n      blockInfo.blockContent.afterPos,\n      newNodeType.createChecked(\n        {\n          ...blockInfo.blockContent.node.attrs,\n          ...block.props,\n        },\n        content,\n      ),\n    );\n  }\n}\n\nfunction updateChildren<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(block: PartialBlock<BSchema, I, S>, tr: Transform, blockInfo: BlockInfo) {\n  const pmSchema = getPmSchema(tr);\n  if (block.children !== undefined && block.children.length > 0) {\n    const childNodes = block.children.map((child) => {\n      return blockToNode(child, pmSchema);\n    });\n\n    // Checks if a blockGroup node already exists.\n    if (blockInfo.childContainer) {\n      // Replaces all child nodes in the existing blockGroup with the ones created earlier.\n\n      // use a replacestep to avoid the fitting algorithm\n      tr.step(\n        new ReplaceStep(\n          blockInfo.childContainer.beforePos + 1,\n          blockInfo.childContainer.afterPos - 1,\n          new Slice(Fragment.from(childNodes), 0, 0),\n        ),\n      );\n    } else {\n      if (!blockInfo.isBlockContainer) {\n        throw new Error(\"impossible\");\n      }\n      // Inserts a new blockGroup containing the child nodes created earlier.\n      tr.insert(\n        blockInfo.blockContent.afterPos,\n        pmSchema.nodes[\"blockGroup\"].createChecked({}, childNodes),\n      );\n    }\n  }\n}\n\nexport function updateBlock<\n  BSchema extends BlockSchema = any,\n  I extends InlineContentSchema = any,\n  S extends StyleSchema = any,\n>(\n  tr: Transform,\n  blockToUpdate: BlockIdentifier,\n  update: PartialBlock<BSchema, I, S>,\n  replaceFromPos?: number,\n  replaceToPos?: number,\n): Block<BSchema, I, S> {\n  const id =\n    typeof blockToUpdate === \"string\" ? blockToUpdate : blockToUpdate.id;\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  updateBlockTr(\n    tr,\n    posInfo.posBeforeNode,\n    update,\n    replaceFromPos,\n    replaceToPos,\n  );\n\n  const blockContainerNode = tr.doc\n    .resolve(posInfo.posBeforeNode + 1) // TODO: clean?\n    .node();\n\n  const pmSchema = getPmSchema(tr);\n  return nodeToBlock(blockContainerNode, pmSchema);\n}\n\ntype CellAnchor = { row: number; col: number; offset: number };\n\n/**\n * Captures the cell anchor from the current selection.\n * @param tr - The transaction to capture the cell anchor from.\n *\n * @returns The cell anchor, or null if no cell is selected.\n */\nexport function captureCellAnchor(tr: Transform): CellAnchor | null {\n  const sel = \"selection\" in tr ? tr.selection : null;\n  if (!(sel instanceof TextSelection)) {\n    return null;\n  }\n\n  const $head = tr.doc.resolve(sel.head);\n  // Find enclosing cell and table\n  let cellDepth = -1;\n  let tableDepth = -1;\n  for (let d = $head.depth; d >= 0; d--) {\n    const name = $head.node(d).type.name;\n    if (cellDepth < 0 && (name === \"tableCell\" || name === \"tableHeader\")) {\n      cellDepth = d;\n    }\n    if (name === \"table\") {\n      tableDepth = d;\n      break;\n    }\n  }\n  if (cellDepth < 0 || tableDepth < 0) {\n    return null;\n  }\n\n  // Absolute positions (before the cell)\n  const cellPos = $head.before(cellDepth);\n  const tablePos = $head.before(tableDepth);\n  const table = tr.doc.nodeAt(tablePos);\n  if (!table || table.type.name !== \"table\") {\n    return null;\n  }\n\n  // Visual grid position via TableMap (handles spans)\n  const map = TableMap.get(table);\n  const rel = cellPos - (tablePos + 1); // relative to inside table\n  const idx = map.map.indexOf(rel);\n  if (idx < 0) {\n    return null;\n  }\n\n  const row = Math.floor(idx / map.width);\n  const col = idx % map.width;\n\n  // Caret offset relative to the start of paragraph text\n  const paraPos = cellPos + 1; // pos BEFORE tableParagraph\n  const textStart = paraPos + 1; // start of paragraph text\n  const offset = Math.max(0, sel.head - textStart);\n\n  return { row, col, offset };\n}\n\nfunction restoreCellAnchor(\n  tr: Transform | Transaction,\n  blockInfo: BlockInfo,\n  a: CellAnchor,\n): boolean {\n  if (blockInfo.blockNoteType !== \"table\") {\n    return false;\n  }\n\n  // 1) Resolve the table node in the current document\n  let tablePos = -1;\n\n  if (blockInfo.isBlockContainer) {\n    // Prefer the blockContent position when available (points directly at the PM table node)\n    tablePos = tr.mapping.map(blockInfo.blockContent.beforePos);\n  } else {\n    // Fallback: scan within the mapped bnBlock range to find the inner table node\n    const start = tr.mapping.map(blockInfo.bnBlock.beforePos);\n    const end = start + (tr.doc.nodeAt(start)?.nodeSize || 0);\n    tr.doc.nodesBetween(start, end, (node, pos) => {\n      if (node.type.name === \"table\") {\n        tablePos = pos;\n        return false;\n      }\n      return true;\n    });\n  }\n\n  const table = tablePos >= 0 ? tr.doc.nodeAt(tablePos) : null;\n  if (!table || table.type.name !== \"table\") {\n    return false;\n  }\n\n  // 2) Clamp row/col to the tableâ€™s current grid\n  const map = TableMap.get(table);\n  const row = Math.max(0, Math.min(a.row, map.height - 1));\n  const col = Math.max(0, Math.min(a.col, map.width - 1));\n\n  // 3) Compute the absolute position of the target cell (pos BEFORE the cell)\n  const cellIndex = row * map.width + col;\n  const relCellPos = map.map[cellIndex]; // relative to (tablePos + 1)\n  if (relCellPos == null) {\n    return false;\n  }\n  const cellPos = tablePos + 1 + relCellPos;\n\n  // 4) Place the caret inside the cell, clamping the text offset\n  const textPos = cellPos + 1;\n  const textNode = tr.doc.nodeAt(textPos);\n  const textStart = textPos + 1;\n  const max = textNode ? textNode.content.size : 0;\n  const head = textStart + Math.max(0, Math.min(a.offset, max));\n\n  if (\"selection\" in tr) {\n    tr.setSelection(TextSelection.create(tr.doc, head));\n  }\n  return true;\n}\n","export const COLORS_DEFAULT = {\n  gray: {\n    text: \"#9b9a97\",\n    background: \"#ebeced\",\n  },\n  brown: {\n    text: \"#64473a\",\n    background: \"#e9e5e3\",\n  },\n  red: {\n    text: \"#e03e3e\",\n    background: \"#fbe4e4\",\n  },\n  orange: {\n    text: \"#d9730d\",\n    background: \"#f6e9d9\",\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#fbf3db\",\n  },\n  green: {\n    text: \"#4d6461\",\n    background: \"#ddedea\",\n  },\n  blue: {\n    text: \"#0b6e99\",\n    background: \"#ddebf1\",\n  },\n  purple: {\n    text: \"#6940a5\",\n    background: \"#eae4f2\",\n  },\n  pink: {\n    text: \"#ad1a72\",\n    background: \"#f4dfeb\",\n  },\n} as Record<string, { text: string; background: string }>;\n\nexport const COLORS_DARK_MODE_DEFAULT = {\n  gray: {\n    text: \"#bebdb8\",\n    background: \"#9b9a97\",\n  },\n  brown: {\n    text: \"#8e6552\",\n    background: \"#64473a\",\n  },\n  red: {\n    text: \"#ec4040\",\n    background: \"#be3434\",\n  },\n  orange: {\n    text: \"#e3790d\",\n    background: \"#b7600a\",\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#b58b00\",\n  },\n  green: {\n    text: \"#6b8b87\",\n    background: \"#4d6461\",\n  },\n  blue: {\n    text: \"#0e87bc\",\n    background: \"#0b6e99\",\n  },\n  purple: {\n    text: \"#8552d7\",\n    background: \"#6940a5\",\n  },\n  pink: {\n    text: \"#da208f\",\n    background: \"#ad1a72\",\n  },\n} as Record<string, { text: string; background: string }>;\n","import { Attribute } from \"@tiptap/core\";\n\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport type { Props, PropSchema } from \"../schema/index.js\";\n\n// TODO: this system should probably be moved / refactored.\n// The dependency from schema on this file doesn't make sense\n\nexport const defaultProps = {\n  backgroundColor: {\n    default: \"default\" as const,\n  },\n  textColor: {\n    default: \"default\" as const,\n  },\n  textAlignment: {\n    default: \"left\" as const,\n    values: [\"left\", \"center\", \"right\", \"justify\"] as const,\n  },\n} satisfies PropSchema;\n\nexport type DefaultProps = Props<typeof defaultProps>;\n\nexport const parseDefaultProps = (element: HTMLElement) => {\n  const props: Partial<DefaultProps> = {};\n\n  // If the `data-` attribute is found, set the prop to the value, as this most\n  // likely means the parsed element was exported by BlockNote originally.\n  // Otherwise, just use whatever is found in the inline styles, if anything.\n  if (element.hasAttribute(\"data-background-color\")) {\n    props.backgroundColor = element.getAttribute(\"data-background-color\")!;\n  } else if (element.style.backgroundColor) {\n    props.backgroundColor = element.style.backgroundColor;\n  }\n\n  // If the `data-` attribute is found, set the prop to the value, as this most\n  // likely means the parsed element was exported by BlockNote originally.\n  // Otherwise, just use whatever is found in the inline styles, if anything.\n  if (element.hasAttribute(\"data-text-color\")) {\n    props.textColor = element.getAttribute(\"data-text-color\")!;\n  } else if (element.style.color) {\n    props.textColor = element.style.color;\n  }\n\n  props.textAlignment = defaultProps.textAlignment.values.includes(\n    element.style.textAlign as DefaultProps[\"textAlignment\"],\n  )\n    ? (element.style.textAlign as DefaultProps[\"textAlignment\"])\n    : undefined;\n\n  return props;\n};\n\nexport const addDefaultPropsExternalHTML = (\n  props: Partial<DefaultProps>,\n  element: HTMLElement,\n) => {\n  if (\n    props.backgroundColor &&\n    props.backgroundColor !== defaultProps.backgroundColor.default\n  ) {\n    // The color can be any string. If the string matches one of the default\n    // theme color names, set the theme color. Otherwise, set the color as-is\n    // (may be a CSS color name, hex value, RGB value, etc).\n    element.style.backgroundColor =\n      props.backgroundColor in COLORS_DEFAULT\n        ? COLORS_DEFAULT[props.backgroundColor].background\n        : props.backgroundColor;\n  }\n\n  if (props.textColor && props.textColor !== defaultProps.textColor.default) {\n    // The color can be any string. If the string matches one of the default\n    // theme color names, set the theme color. Otherwise, set the color as-is\n    // (may be a CSS color name, hex value, RGB value, etc).\n    element.style.color =\n      props.textColor in COLORS_DEFAULT\n        ? COLORS_DEFAULT[props.textColor].text\n        : props.textColor;\n  }\n\n  if (\n    props.textAlignment &&\n    props.textAlignment !== defaultProps.textAlignment.default\n  ) {\n    element.style.textAlign = props.textAlignment;\n  }\n};\n\nexport const getBackgroundColorAttribute = (\n  attributeName = \"backgroundColor\",\n): Attribute => ({\n  default: defaultProps.backgroundColor.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-background-color\")) {\n      return element.getAttribute(\"data-background-color\")!;\n    }\n\n    if (element.style.backgroundColor) {\n      return element.style.backgroundColor;\n    }\n\n    return defaultProps.backgroundColor.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.backgroundColor.default) {\n      return {};\n    }\n\n    return {\n      \"data-background-color\": attributes[attributeName],\n    };\n  },\n});\n\nexport const getTextColorAttribute = (\n  attributeName = \"textColor\",\n): Attribute => ({\n  default: defaultProps.textColor.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-text-color\")) {\n      return element.getAttribute(\"data-text-color\")!;\n    }\n\n    if (element.style.color) {\n      return element.style.color;\n    }\n\n    return defaultProps.textColor.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.textColor.default) {\n      return {};\n    }\n\n    return {\n      \"data-text-color\": attributes[attributeName],\n    };\n  },\n});\n\nexport const getTextAlignmentAttribute = (\n  attributeName = \"textAlignment\",\n): Attribute => ({\n  default: defaultProps.textAlignment.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-text-alignment\")) {\n      return element.getAttribute(\"data-text-alignment\");\n    }\n\n    if (element.style.textAlign) {\n      return element.style.textAlign;\n    }\n\n    return defaultProps.textAlignment.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.textAlignment.default) {\n      return {};\n    }\n\n    return {\n      \"data-text-alignment\": attributes[attributeName],\n    };\n  },\n});\n","export const parseFigureElement = (\n  figureElement: HTMLElement,\n  targetTag: string,\n) => {\n  const targetElement = figureElement.querySelector(\n    targetTag,\n  ) as HTMLElement | null;\n  if (!targetElement) {\n    return undefined;\n  }\n\n  const captionElement = figureElement.querySelector(\"figcaption\");\n  const caption = captionElement?.textContent ?? undefined;\n\n  return { targetElement, caption };\n};\n","import {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\n\nexport const FilePanelExtension = createExtension(({ editor }) => {\n  const store = createStore<string | undefined>(undefined);\n\n  function closeMenu() {\n    store.setState(undefined);\n  }\n\n  return {\n    key: \"filePanel\",\n    store,\n    mount({ signal }) {\n      // Reset the menu when the document changes.\n      const unsubscribeOnChange = editor.onChange(\n        closeMenu,\n        // Don't trigger if the changes are caused by a remote user.\n        false,\n      );\n\n      // reset the menu when the selection changes\n      const unsubscribeOnSelectionChange = editor.onSelectionChange(\n        closeMenu,\n        // Don't trigger if the changes are caused by a remote user.\n        false,\n      );\n\n      signal.addEventListener(\"abort\", () => {\n        unsubscribeOnChange();\n        unsubscribeOnSelectionChange();\n      });\n    },\n    closeMenu,\n    showMenu(blockId: string) {\n      store.setState(blockId);\n    },\n  } as const;\n});\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport { FilePanelExtension } from \"../../../../extensions/FilePanel/FilePanel.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\n\nexport const createAddFileButton = (\n  block: BlockFromConfigNoChildren<BlockConfig<string, any, \"none\">, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  buttonIcon?: HTMLElement,\n) => {\n  const addFileButton = document.createElement(\"div\");\n  addFileButton.className = \"bn-add-file-button\";\n\n  const addFileButtonIcon = document.createElement(\"div\");\n  addFileButtonIcon.className = \"bn-add-file-button-icon\";\n  if (buttonIcon) {\n    addFileButtonIcon.appendChild(buttonIcon);\n  } else {\n    addFileButtonIcon.innerHTML =\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>';\n  }\n  addFileButton.appendChild(addFileButtonIcon);\n\n  const addFileButtonText = document.createElement(\"p\");\n  addFileButtonText.className = \"bn-add-file-button-text\";\n  addFileButtonText.innerHTML =\n    block.type in editor.dictionary.file_blocks.add_button_text\n      ? editor.dictionary.file_blocks.add_button_text[block.type]\n      : editor.dictionary.file_blocks.add_button_text[\"file\"];\n  addFileButton.appendChild(addFileButtonText);\n\n  // Prevents focus from moving to the button.\n  const addFileButtonMouseDownHandler = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n  // Opens the file toolbar.\n  const addFileButtonClickHandler = () => {\n    if (!editor.isEditable) {\n      return;\n    }\n\n    editor.getExtension(FilePanelExtension)?.showMenu(block.id);\n  };\n  addFileButton.addEventListener(\n    \"mousedown\",\n    addFileButtonMouseDownHandler,\n    true,\n  );\n  addFileButton.addEventListener(\"click\", addFileButtonClickHandler, true);\n\n  return {\n    dom: addFileButton,\n    destroy: () => {\n      addFileButton.removeEventListener(\n        \"mousedown\",\n        addFileButtonMouseDownHandler,\n        true,\n      );\n      addFileButton.removeEventListener(\n        \"click\",\n        addFileButtonClickHandler,\n        true,\n      );\n    },\n  };\n};\n","import {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\n\nexport const FILE_ICON_SVG = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>`;\n\nexport const createFileNameWithIcon = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        name: { default: \"\" };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n): { dom: HTMLElement; destroy?: () => void } => {\n  const file = document.createElement(\"div\");\n  file.className = \"bn-file-name-with-icon\";\n\n  const icon = document.createElement(\"div\");\n  icon.className = \"bn-file-icon\";\n  icon.innerHTML = FILE_ICON_SVG;\n  file.appendChild(icon);\n\n  const fileName = document.createElement(\"p\");\n  fileName.className = \"bn-file-name\";\n  fileName.textContent = block.props.name;\n  file.appendChild(fileName);\n\n  return {\n    dom: file,\n  };\n};\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\nimport { createAddFileButton } from \"./createAddFileButton.js\";\nimport { createFileNameWithIcon } from \"./createFileNameWithIcon.js\";\n\nexport const createFileBlockWrapper = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        backgroundColor: { default: \"default\" };\n        name: { default: \"\" };\n        url: { default: \"\" };\n        caption: { default: \"\" };\n        showPreview?: { default: true };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n  editor: BlockNoteEditor<any, any, any>,\n  element?: { dom: HTMLElement; destroy?: () => void },\n  buttonIcon?: HTMLElement,\n) => {\n  const wrapper = document.createElement(\"div\");\n  wrapper.className = \"bn-file-block-content-wrapper\";\n\n  // Show the add file button if the file has not been uploaded yet. Change to\n  // show a loader if a file upload for the block begins.\n  if (block.props.url === \"\") {\n    const addFileButton = createAddFileButton(block, editor, buttonIcon);\n    wrapper.appendChild(addFileButton.dom);\n\n    const destroyUploadStartHandler = editor.onUploadStart((blockId) => {\n      if (blockId === block.id) {\n        wrapper.removeChild(addFileButton.dom);\n\n        const loading = document.createElement(\"div\");\n        loading.className = \"bn-file-loading-preview\";\n        loading.textContent = \"Loading...\";\n        wrapper.appendChild(loading);\n      }\n    });\n\n    return {\n      dom: wrapper,\n      destroy: () => {\n        destroyUploadStartHandler();\n        addFileButton.destroy();\n      },\n    };\n  }\n\n  const ret: { dom: HTMLElement; destroy?: () => void } = { dom: wrapper };\n\n  // Show the file preview, or the file name and icon.\n  if (block.props.showPreview === false || !element) {\n    // Show file name and icon.\n    const fileNameWithIcon = createFileNameWithIcon(block);\n    wrapper.appendChild(fileNameWithIcon.dom);\n\n    ret.destroy = () => {\n      fileNameWithIcon.destroy?.();\n    };\n  } else {\n    // Show file preview.\n    wrapper.appendChild(element.dom);\n  }\n\n  // Show the caption if there is one.\n  if (block.props.caption) {\n    const caption = document.createElement(\"p\");\n    caption.className = \"bn-file-caption\";\n    caption.textContent = block.props.caption;\n    wrapper.appendChild(caption);\n  }\n\n  return ret;\n};\n","export const createFigureWithCaption = (\n  element: HTMLElement,\n  caption: string,\n) => {\n  const figure = document.createElement(\"figure\");\n  const captionElement = document.createElement(\"figcaption\");\n  captionElement.textContent = caption;\n\n  figure.appendChild(element);\n  figure.appendChild(captionElement);\n\n  return { dom: figure };\n};\n","export const createLinkWithCaption = (\n  element: HTMLElement,\n  caption: string,\n) => {\n  const wrapper = document.createElement(\"div\");\n  const fileCaption = document.createElement(\"p\");\n  fileCaption.textContent = caption;\n\n  wrapper.appendChild(element);\n  wrapper.appendChild(fileCaption);\n\n  return {\n    dom: wrapper,\n  };\n};\n","export const parseAudioElement = (audioElement: HTMLAudioElement) => {\n  const url = audioElement.src || undefined;\n\n  return { url };\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockFromConfig,\n  createBlockConfig,\n  createBlockSpec,\n} from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createFileBlockWrapper } from \"../File/helpers/render/createFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseAudioElement } from \"./parseAudioElement.js\";\n\nexport const FILE_AUDIO_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z\"></path></svg>';\n\nexport interface AudioOptions {\n  icon?: string;\n}\n\nexport type AudioBlockConfig = ReturnType<typeof createAudioBlockConfig>;\n\nexport const createAudioBlockConfig = createBlockConfig(\n  (_ctx: AudioOptions) =>\n    ({\n      type: \"audio\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n\n        showPreview: {\n          default: true,\n        },\n      },\n      content: \"none\",\n    }) as const,\n);\n\nexport const audioParse =\n  (_config: AudioOptions = {}) =>\n  (element: HTMLElement) => {\n    if (element.tagName === \"AUDIO\") {\n      // Ignore if parent figure has already been parsed.\n      if (element.closest(\"figure\")) {\n        return undefined;\n      }\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseAudioElement(element as HTMLAudioElement),\n        backgroundColor,\n      };\n    }\n\n    if (element.tagName === \"FIGURE\") {\n      const parsedFigure = parseFigureElement(element, \"audio\");\n      if (!parsedFigure) {\n        return undefined;\n      }\n\n      const { targetElement, caption } = parsedFigure;\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseAudioElement(targetElement as HTMLAudioElement),\n        backgroundColor,\n        caption,\n      };\n    }\n\n    return undefined;\n  };\n\nexport const audioRender =\n  (config: AudioOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createAudioBlockConfig>, any, any>,\n    editor: BlockNoteEditor<\n      Record<\"audio\", ReturnType<typeof createAudioBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    const icon = document.createElement(\"div\");\n    icon.innerHTML = config.icon ?? FILE_AUDIO_ICON_SVG;\n\n    const audio = document.createElement(\"audio\");\n    audio.className = \"bn-audio\";\n    if (editor.resolveFileUrl) {\n      editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n        audio.src = downloadUrl;\n      });\n    } else {\n      audio.src = block.props.url;\n    }\n    audio.controls = true;\n    audio.contentEditable = \"false\";\n    audio.draggable = false;\n\n    return createFileBlockWrapper(\n      block,\n      editor,\n      { dom: audio },\n      icon.firstElementChild as HTMLElement,\n    );\n  };\n\nexport const audioToExternalHTML =\n  (_config: AudioOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createAudioBlockConfig>, any, any>,\n    _editor: BlockNoteEditor<\n      Record<\"audio\", ReturnType<typeof createAudioBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add audio\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    let audio;\n    if (block.props.showPreview) {\n      audio = document.createElement(\"audio\");\n      audio.src = block.props.url;\n    } else {\n      audio = document.createElement(\"a\");\n      audio.href = block.props.url;\n      audio.textContent = block.props.name || block.props.url;\n    }\n\n    if (block.props.caption) {\n      if (block.props.showPreview) {\n        return createFigureWithCaption(audio, block.props.caption);\n      } else {\n        return createLinkWithCaption(audio, block.props.caption);\n      }\n    }\n\n    return {\n      dom: audio,\n    };\n  };\n\nexport const createAudioBlockSpec = createBlockSpec(\n  createAudioBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"audio/*\"],\n    },\n    parse: audioParse(config),\n    render: audioRender(config),\n    toExternalHTML: audioToExternalHTML(config),\n    runsBefore: [\"file\"],\n  }),\n);\n","import type { HighlighterGeneric } from \"@shikijs/types\";\nimport { Parser, createHighlightPlugin } from \"prosemirror-highlight\";\nimport { createParser } from \"prosemirror-highlight/shiki\";\nimport { CodeBlockOptions, getLanguageId } from \"./block.js\";\n\nexport const shikiParserSymbol = Symbol.for(\"blocknote.shikiParser\");\nexport const shikiHighlighterPromiseSymbol = Symbol.for(\n  \"blocknote.shikiHighlighterPromise\",\n);\n\nexport function lazyShikiPlugin(options: CodeBlockOptions) {\n  const globalThisForShiki = globalThis as {\n    [shikiHighlighterPromiseSymbol]?: Promise<HighlighterGeneric<any, any>>;\n    [shikiParserSymbol]?: Parser;\n  };\n\n  let highlighter: HighlighterGeneric<any, any> | undefined;\n  let parser: Parser | undefined;\n  let hasWarned = false;\n  const lazyParser: Parser = (parserOptions) => {\n    if (!options.createHighlighter) {\n      if (process.env.NODE_ENV === \"development\" && !hasWarned) {\n        // eslint-disable-next-line no-console\n        console.log(\n          \"For syntax highlighting of code blocks, you must provide a `createCodeBlockSpec({ createHighlighter: () => ... })` function\",\n        );\n        hasWarned = true;\n      }\n      return [];\n    }\n    if (!highlighter) {\n      globalThisForShiki[shikiHighlighterPromiseSymbol] =\n        globalThisForShiki[shikiHighlighterPromiseSymbol] ||\n        options.createHighlighter();\n\n      return globalThisForShiki[shikiHighlighterPromiseSymbol].then(\n        (createdHighlighter) => {\n          highlighter = createdHighlighter;\n        },\n      );\n    }\n    const language = getLanguageId(options, parserOptions.language!);\n\n    if (\n      !language ||\n      language === \"text\" ||\n      language === \"none\" ||\n      language === \"plaintext\" ||\n      language === \"txt\"\n    ) {\n      return [];\n    }\n\n    if (!highlighter.getLoadedLanguages().includes(language)) {\n      return highlighter.loadLanguage(language);\n    }\n\n    if (!parser) {\n      parser =\n        globalThisForShiki[shikiParserSymbol] ||\n        createParser(highlighter as any);\n      globalThisForShiki[shikiParserSymbol] = parser;\n    }\n\n    return parser(parserOptions);\n  };\n\n  return createHighlightPlugin({\n    parser: lazyParser,\n    languageExtractor: (node) => node.attrs.language,\n    nodeTypes: [\"codeBlock\"],\n  });\n}\n","import type { HighlighterGeneric } from \"@shikijs/types\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { lazyShikiPlugin } from \"./shiki.js\";\nimport { DOMParser } from \"@tiptap/pm/model\";\n\nexport type CodeBlockOptions = {\n  /**\n   * Whether to indent lines with a tab when the user presses `Tab` in a code block.\n   *\n   * @default true\n   */\n  indentLineWithTab?: boolean;\n  /**\n   * The default language to use for code blocks.\n   *\n   * @default \"text\"\n   */\n  defaultLanguage?: string;\n  /**\n   * The languages that are supported in the editor.\n   *\n   * @example\n   * {\n   *   javascript: {\n   *     name: \"JavaScript\",\n   *     aliases: [\"js\"],\n   *   },\n   *   typescript: {\n   *     name: \"TypeScript\",\n   *     aliases: [\"ts\"],\n   *   },\n   * }\n   */\n  supportedLanguages?: Record<\n    string,\n    {\n      /**\n       * The display name of the language.\n       */\n      name: string;\n      /**\n       * Aliases for this language.\n       */\n      aliases?: string[];\n    }\n  >;\n  /**\n   * The highlighter to use for code blocks.\n   */\n  createHighlighter?: () => Promise<HighlighterGeneric<any, any>>;\n};\n\nexport type CodeBlockConfig = ReturnType<typeof createCodeBlockConfig>;\n\nexport const createCodeBlockConfig = createBlockConfig(\n  ({ defaultLanguage = \"text\" }: CodeBlockOptions) =>\n    ({\n      type: \"codeBlock\" as const,\n      propSchema: {\n        language: {\n          default: defaultLanguage,\n        },\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createCodeBlockSpec = createBlockSpec(\n  createCodeBlockConfig,\n  (options) => ({\n    meta: {\n      code: true,\n      defining: true,\n      isolating: false,\n    },\n    parse: (e) => {\n      if (e.tagName !== \"PRE\") {\n        return undefined;\n      }\n\n      if (\n        e.childElementCount !== 1 ||\n        e.firstElementChild?.tagName !== \"CODE\"\n      ) {\n        return undefined;\n      }\n\n      const code = e.firstElementChild!;\n      const language =\n        code.getAttribute(\"data-language\") ||\n        code.className\n          .split(\" \")\n          .find((name) => name.includes(\"language-\"))\n          ?.replace(\"language-\", \"\");\n\n      return { language };\n    },\n\n    parseContent: ({ el, schema }) => {\n      const parser = DOMParser.fromSchema(schema);\n      const code = el.firstElementChild!;\n\n      return parser.parse(code, {\n        preserveWhitespace: \"full\",\n        topNode: schema.nodes[\"codeBlock\"].create(),\n      }).content;\n    },\n\n    render(block, editor) {\n      const wrapper = document.createDocumentFragment();\n      const pre = document.createElement(\"pre\");\n      const code = document.createElement(\"code\");\n      pre.appendChild(code);\n\n      let removeSelectChangeListener = undefined;\n\n      if (options.supportedLanguages) {\n        const select = document.createElement(\"select\");\n\n        Object.entries(options.supportedLanguages ?? {}).forEach(\n          ([id, { name }]) => {\n            const option = document.createElement(\"option\");\n\n            option.value = id;\n            option.text = name;\n            select.appendChild(option);\n          },\n        );\n        select.value =\n          block.props.language || options.defaultLanguage || \"text\";\n\n        const handleLanguageChange = (event: Event) => {\n          const language = (event.target as HTMLSelectElement).value;\n\n          editor.updateBlock(block.id, { props: { language } });\n        };\n        select.addEventListener(\"change\", handleLanguageChange);\n        removeSelectChangeListener = () =>\n          select.removeEventListener(\"change\", handleLanguageChange);\n\n        const selectWrapper = document.createElement(\"div\");\n        selectWrapper.contentEditable = \"false\";\n\n        selectWrapper.appendChild(select);\n        wrapper.appendChild(selectWrapper);\n      }\n      wrapper.appendChild(pre);\n\n      return {\n        dom: wrapper,\n        contentDOM: code,\n        destroy: () => {\n          removeSelectChangeListener?.();\n        },\n      };\n    },\n    toExternalHTML(block) {\n      const pre = document.createElement(\"pre\");\n      const code = document.createElement(\"code\");\n      code.className = `language-${block.props.language}`;\n      code.dataset.language = block.props.language;\n      pre.appendChild(code);\n      return {\n        dom: pre,\n        contentDOM: code,\n      };\n    },\n  }),\n  (options) => {\n    return [\n      createExtension({\n        key: \"code-block-highlighter\",\n        prosemirrorPlugins: [lazyShikiPlugin(options)],\n      }),\n      createExtension({\n        key: \"code-block-keyboard-shortcuts\",\n        keyboardShortcuts: {\n          Delete: ({ editor }) => {\n            return editor.transact((tr) => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n              const { $from } = tr.selection;\n\n              // When inside empty codeblock, on `DELETE` key press, delete the codeblock\n              if (!$from.parent.textContent) {\n                editor.removeBlocks([block]);\n\n                return true;\n              }\n\n              return false;\n            });\n          },\n          Tab: ({ editor }) => {\n            if (options.indentLineWithTab === false) {\n              return false;\n            }\n\n            return editor.transact((tr) => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type === \"codeBlock\") {\n                // TODO should probably only tab when at a line start or already tabbed in\n                tr.insertText(\"  \");\n                return true;\n              }\n\n              return false;\n            });\n          },\n          Enter: ({ editor }) => {\n            return editor.transact((tr) => {\n              const { block, nextBlock } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n              const { $from } = tr.selection;\n\n              const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n              const endsWithDoubleNewline =\n                $from.parent.textContent.endsWith(\"\\n\\n\");\n\n              // The user is trying to exit the code block by pressing enter at the end of the code block\n              if (isAtEnd && endsWithDoubleNewline) {\n                // Remove the double newline\n                tr.delete($from.pos - 2, $from.pos);\n\n                // If there is a next block, move the cursor to it\n                if (nextBlock) {\n                  editor.setTextCursorPosition(nextBlock, \"start\");\n                  return true;\n                }\n\n                // If there is no next block, insert a new paragraph\n                const [newBlock] = editor.insertBlocks(\n                  [{ type: \"paragraph\" }],\n                  block,\n                  \"after\",\n                );\n                // Move the cursor to the new block\n                editor.setTextCursorPosition(newBlock, \"start\");\n\n                return true;\n              }\n\n              tr.insertText(\"\\n\");\n              return true;\n            });\n          },\n          \"Shift-Enter\": ({ editor }) => {\n            return editor.transact(() => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n\n              const [newBlock] = editor.insertBlocks(\n                // insert a new paragraph\n                [{ type: \"paragraph\" }],\n                block,\n                \"after\",\n              );\n              // move the cursor to the new block\n              editor.setTextCursorPosition(newBlock, \"start\");\n              return true;\n            });\n          },\n        },\n        inputRules: [\n          {\n            find: /^```(.*?)\\s$/,\n            replace: ({ match }) => {\n              const languageName = match[1].trim();\n              const attributes = {\n                language: getLanguageId(options, languageName) ?? languageName,\n              };\n\n              return {\n                type: \"codeBlock\",\n                props: {\n                  language: attributes.language,\n                },\n                content: [],\n              };\n            },\n          },\n        ],\n      }),\n    ];\n  },\n);\n\nexport function getLanguageId(\n  options: CodeBlockOptions,\n  languageName: string,\n): string | undefined {\n  return Object.entries(options.supportedLanguages ?? {}).find(\n    ([id, { aliases }]) => {\n      return aliases?.includes(languageName) || id === languageName;\n    },\n  )?.[0];\n}\n","import { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\n\nexport type DividerBlockConfig = ReturnType<typeof createDividerBlockConfig>;\n\nexport const createDividerBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"divider\" as const,\n      propSchema: {},\n      content: \"none\",\n    }) as const,\n);\n\nexport const createDividerBlockSpec = createBlockSpec(\n  createDividerBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"HR\") {\n        return {};\n      }\n\n      return undefined;\n    },\n    render() {\n      const dom = document.createElement(\"hr\");\n\n      return {\n        dom,\n      };\n    },\n  },\n  [\n    createExtension({\n      key: \"divider-block-shortcuts\",\n      inputRules: [\n        {\n          find: new RegExp(`^---$`),\n          replace() {\n            return { type: \"divider\", props: {}, content: [] };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","export const parseEmbedElement = (embedElement: HTMLEmbedElement) => {\n  const url = embedElement.src || undefined;\n\n  return { url };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseEmbedElement } from \"./helpers/parse/parseEmbedElement.js\";\nimport { parseFigureElement } from \"./helpers/parse/parseFigureElement.js\";\nimport { createFileBlockWrapper } from \"./helpers/render/createFileBlockWrapper.js\";\nimport { createLinkWithCaption } from \"./helpers/toExternalHTML/createLinkWithCaption.js\";\n\nexport type FileBlockConfig = ReturnType<typeof createFileBlockConfig>;\n\nexport const createFileBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"file\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n      },\n      content: \"none\" as const,\n    }) as const,\n);\n\nexport const fileParse = () => (element: HTMLElement) => {\n  if (element.tagName === \"EMBED\") {\n    // Ignore if parent figure has already been parsed.\n    if (element.closest(\"figure\")) {\n      return undefined;\n    }\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseEmbedElement(element as HTMLEmbedElement),\n      backgroundColor,\n    };\n  }\n\n  if (element.tagName === \"FIGURE\") {\n    const parsedFigure = parseFigureElement(element, \"embed\");\n    if (!parsedFigure) {\n      return undefined;\n    }\n\n    const { targetElement, caption } = parsedFigure;\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseEmbedElement(targetElement as HTMLEmbedElement),\n      backgroundColor,\n      caption,\n    };\n  }\n\n  return undefined;\n};\n\nexport const createFileBlockSpec = createBlockSpec(createFileBlockConfig, {\n  meta: {\n    fileBlockAccept: [\"*/*\"],\n  },\n  parse: fileParse(),\n  render(block, editor) {\n    return createFileBlockWrapper(block, editor);\n  },\n  toExternalHTML(block) {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add file\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    const fileSrcLink = document.createElement(\"a\");\n    fileSrcLink.href = block.props.url;\n    fileSrcLink.textContent = block.props.name || block.props.url;\n\n    if (block.props.caption) {\n      return createLinkWithCaption(fileSrcLink, block.props.caption);\n    }\n\n    return {\n      dom: fileSrcLink,\n    };\n  },\n});\n","import { ViewMutationRecord } from \"@tiptap/pm/view\";\n\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { Block } from \"../defaultBlocks.js\";\n\ntype ToggledState = {\n  set: (block: Block<any, any, any>, isToggled: boolean) => void;\n  get: (block: Block<any, any, any>) => boolean;\n};\n\nexport const defaultToggledState: ToggledState = {\n  set: (block, isToggled: boolean) =>\n    window.localStorage.setItem(\n      `toggle-${block.id}`,\n      isToggled ? \"true\" : \"false\",\n    ),\n  get: (block) => window.localStorage.getItem(`toggle-${block.id}`) === \"true\",\n};\n\nexport const createToggleWrapper = (\n  block: Block<any, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  renderedElement: HTMLElement,\n  toggledState: ToggledState = defaultToggledState,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n  ignoreMutation?: (mutation: ViewMutationRecord) => boolean;\n  destroy?: () => void;\n} => {\n  if (\"isToggleable\" in block.props && !block.props.isToggleable) {\n    return {\n      dom: renderedElement,\n    };\n  }\n\n  const dom = document.createElement(\"div\");\n\n  const toggleWrapper = document.createElement(\"div\");\n  toggleWrapper.className = \"bn-toggle-wrapper\";\n\n  const toggleButton = document.createElement(\"button\");\n  toggleButton.className = \"bn-toggle-button\";\n  toggleButton.type = \"button\";\n  toggleButton.innerHTML =\n    // https://fonts.google.com/icons?selected=Material+Symbols+Rounded:chevron_right:FILL@0;wght@700;GRAD@0;opsz@24&icon.query=chevron&icon.style=Rounded&icon.size=24&icon.color=%23e8eaed\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\" width=\"24px\" fill=\"CURRENTCOLOR\"><path d=\"M320-200v-560l440 280-440 280Z\"/></svg>';\n  const toggleButtonMouseDown = (event: MouseEvent) => event.preventDefault();\n  toggleButton.addEventListener(\"mousedown\", toggleButtonMouseDown);\n  const toggleButtonOnClick = () => {\n    // Toggles visibility of child blocks. Also adds/removes the \"add block\"\n    // button if there are no child blocks.\n    if (toggleWrapper.getAttribute(\"data-show-children\") === \"true\") {\n      toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n      toggledState.set(editor.getBlock(block)!, false);\n\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    } else {\n      toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n      toggledState.set(editor.getBlock(block)!, true);\n\n      if (\n        editor.isEditable &&\n        editor.getBlock(block)?.children.length === 0 &&\n        !dom.contains(toggleAddBlockButton)\n      ) {\n        dom.appendChild(toggleAddBlockButton);\n      }\n    }\n  };\n  toggleButton.addEventListener(\"click\", toggleButtonOnClick);\n\n  toggleWrapper.appendChild(toggleButton);\n  toggleWrapper.appendChild(renderedElement);\n\n  const toggleAddBlockButton = document.createElement(\"button\");\n  toggleAddBlockButton.className = \"bn-toggle-add-block-button\";\n  toggleAddBlockButton.type = \"button\";\n  toggleAddBlockButton.textContent =\n    editor.dictionary.toggle_blocks.add_block_button;\n  const toggleAddBlockButtonMouseDown = (event: MouseEvent) =>\n    event.preventDefault();\n  toggleAddBlockButton.addEventListener(\n    \"mousedown\",\n    toggleAddBlockButtonMouseDown,\n  );\n  const toggleAddBlockButtonOnClick = () => {\n    // Adds a single empty child block.\n    editor.transact(() => {\n      // dom.removeChild(toggleAddBlockButton);\n\n      const updatedBlock = editor.updateBlock(block, {\n        // Single empty block with default type.\n        children: [{}],\n      });\n      editor.setTextCursorPosition(updatedBlock.children[0].id, \"end\");\n      editor.focus();\n    });\n  };\n  toggleAddBlockButton.addEventListener(\"click\", toggleAddBlockButtonOnClick);\n\n  dom.appendChild(toggleWrapper);\n\n  let childCount = block.children.length;\n  const onEditorChange = editor.onChange(() => {\n    const newChildCount = editor.getBlock(block)?.children.length ?? 0;\n\n    if (newChildCount > childCount) {\n      // If a child block is added while children are hidden, show children.\n      if (toggleWrapper.getAttribute(\"data-show-children\") === \"false\") {\n        toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n        toggledState.set(editor.getBlock(block)!, true);\n      }\n\n      // Remove the \"add block\" button as we want to show child blocks and\n      // there is at least one child block.\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    } else if (newChildCount === 0 && newChildCount < childCount) {\n      // If the last child block is removed while children are shown, hide\n      // children.\n      if (toggleWrapper.getAttribute(\"data-show-children\") === \"true\") {\n        toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n        toggledState.set(editor.getBlock(block)!, false);\n      }\n\n      // Remove the \"add block\" button as we want to hide child blocks,\n      // regardless of whether there are child blocks or not.\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    }\n\n    childCount = newChildCount;\n  });\n\n  if (toggledState.get(block)) {\n    toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n\n    if (editor.isEditable && block.children.length === 0) {\n      // If the toggle is set to show children, but there are no children,\n      // we add the \"add block\" button.\n      dom.appendChild(toggleAddBlockButton);\n    }\n  } else {\n    toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n  }\n\n  return {\n    dom,\n    // Prevents re-renders when the toggle button is clicked.\n    ignoreMutation: (mutation) => {\n      if (\n        mutation instanceof MutationRecord &&\n        // We want to prevent re-renders when the view changes, so we ignore\n        // all mutations where the `data-show-children` attribute is changed\n        // or the \"add block\" button is added/removed.\n        ((mutation.type === \"attributes\" &&\n          mutation.target === toggleWrapper &&\n          mutation.attributeName === \"data-show-children\") ||\n          (mutation.type === \"childList\" &&\n            (mutation.addedNodes[0] === toggleAddBlockButton ||\n              mutation.removedNodes[0] === toggleAddBlockButton)))\n      ) {\n        return true;\n      }\n      return false;\n    },\n    destroy: () => {\n      toggleButton.removeEventListener(\"mousedown\", toggleButtonMouseDown);\n      toggleButton.removeEventListener(\"click\", toggleButtonOnClick);\n      toggleAddBlockButton.removeEventListener(\n        \"mousedown\",\n        toggleAddBlockButtonMouseDown,\n      );\n      toggleAddBlockButton.removeEventListener(\n        \"click\",\n        toggleAddBlockButtonOnClick,\n      );\n      onEditorChange?.();\n    },\n  };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\nimport { createToggleWrapper } from \"../ToggleWrapper/createToggleWrapper.js\";\n\nconst HEADING_LEVELS = [1, 2, 3, 4, 5, 6] as const;\n\nexport interface HeadingOptions {\n  defaultLevel?: (typeof HEADING_LEVELS)[number];\n  levels?: readonly number[];\n  // TODO should probably use composition instead of this\n  allowToggleHeadings?: boolean;\n}\n\nconst createHeadingKeyboardShortcut =\n  (level: number) =>\n  ({ editor }: { editor: BlockNoteEditor<any, any, any> }) => {\n    const cursorPosition = editor.getTextCursorPosition();\n\n    if (\n      editor.schema.blockSchema[cursorPosition.block.type].content !== \"inline\"\n    ) {\n      return false;\n    }\n\n    editor.updateBlock(cursorPosition.block, {\n      type: \"heading\",\n      props: { level },\n    });\n\n    return true;\n  };\n\nexport type HeadingBlockConfig = ReturnType<typeof createHeadingBlockConfig>;\n\nexport const createHeadingBlockConfig = createBlockConfig(\n  ({\n    defaultLevel = 1,\n    levels = HEADING_LEVELS,\n    allowToggleHeadings = true,\n  }: HeadingOptions = {}) =>\n    ({\n      type: \"heading\" as const,\n      propSchema: {\n        ...defaultProps,\n        level: { default: defaultLevel, values: levels },\n        ...(allowToggleHeadings\n          ? { isToggleable: { default: false, optional: true } as const }\n          : {}),\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createHeadingBlockSpec = createBlockSpec(\n  createHeadingBlockConfig,\n  ({ allowToggleHeadings = true }: HeadingOptions = {}) => ({\n    meta: {\n      isolating: false,\n    },\n    parse(e) {\n      let level: number;\n      switch (e.tagName) {\n        case \"H1\":\n          level = 1;\n          break;\n        case \"H2\":\n          level = 2;\n          break;\n        case \"H3\":\n          level = 3;\n          break;\n        case \"H4\":\n          level = 4;\n          break;\n        case \"H5\":\n          level = 5;\n          break;\n        case \"H6\":\n          level = 6;\n          break;\n        default:\n          return undefined;\n      }\n\n      return {\n        ...parseDefaultProps(e),\n        level,\n      };\n    },\n    render(block, editor) {\n      const dom = document.createElement(`h${block.props.level}`);\n\n      if (allowToggleHeadings) {\n        const toggleWrapper = createToggleWrapper(block, editor, dom);\n        return { ...toggleWrapper, contentDOM: dom };\n      }\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const dom = document.createElement(`h${block.props.level}`);\n      addDefaultPropsExternalHTML(block.props, dom);\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n  }),\n  ({ levels = HEADING_LEVELS }: HeadingOptions = {}) => [\n    createExtension({\n      key: \"heading-shortcuts\",\n      keyboardShortcuts: Object.fromEntries(\n        levels.map((level) => [\n          `Mod-Alt-${level}`,\n          createHeadingKeyboardShortcut(level),\n        ]) ?? [],\n      ),\n      inputRules: levels.map((level) => ({\n        find: new RegExp(`^(#{${level}})\\\\s$`),\n        replace({ match }: { match: RegExpMatchArray }) {\n          return {\n            type: \"heading\",\n            props: {\n              level: match[1].length,\n            },\n          };\n        },\n      })),\n    }),\n  ],\n);\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\nimport { createFileBlockWrapper } from \"./createFileBlockWrapper.js\";\n\nexport const createResizableFileBlockWrapper = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        backgroundColor: { default: \"default\" };\n        name: { default: \"\" };\n        url: { default: \"\" };\n        caption: { default: \"\" };\n        showPreview?: { default: true };\n        previewWidth?: { default: number };\n        textAlignment?: { default: \"left\" };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n  editor: BlockNoteEditor<any, any, any>,\n  element: { dom: HTMLElement; destroy?: () => void },\n  resizeHandlesContainerElement: HTMLElement,\n  buttonIcon?: HTMLElement,\n): { dom: HTMLElement; destroy: () => void } => {\n  const { dom, destroy } = createFileBlockWrapper(\n    block,\n    editor,\n    element,\n    buttonIcon,\n  );\n  const wrapper = dom;\n  wrapper.style.position = \"relative\";\n  if (block.props.url && block.props.showPreview) {\n    if (block.props.previewWidth) {\n      wrapper.style.width = `${block.props.previewWidth}px`;\n    } else {\n      wrapper.style.width = \"fit-content\";\n    }\n  }\n\n  const leftResizeHandle = document.createElement(\"div\");\n  leftResizeHandle.className = \"bn-resize-handle\";\n  leftResizeHandle.style.left = \"4px\";\n  const rightResizeHandle = document.createElement(\"div\");\n  rightResizeHandle.className = \"bn-resize-handle\";\n  rightResizeHandle.style.right = \"4px\";\n\n  // This element ensures `mousemove` and `mouseup` events are captured while\n  // resizing when the cursor is over the wrapper content. This is because\n  // embeds are treated as separate HTML documents, so if the content is an\n  // embed, the events will only fire within that document.\n  const eventCaptureElement = document.createElement(\"div\");\n  eventCaptureElement.style.position = \"absolute\";\n  eventCaptureElement.style.height = \"100%\";\n  eventCaptureElement.style.width = \"100%\";\n\n  // Temporary parameters set when the user begins resizing the element, used to\n  // calculate the new width of the element.\n  let resizeParams:\n    | {\n        handleUsed: \"left\" | \"right\";\n        initialWidth: number;\n        initialClientX: number;\n      }\n    | undefined;\n  let width = block.props.previewWidth! as number;\n\n  // Updates the element width with an updated width depending on the cursor X\n  // offset from when the resize began, and which resize handle is being used.\n  const windowMouseMoveHandler = (event: MouseEvent | TouchEvent) => {\n    if (!resizeParams) {\n      if (\n        !editor.isEditable &&\n        resizeHandlesContainerElement.contains(leftResizeHandle) &&\n        resizeHandlesContainerElement.contains(rightResizeHandle)\n      ) {\n        resizeHandlesContainerElement.removeChild(leftResizeHandle);\n        resizeHandlesContainerElement.removeChild(rightResizeHandle);\n      }\n\n      return;\n    }\n\n    let newWidth: number;\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    if (block.props.textAlignment === \"center\") {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth +\n          (resizeParams.initialClientX - clientX) * 2;\n      } else {\n        newWidth =\n          resizeParams.initialWidth +\n          (clientX - resizeParams.initialClientX) * 2;\n      }\n    } else {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth + resizeParams.initialClientX - clientX;\n      } else {\n        newWidth =\n          resizeParams.initialWidth + clientX - resizeParams.initialClientX;\n      }\n    }\n\n    // Min element width in px.\n    const minWidth = 64;\n\n    // Ensures the element is not wider than the editor and not narrower than a\n    // predetermined minimum width.\n    width = Math.min(\n      Math.max(newWidth, minWidth),\n      editor.domElement?.firstElementChild?.clientWidth || Number.MAX_VALUE,\n    );\n    wrapper.style.width = `${width}px`;\n  };\n  // Stops mouse movements from resizing the element and updates the block's\n  // `width` prop to the new value.\n  const windowMouseUpHandler = (event: MouseEvent | TouchEvent) => {\n    // Hides the drag handles if the cursor is no longer over the element.\n    if (\n      (!event.target ||\n        !wrapper.contains(event.target as Node) ||\n        !editor.isEditable) &&\n      resizeHandlesContainerElement.contains(leftResizeHandle) &&\n      resizeHandlesContainerElement.contains(rightResizeHandle)\n    ) {\n      resizeHandlesContainerElement.removeChild(leftResizeHandle);\n      resizeHandlesContainerElement.removeChild(rightResizeHandle);\n    }\n\n    if (!resizeParams) {\n      return;\n    }\n\n    resizeParams = undefined;\n\n    if (wrapper.contains(eventCaptureElement)) {\n      wrapper.removeChild(eventCaptureElement);\n    }\n\n    editor.updateBlock(block, {\n      props: {\n        previewWidth: width,\n      },\n    });\n  };\n\n  // Shows the resize handles when hovering over the wrapper with the cursor.\n  const wrapperMouseEnterHandler = () => {\n    if (editor.isEditable) {\n      resizeHandlesContainerElement.appendChild(leftResizeHandle);\n      resizeHandlesContainerElement.appendChild(rightResizeHandle);\n    }\n  };\n  // Hides the resize handles when the cursor leaves the wrapper, unless the\n  // cursor moves to one of the resize handles.\n  const wrapperMouseLeaveHandler = (event: MouseEvent) => {\n    if (\n      event.relatedTarget === leftResizeHandle ||\n      event.relatedTarget === rightResizeHandle\n    ) {\n      return;\n    }\n\n    if (resizeParams) {\n      return;\n    }\n\n    if (\n      editor.isEditable &&\n      resizeHandlesContainerElement.contains(leftResizeHandle) &&\n      resizeHandlesContainerElement.contains(rightResizeHandle)\n    ) {\n      resizeHandlesContainerElement.removeChild(leftResizeHandle);\n      resizeHandlesContainerElement.removeChild(rightResizeHandle);\n    }\n  };\n\n  // Sets the resize params, allowing the user to begin resizing the element by\n  // moving the cursor left or right.\n  const leftResizeHandleMouseDownHandler = (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    if (!wrapper.contains(eventCaptureElement)) {\n      wrapper.appendChild(eventCaptureElement);\n    }\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    resizeParams = {\n      handleUsed: \"left\",\n      initialWidth: wrapper.clientWidth,\n      initialClientX: clientX,\n    };\n  };\n  const rightResizeHandleMouseDownHandler = (\n    event: MouseEvent | TouchEvent,\n  ) => {\n    event.preventDefault();\n\n    if (!wrapper.contains(eventCaptureElement)) {\n      wrapper.appendChild(eventCaptureElement);\n    }\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    resizeParams = {\n      handleUsed: \"right\",\n      initialWidth: wrapper.clientWidth,\n      initialClientX: clientX,\n    };\n  };\n\n  window.addEventListener(\"mousemove\", windowMouseMoveHandler);\n  window.addEventListener(\"touchmove\", windowMouseMoveHandler);\n  window.addEventListener(\"mouseup\", windowMouseUpHandler);\n  window.addEventListener(\"touchend\", windowMouseUpHandler);\n  wrapper.addEventListener(\"mouseenter\", wrapperMouseEnterHandler);\n  wrapper.addEventListener(\"mouseleave\", wrapperMouseLeaveHandler);\n  leftResizeHandle.addEventListener(\n    \"mousedown\",\n    leftResizeHandleMouseDownHandler,\n  );\n  leftResizeHandle.addEventListener(\n    \"touchstart\",\n    leftResizeHandleMouseDownHandler,\n  );\n  rightResizeHandle.addEventListener(\n    \"mousedown\",\n    rightResizeHandleMouseDownHandler,\n  );\n  rightResizeHandle.addEventListener(\n    \"touchstart\",\n    rightResizeHandleMouseDownHandler,\n  );\n\n  return {\n    dom: wrapper,\n    destroy: () => {\n      destroy?.();\n      window.removeEventListener(\"mousemove\", windowMouseMoveHandler);\n      window.removeEventListener(\"touchmove\", windowMouseMoveHandler);\n      window.removeEventListener(\"mouseup\", windowMouseUpHandler);\n      window.removeEventListener(\"touchend\", windowMouseUpHandler);\n      wrapper.removeEventListener(\"mouseenter\", wrapperMouseEnterHandler);\n      wrapper.removeEventListener(\"mouseleave\", wrapperMouseLeaveHandler);\n      leftResizeHandle.removeEventListener(\n        \"mousedown\",\n        leftResizeHandleMouseDownHandler,\n      );\n      leftResizeHandle.removeEventListener(\n        \"touchstart\",\n        leftResizeHandleMouseDownHandler,\n      );\n      rightResizeHandle.removeEventListener(\n        \"mousedown\",\n        rightResizeHandleMouseDownHandler,\n      );\n      rightResizeHandle.removeEventListener(\n        \"touchstart\",\n        rightResizeHandleMouseDownHandler,\n      );\n    },\n  };\n};\n","export const parseImageElement = (imageElement: HTMLImageElement) => {\n  const url = imageElement.src || undefined;\n  const previewWidth = imageElement.width || undefined;\n  const name = imageElement.alt || undefined;\n\n  return { url, previewWidth, name };\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockFromConfig,\n  createBlockConfig,\n  createBlockSpec,\n} from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createResizableFileBlockWrapper } from \"../File/helpers/render/createResizableFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseImageElement } from \"./parseImageElement.js\";\n\nexport const FILE_IMAGE_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z\"></path></svg>';\n\nexport interface ImageOptions {\n  icon?: string;\n}\n\nexport type ImageBlockConfig = ReturnType<typeof createImageBlockConfig>;\n\nexport const createImageBlockConfig = createBlockConfig(\n  (_ctx: ImageOptions = {}) =>\n    ({\n      type: \"image\" as const,\n      propSchema: {\n        textAlignment: defaultProps.textAlignment,\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n\n        showPreview: {\n          default: true,\n        },\n        // File preview width in px.\n        previewWidth: {\n          default: undefined,\n          type: \"number\" as const,\n        },\n      },\n      content: \"none\" as const,\n    }) as const,\n);\n\nexport const imageParse =\n  (_config: ImageOptions = {}) =>\n  (element: HTMLElement) => {\n    if (element.tagName === \"IMG\") {\n      // Ignore if parent figure has already been parsed.\n      if (element.closest(\"figure\")) {\n        return undefined;\n      }\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseImageElement(element as HTMLImageElement),\n        backgroundColor,\n      };\n    }\n\n    if (element.tagName === \"FIGURE\") {\n      const parsedFigure = parseFigureElement(element, \"img\");\n      if (!parsedFigure) {\n        return undefined;\n      }\n\n      const { targetElement, caption } = parsedFigure;\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseImageElement(targetElement as HTMLImageElement),\n        backgroundColor,\n        caption,\n      };\n    }\n\n    return undefined;\n  };\n\nexport const imageRender =\n  (config: ImageOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createImageBlockConfig>, any, any>,\n    editor: BlockNoteEditor<\n      Record<\"image\", ReturnType<typeof createImageBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    const icon = document.createElement(\"div\");\n    icon.innerHTML = config.icon ?? FILE_IMAGE_ICON_SVG;\n\n    const imageWrapper = document.createElement(\"div\");\n    imageWrapper.className = \"bn-visual-media-wrapper\";\n\n    const image = document.createElement(\"img\");\n    image.className = \"bn-visual-media\";\n    if (editor.resolveFileUrl) {\n      editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n        image.src = downloadUrl;\n      });\n    } else {\n      image.src = block.props.url;\n    }\n\n    image.alt = block.props.name || block.props.caption || \"BlockNote image\";\n    image.contentEditable = \"false\";\n    image.draggable = false;\n    imageWrapper.appendChild(image);\n\n    return createResizableFileBlockWrapper(\n      block,\n      editor,\n      { dom: imageWrapper },\n      imageWrapper,\n      icon.firstElementChild as HTMLElement,\n    );\n  };\n\nexport const imageToExternalHTML =\n  (_config: ImageOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createImageBlockConfig>, any, any>,\n    _editor: BlockNoteEditor<\n      Record<\"image\", ReturnType<typeof createImageBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add image\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    let image;\n    if (block.props.showPreview) {\n      image = document.createElement(\"img\");\n      image.src = block.props.url;\n      image.alt = block.props.name || block.props.caption || \"BlockNote image\";\n      if (block.props.previewWidth) {\n        image.width = block.props.previewWidth;\n      }\n    } else {\n      image = document.createElement(\"a\");\n      image.href = block.props.url;\n      image.textContent = block.props.name || block.props.url;\n    }\n\n    if (block.props.caption) {\n      if (block.props.showPreview) {\n        return createFigureWithCaption(image, block.props.caption);\n      } else {\n        return createLinkWithCaption(image, block.props.caption);\n      }\n    }\n\n    return {\n      dom: image,\n    };\n  };\n\nexport const createImageBlockSpec = createBlockSpec(\n  createImageBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"image/*\"],\n    },\n    parse: imageParse(config),\n    render: imageRender(config),\n    toExternalHTML: imageToExternalHTML(config),\n    runsBefore: [\"file\"],\n  }),\n);\n","import { EditorState, Transaction } from \"prosemirror-state\";\n\nimport {\n  getBlockInfo,\n  getNearestBlockPos,\n} from \"../../../getBlockInfoFromPos.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport const splitBlockCommand = (\n  posInBlock: number,\n  keepType?: boolean,\n  keepProps?: boolean,\n) => {\n  return ({\n    state,\n    dispatch,\n  }: {\n    state: EditorState;\n    dispatch: ((args?: any) => any) | undefined;\n  }) => {\n    if (dispatch) {\n      return splitBlockTr(state.tr, posInBlock, keepType, keepProps);\n    }\n\n    return true;\n  };\n};\n\nexport const splitBlockTr = (\n  tr: Transaction,\n  posInBlock: number,\n  keepType?: boolean,\n  keepProps?: boolean,\n): boolean => {\n  const nearestBlockContainerPos = getNearestBlockPos(tr.doc, posInBlock);\n\n  const info = getBlockInfo(nearestBlockContainerPos);\n\n  if (!info.isBlockContainer) {\n    return false;\n  }\n  const schema = getPmSchema(tr);\n\n  const types = [\n    {\n      type: info.bnBlock.node.type, // always keep blockcontainer type\n      attrs: keepProps ? { ...info.bnBlock.node.attrs, id: undefined } : {},\n    },\n    {\n      type: keepType ? info.blockContent.node.type : schema.nodes[\"paragraph\"],\n      attrs: keepProps ? { ...info.blockContent.node.attrs } : {},\n    },\n  ];\n\n  tr.split(posInBlock, 2, types);\n\n  return true;\n};\n","import { splitBlockTr } from \"../../api/blockManipulation/commands/splitBlock/splitBlock.js\";\nimport { updateBlockTr } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromTransaction } from \"../../api/getBlockInfoFromPos.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\n\nexport const handleEnter = (\n  editor: BlockNoteEditor<any, any, any>,\n  listItemType: string,\n) => {\n  const { blockInfo, selectionEmpty } = editor.transact((tr) => {\n    return {\n      blockInfo: getBlockInfoFromTransaction(tr),\n      selectionEmpty: tr.selection.anchor === tr.selection.head,\n    };\n  });\n\n  if (!blockInfo.isBlockContainer) {\n    return false;\n  }\n  const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n  if (!(blockContent.node.type.name === listItemType) || !selectionEmpty) {\n    return false;\n  }\n\n  if (blockContent.node.childCount === 0) {\n    editor.transact((tr) => {\n      updateBlockTr(tr, blockContainer.beforePos, {\n        type: \"paragraph\",\n        props: {},\n      });\n    });\n    return true;\n  } else if (blockContent.node.childCount > 0) {\n    return editor.transact((tr) => {\n      tr.deleteSelection();\n      return splitBlockTr(tr, tr.selection.from, true);\n    });\n  }\n\n  return false;\n};\n","import { DOMParser, Fragment, Schema } from \"prosemirror-model\";\n\n/**\n * This function is used to parse the content of a list item external HTML node.\n *\n * Due to a change in how prosemirror-model handles parsing elements, we have additional flexibility in how we can \"fit\" content into a list item.\n *\n * We've decided to take an approach that is similar to Notion. The core rules of the algorithm are:\n *\n *  - If the first child of an `li` has ONLY text content, take the text content, and flatten it into the list item. Subsequent siblings are carried over as is, as children of the list item.\n *    - e.g. `<li><h1>Hello</h1><p>World</p></li> -> <li>Hello<blockGroup><blockContainer><p>World</p></blockContainer></blockGroup></li>`\n *  - Else, take the content and insert it as children instead.\n *    - e.g. `<li><img src=\"url\" /></li> -> <li><p></p><blockGroup><blockContainer><img src=\"url\" /></blockContainer></blockGroup></li>`\n *\n * This ensures that a list item's content is always valid ProseMirror content. Smoothing over differences between how external HTML may be rendered, and how ProseMirror expects content to be structured.\n */\nexport function getListItemContent(\n  /**\n   * The `li` element to parse.\n   */\n  _node: Node,\n  /**\n   * The schema to use for parsing.\n   */\n  schema: Schema,\n  /**\n   * The name of the list item node.\n   */\n  name: string,\n): Fragment {\n  /**\n   * To actually implement this algorithm, we need to leverage ProseMirror's \"fitting\" algorithm.\n   * Where, if content is parsed which doesn't fit into the current node, it will be moved into the parent node.\n   *\n   * This allows us to parse multiple pieces of content from within the list item (even though it normally would not match the list item's schema) and \"throw\" the excess content into the list item's children.\n   *\n   * The expected return value is a `Fragment` which contains the list item's content as the first element, and the children wrapped in a blockGroup node. Like so:\n   * ```\n   * Fragment<[Node<Text>, Node<BlockGroup<Node<BlockContainer<any>>>>]>\n   * ```\n   */\n  const parser = DOMParser.fromSchema(schema);\n\n  // TODO: This will be unnecessary in the future: https://github.com/ProseMirror/prosemirror-model/commit/166188d4f9db96eb86fb7de62e72049c86c9dd79\n  const node = _node as HTMLElement;\n\n  // Move the `li` element's content into a new `div` element\n  // This is a hacky workaround to not re-trigger list item parsing,\n  // when we are looking to understand what the list item's content actually is, in terms of the schema.\n  const clonedNodeDiv = document.createElement(\"div\");\n  // Mark the `div` element as a `blockGroup` to make the parsing easier.\n  clonedNodeDiv.setAttribute(\"data-node-type\", \"blockGroup\");\n  // Clone all children of the `li` element into the new `div` element\n  for (const child of Array.from(node.childNodes)) {\n    clonedNodeDiv.appendChild(child.cloneNode(true));\n  }\n\n  // Parses children of the `li` element into a `blockGroup` with `blockContainer` node children\n  // This is the structure of list item children, so parsing into this structure allows for\n  // easy separation of list item content from child list item content.\n  let blockGroupNode = parser.parse(clonedNodeDiv, {\n    topNode: schema.nodes.blockGroup.create(),\n  });\n\n  // There is an edge case where a list item's content may contain a `<input>` element.\n  // Causing it to be recognized as a `checkListItem`.\n  // We want to skip this, and just parse the list item's content as is.\n  if (blockGroupNode.firstChild?.firstChild?.type.name === \"checkListItem\") {\n    // We skip the first child, by cutting it out of the `blockGroup` node.\n    // and continuing with the rest of the algorithm.\n    blockGroupNode = blockGroupNode.copy(\n      blockGroupNode.content.cut(\n        blockGroupNode.firstChild.firstChild.nodeSize + 2,\n      ),\n    );\n  }\n\n  // Structure above is `blockGroup<blockContainer<any>[]>`\n  // We want to extract the first `blockContainer` node's content, and see if it is a text block.\n  const listItemsFirstChild = blockGroupNode.firstChild?.firstChild;\n\n  // If the first node is not a text block, then it's first child is not compatible with the list item node.\n  if (!listItemsFirstChild?.isTextblock) {\n    // So, we do not try inserting anything into the list item, and instead return anything we found as children for the list item.\n    return Fragment.from(blockGroupNode);\n  }\n\n  // If it is a text block, then we know it only contains text content.\n  // So, we extract it, and insert its content into the `listItemNode`.\n  // The remaining nodes in the `blockGroup` stay in-place.\n  const listItemNode = schema.nodes[name].create(\n    {},\n    listItemsFirstChild.content,\n  );\n\n  // We have `blockGroup<listItemsFirstChild, ...blockContainer<any>[]>`\n  // We want to extract out the rest of the nodes as `<...blockContainer<any>[]>`\n  const remainingListItemChildren = blockGroupNode.content.cut(\n    // +2 for the `blockGroup` node's start and end markers\n    listItemsFirstChild.nodeSize + 2,\n  );\n  const hasRemainingListItemChildren = remainingListItemChildren.size > 0;\n\n  if (hasRemainingListItemChildren) {\n    // Copy the remaining list item children back into the `blockGroup` node.\n    // This will make it back into: `blockGroup<...blockContainer<any>[]>`\n    const listItemsChildren = blockGroupNode.copy(remainingListItemChildren);\n\n    // Return the `listItem` node's content, then add the parsed children after to be lifted out by ProseMirror \"fitting\" algorithm.\n    return listItemNode.content.addToEnd(listItemsChildren);\n  }\n\n  // Otherwise, just return the `listItem` node's content.\n  return listItemNode.content;\n}\n","import { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { createExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\n\nexport type BulletListItemBlockConfig = ReturnType<\n  typeof createBulletListItemBlockConfig\n>;\n\nexport const createBulletListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"bulletListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createBulletListItemBlockSpec = createBlockSpec(\n  createBulletListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"UL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"UL\")\n      ) {\n        return parseDefaultProps(element);\n      }\n\n      return undefined;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"bulletListItem\"),\n    render() {\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const dom = document.createElement(\"p\");\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createExtension({\n      key: \"bullet-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"bulletListItem\");\n        },\n        \"Mod-Shift-8\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"bulletListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`^[-+*]\\\\s$`),\n          replace({ editor }) {\n            const blockInfo = getBlockInfoFromSelection(\n              editor.prosemirrorState,\n            );\n\n            if (blockInfo.blockNoteType === \"heading\") {\n              return;\n            }\n            return {\n              type: \"bulletListItem\",\n              props: {},\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import { createExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\n\nexport type CheckListItemBlockConfig = ReturnType<\n  typeof createCheckListItemConfig\n>;\n\nexport const createCheckListItemConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"checkListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n        checked: { default: false, type: \"boolean\" },\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createCheckListItemBlockSpec = createBlockSpec(\n  createCheckListItemConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"input\") {\n        // Ignore if we already parsed an ancestor list item to avoid double-parsing.\n        if (element.closest(\"[data-content-type]\") || element.closest(\"li\")) {\n          return undefined;\n        }\n\n        if ((element as HTMLInputElement).type === \"checkbox\") {\n          return { checked: (element as HTMLInputElement).checked };\n        }\n        return undefined;\n      }\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"UL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"UL\")\n      ) {\n        const checkbox =\n          (element.querySelector(\"input[type=checkbox]\") as HTMLInputElement) ||\n          null;\n\n        if (checkbox === null) {\n          return undefined;\n        }\n\n        return { ...parseDefaultProps(element), checked: checkbox.checked };\n      }\n\n      return;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"checkListItem\"),\n    render(block, editor) {\n      const dom = document.createDocumentFragment();\n\n      const checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.checked = block.props.checked;\n      if (block.props.checked) {\n        checkbox.setAttribute(\"checked\", \"\");\n      }\n      checkbox.addEventListener(\"change\", () => {\n        editor.updateBlock(block, { props: { checked: !block.props.checked } });\n      });\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const paragraph = document.createElement(\"p\");\n\n      dom.appendChild(checkbox);\n      dom.appendChild(paragraph);\n\n      return {\n        dom,\n        contentDOM: paragraph,\n      };\n    },\n    toExternalHTML(block) {\n      const dom = document.createElement(\"li\");\n      const checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.checked = block.props.checked;\n      if (block.props.checked) {\n        checkbox.setAttribute(\"checked\", \"\");\n      }\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const paragraph = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, dom);\n\n      dom.appendChild(checkbox);\n      dom.appendChild(paragraph);\n\n      return {\n        dom,\n        contentDOM: paragraph,\n      };\n    },\n    runsBefore: [\"bulletListItem\"],\n  },\n  [\n    createExtension({\n      key: \"check-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"checkListItem\");\n        },\n        \"Mod-Shift-9\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"checkListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`\\\\[\\\\s*\\\\]\\\\s$`),\n          replace() {\n            return {\n              type: \"checkListItem\",\n              props: {\n                checked: false,\n              },\n              content: [],\n            };\n          },\n        },\n        {\n          find: new RegExp(`\\\\[[Xx]\\\\]\\\\s$`),\n          replace() {\n            return {\n              type: \"checkListItem\",\n              props: {\n                checked: true,\n              },\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import type { Node } from \"@tiptap/pm/model\";\nimport type { Transaction } from \"@tiptap/pm/state\";\nimport { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport { Decoration, DecorationSet } from \"@tiptap/pm/view\";\n\nimport { getBlockInfo } from \"../../../api/getBlockInfoFromPos.js\";\n\n// Loosely based on https://github.com/ueberdosis/tiptap/blob/7ac01ef0b816a535e903b5ca92492bff110a71ae/packages/extension-mathematics/src/MathematicsPlugin.ts (MIT)\n\ntype DecoSpec = {\n  index: number;\n  isFirst: boolean;\n  hasStart: boolean;\n  side: number;\n};\n\ntype Deco = Omit<Decoration, \"spec\"> & { spec: DecoSpec };\n\n/**\n * Calculate the index for a numbered list item based on its position and previous siblings\n */\nfunction calculateListItemIndex(\n  node: Node,\n  pos: number,\n  tr: Transaction,\n  map: Map<Node, number>,\n): { index: number; isFirst: boolean; hasStart: boolean } {\n  let index: number = node.firstChild!.attrs[\"start\"] || 1;\n  let isFirst = true;\n  const hasStart = !!node.firstChild!.attrs[\"start\"];\n\n  const blockInfo = getBlockInfo({\n    posBeforeNode: pos,\n    node,\n  });\n\n  if (!blockInfo.isBlockContainer) {\n    throw new Error(\"impossible\");\n  }\n\n  // Check if this block is the start of a new ordered list\n  const prevBlock = tr.doc.resolve(blockInfo.bnBlock.beforePos).nodeBefore;\n  const prevBlockIndex = prevBlock ? map.get(prevBlock) : undefined;\n\n  if (prevBlockIndex !== undefined) {\n    index = prevBlockIndex + 1;\n    isFirst = false;\n  } else if (prevBlock) {\n    // Because we only check the affected ranges, we may need to walk backwards to find the previous block's index\n    // We can't just rely on the map, because the map is reset every `apply` call\n    const prevBlockInfo = getBlockInfo({\n      posBeforeNode: blockInfo.bnBlock.beforePos - prevBlock.nodeSize,\n      node: prevBlock,\n    });\n\n    const isPrevBlockOrderedListItem =\n      prevBlockInfo.blockNoteType === \"numberedListItem\";\n    if (isPrevBlockOrderedListItem) {\n      // recurse to get the index of the previous block\n      const itemIndex = calculateListItemIndex(\n        prevBlock,\n        blockInfo.bnBlock.beforePos - prevBlock.nodeSize,\n        tr,\n        map,\n      );\n      index = itemIndex.index + 1;\n      isFirst = false;\n    }\n  }\n  // Note: we set the map late, so that when we recurse, we can rely on the map to get the previous block's index in one lookup\n  map.set(node, index);\n\n  return { index, isFirst, hasStart };\n}\n\n/**\n * Get the decorations for the current state based on the previous state,\n * and the transaction that was applied to get to the current state\n */\nfunction getDecorations(\n  tr: Transaction,\n  previousPluginState: { decorations: DecorationSet },\n) {\n  const map = new Map<Node, number>();\n\n  const nextDecorationSet = previousPluginState.decorations.map(\n    tr.mapping,\n    tr.doc,\n  );\n  const decorationsToAdd = [] as Deco[];\n\n  tr.doc.nodesBetween(0, tr.doc.nodeSize - 2, (node, pos) => {\n    if (\n      node.type.name === \"blockContainer\" &&\n      node.firstChild!.type.name === \"numberedListItem\"\n    ) {\n      const { index, isFirst, hasStart } = calculateListItemIndex(\n        node,\n        pos,\n        tr,\n        map,\n      );\n\n      // Check if decoration already exists with the same properties (for perf reasons)\n      const existingDecorations = nextDecorationSet.find(\n        pos,\n        pos + node.nodeSize,\n        (deco: DecoSpec) =>\n          deco.index === index &&\n          deco.isFirst === isFirst &&\n          deco.hasStart === hasStart,\n      );\n\n      if (existingDecorations.length === 0) {\n        const blockNode = tr.doc.nodeAt(pos + 1);\n        // Create a widget decoration to display the index\n        decorationsToAdd.push(\n          // move in by 1 to account for the block container\n          Decoration.node(pos + 1, pos + 1 + blockNode!.nodeSize, {\n            \"data-index\": index.toString(),\n          }),\n        );\n      }\n    }\n  });\n\n  // Remove any decorations that exist at the same position, they will be replaced by the new decorations\n  const decorationsToRemove = decorationsToAdd.flatMap((deco) =>\n    nextDecorationSet.find(deco.from, deco.to),\n  );\n\n  return {\n    decorations: nextDecorationSet\n      // Remove existing decorations that are going to be replaced\n      .remove(decorationsToRemove)\n      // Add any new decorations\n      .add(tr.doc, decorationsToAdd),\n  };\n}\n\n/**\n * This plugin adds decorations to numbered list items to display their index.\n */\nexport const NumberedListIndexingDecorationPlugin = () => {\n  return new Plugin<{ decorations: DecorationSet }>({\n    key: new PluginKey(\"numbered-list-indexing-decorations\"),\n\n    state: {\n      init(_config, state) {\n        // We create an empty transaction to get the decorations for the initial state based on the initial content\n        return getDecorations(state.tr, {\n          decorations: DecorationSet.empty,\n        });\n      },\n      apply(tr, previousPluginState) {\n        if (\n          !tr.docChanged &&\n          !tr.selectionSet &&\n          previousPluginState.decorations\n        ) {\n          // Just reuse the existing decorations, since nothing should have changed\n          return previousPluginState;\n        }\n        return getDecorations(tr, previousPluginState);\n      },\n    },\n\n    props: {\n      decorations(state) {\n        return this.getState(state)?.decorations ?? DecorationSet.empty;\n      },\n    },\n  });\n};\n","import { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { createExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\nimport { NumberedListIndexingDecorationPlugin } from \"./IndexingPlugin.js\";\n\nexport type NumberedListItemBlockConfig = ReturnType<\n  typeof createNumberedListItemBlockConfig\n>;\n\nexport const createNumberedListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"numberedListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n        start: { default: undefined, type: \"number\" } as const,\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createNumberedListItemBlockSpec = createBlockSpec(\n  createNumberedListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"OL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"OL\")\n      ) {\n        const startIndex = parseInt(parent.getAttribute(\"start\") || \"1\");\n\n        const defaultProps = parseDefaultProps(element);\n\n        if (element.previousElementSibling || startIndex === 1) {\n          return defaultProps;\n        }\n\n        return {\n          ...defaultProps,\n          start: startIndex,\n        };\n      }\n\n      return undefined;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"numberedListItem\"),\n    render() {\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const dom = document.createElement(\"p\");\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createExtension({\n      key: \"numbered-list-item-shortcuts\",\n      inputRules: [\n        {\n          find: new RegExp(`^(\\\\d+)\\\\.\\\\s$`),\n          replace({ match, editor }) {\n            const blockInfo = getBlockInfoFromSelection(\n              editor.prosemirrorState,\n            );\n\n            if (blockInfo.blockNoteType === \"heading\") {\n              return;\n            }\n            const start = parseInt(match[1]);\n            return {\n              type: \"numberedListItem\",\n              props: {\n                start: start !== 1 ? start : undefined,\n              },\n            };\n          },\n        },\n      ],\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"numberedListItem\");\n        },\n        \"Mod-Shift-7\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"numberedListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      prosemirrorPlugins: [NumberedListIndexingDecorationPlugin()],\n    }),\n  ],\n);\n","import { createExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n} from \"../../defaultProps.js\";\nimport { createToggleWrapper } from \"../../ToggleWrapper/createToggleWrapper.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\n\nexport type ToggleListItemBlockConfig = ReturnType<\n  typeof createToggleListItemBlockConfig\n>;\n\nexport const createToggleListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"toggleListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n      },\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createToggleListItemBlockSpec = createBlockSpec(\n  createToggleListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    render(block, editor) {\n      const paragraphEl = document.createElement(\"p\");\n      const toggleWrapper = createToggleWrapper(\n        block as any,\n        editor,\n        paragraphEl,\n      );\n      return { ...toggleWrapper, contentDOM: paragraphEl };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createExtension({\n      key: \"toggle-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"toggleListItem\");\n        },\n        \"Mod-Shift-6\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"toggleListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n    }),\n  ],\n);\n","import { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\n\nexport type ParagraphBlockConfig = ReturnType<\n  typeof createParagraphBlockConfig\n>;\n\nexport const createParagraphBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"paragraph\" as const,\n      propSchema: defaultProps,\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createParagraphBlockSpec = createBlockSpec(\n  createParagraphBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse: (e) => {\n      if (e.tagName !== \"P\") {\n        return undefined;\n      }\n\n      // Edge case for things like images directly inside paragraph.\n      if (!e.textContent?.trim()) {\n        return undefined;\n      }\n\n      return parseDefaultProps(e);\n    },\n    render: () => {\n      const dom = document.createElement(\"p\");\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML: (block) => {\n      const dom = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, dom);\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    runsBefore: [\"default\"],\n  },\n  [\n    createExtension({\n      key: \"paragraph-shortcuts\",\n      keyboardShortcuts: {\n        \"Mod-Alt-0\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"paragraph\",\n            props: {},\n          });\n          return true;\n        },\n      },\n    }),\n  ],\n);\n","import { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\n\nexport type QuoteBlockConfig = ReturnType<typeof createQuoteBlockConfig>;\n\nexport const createQuoteBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"quote\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        textColor: defaultProps.textColor,\n      },\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createQuoteBlockSpec = createBlockSpec(\n  createQuoteBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"BLOCKQUOTE\") {\n        const { backgroundColor, textColor } = parseDefaultProps(element);\n\n        return { backgroundColor, textColor };\n      }\n\n      return undefined;\n    },\n    render() {\n      const quote = document.createElement(\"blockquote\");\n\n      return {\n        dom: quote,\n        contentDOM: quote,\n      };\n    },\n    toExternalHTML(block) {\n      const quote = document.createElement(\"blockquote\");\n      addDefaultPropsExternalHTML(block.props, quote);\n\n      return {\n        dom: quote,\n        contentDOM: quote,\n      };\n    },\n  },\n  [\n    createExtension({\n      key: \"quote-block-shortcuts\",\n      keyboardShortcuts: {\n        \"Mod-Alt-q\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"quote\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`^>\\\\s$`),\n          replace() {\n            return {\n              type: \"quote\",\n              props: {},\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import { callOrReturn, Extension, getExtensionField } from \"@tiptap/core\";\nimport { columnResizing, goToNextCell, tableEditing } from \"prosemirror-tables\";\n\nexport const RESIZE_MIN_WIDTH = 35;\nexport const EMPTY_CELL_WIDTH = 120;\nexport const EMPTY_CELL_HEIGHT = 31;\n\nexport const TableExtension = Extension.create({\n  name: \"BlockNoteTableExtension\",\n\n  addProseMirrorPlugins: () => {\n    return [\n      columnResizing({\n        cellMinWidth: RESIZE_MIN_WIDTH,\n        defaultCellMinWidth: EMPTY_CELL_WIDTH,\n        // We set this to null as we implement our own node view in the table\n        // block content. This node view is the same as what's used by default,\n        // but is wrapped in a `blockContent` HTML element.\n        View: null,\n      }),\n      tableEditing(),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      // Makes enter create a new line within the cell.\n      Enter: () => {\n        if (\n          this.editor.state.selection.empty &&\n          this.editor.state.selection.$head.parent.type.name ===\n            \"tableParagraph\"\n        ) {\n          this.editor.commands.insertContent({ type: \"hardBreak\" });\n\n          return true;\n        }\n\n        return false;\n      },\n      // Ensures that backspace won't delete the table if the text cursor is at\n      // the start of a cell and the selection is empty.\n      Backspace: () => {\n        const selection = this.editor.state.selection;\n        const selectionIsEmpty = selection.empty;\n        const selectionIsAtStartOfNode = selection.$head.parentOffset === 0;\n        const selectionIsInTableParagraphNode =\n          selection.$head.node().type.name === \"tableParagraph\";\n\n        return (\n          selectionIsEmpty &&\n          selectionIsAtStartOfNode &&\n          selectionIsInTableParagraphNode\n        );\n      },\n      // Enables navigating cells using the tab key.\n      Tab: () => {\n        return this.editor.commands.command(({ state, dispatch, view }) =>\n          goToNextCell(1)(state, dispatch, view),\n        );\n      },\n      \"Shift-Tab\": () => {\n        return this.editor.commands.command(({ state, dispatch, view }) =>\n          goToNextCell(-1)(state, dispatch, view),\n        );\n      },\n    };\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    };\n\n    return {\n      tableRole: callOrReturn(\n        getExtensionField(extension, \"tableRole\", context),\n      ),\n    };\n  },\n});\n","import { Node, mergeAttributes } from \"@tiptap/core\";\nimport { DOMParser, Fragment, Node as PMNode, Schema } from \"prosemirror-model\";\nimport { CellSelection, TableView } from \"prosemirror-tables\";\nimport { NodeView } from \"prosemirror-view\";\n\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport {\n  BlockConfig,\n  createBlockSpecFromTiptapNode,\n  TableContent,\n} from \"../../schema/index.js\";\nimport { mergeCSSClasses } from \"../../util/browser.js\";\nimport { createDefaultBlockDOMOutputSpec } from \"../defaultBlockHelpers.js\";\nimport { defaultProps } from \"../defaultProps.js\";\nimport { EMPTY_CELL_WIDTH, TableExtension } from \"./TableExtension.js\";\n\nexport const tablePropSchema = {\n  textColor: defaultProps.textColor,\n};\n\nconst TiptapTableHeader = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableHeader\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  /**\n   * We allow table headers and cells to have multiple tableContent nodes because\n   * when merging cells, prosemirror-tables will concat the contents of the cells naively.\n   * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.\n   *\n   * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.\n   */\n  content: \"tableContent+\",\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: (element) => {\n          const colwidth = element.getAttribute(\"colwidth\");\n          const value = colwidth\n            ? colwidth.split(\",\").map((width) => parseInt(width, 10))\n            : null;\n\n          return value;\n        },\n      },\n    };\n  },\n\n  tableRole: \"header_cell\",\n\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"th\",\n        // As `th` elements can contain multiple paragraphs, we need to merge their contents\n        // into a single one so that ProseMirror can parse everything correctly.\n        getContent: (node, schema) =>\n          parseTableContent(node as HTMLElement, schema),\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"th\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\nconst TiptapTableCell = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableCell\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  content: \"tableContent+\",\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: (element) => {\n          const colwidth = element.getAttribute(\"colwidth\");\n          const value = colwidth\n            ? colwidth.split(\",\").map((width) => parseInt(width, 10))\n            : null;\n\n          return value;\n        },\n      },\n    };\n  },\n\n  tableRole: \"cell\",\n\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"td\",\n        // As `td` elements can contain multiple paragraphs, we need to merge their contents\n        // into a single one so that ProseMirror can parse everything correctly.\n        getContent: (node, schema) =>\n          parseTableContent(node as HTMLElement, schema),\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"td\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\nconst TiptapTableNode = Node.create({\n  name: \"table\",\n  content: \"tableRow+\",\n  group: \"blockContent\",\n  tableRole: \"table\",\n\n  marks: \"deletion insertion modification\",\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"table\",\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const domOutputSpec = createDefaultBlockDOMOutputSpec(\n      this.name,\n      \"table\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {},\n    );\n\n    // Need to manually add colgroup element\n    const colGroup = document.createElement(\"colgroup\");\n    for (const tableCell of node.children[0].children) {\n      const colWidths: null | (number | undefined)[] =\n        tableCell.attrs[\"colwidth\"];\n\n      if (colWidths) {\n        for (const colWidth of tableCell.attrs[\"colwidth\"]) {\n          const col = document.createElement(\"col\");\n          if (colWidth) {\n            col.style = `width: ${colWidth}px`;\n          }\n\n          colGroup.appendChild(col);\n        }\n      } else {\n        colGroup.appendChild(document.createElement(\"col\"));\n      }\n    }\n\n    domOutputSpec.dom.firstChild?.appendChild(colGroup);\n\n    return domOutputSpec;\n  },\n\n  // This node view is needed for the `columnResizing` plugin. By default, the\n  // plugin adds its own node view, which overrides how the node is rendered vs\n  // `renderHTML`. This means that the wrapping `blockContent` HTML element is\n  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its\n  // default node view. `BlockNoteTableView` extends it by wrapping it in a\n  // `blockContent` element, so the DOM structure is consistent with other block\n  // types.\n  addNodeView() {\n    return ({ node, HTMLAttributes }) => {\n      class BlockNoteTableView extends TableView {\n        constructor(\n          public node: PMNode,\n          public cellMinWidth: number,\n          public blockContentHTMLAttributes: Record<string, string>,\n        ) {\n          super(node, cellMinWidth);\n\n          const blockContent = document.createElement(\"div\");\n          blockContent.className = mergeCSSClasses(\n            \"bn-block-content\",\n            blockContentHTMLAttributes.class,\n          );\n          blockContent.setAttribute(\"data-content-type\", \"table\");\n          for (const [attribute, value] of Object.entries(\n            blockContentHTMLAttributes,\n          )) {\n            if (attribute !== \"class\") {\n              blockContent.setAttribute(attribute, value);\n            }\n          }\n\n          const tableWrapper = this.dom;\n\n          const tableWrapperInner = document.createElement(\"div\");\n          tableWrapperInner.className = \"tableWrapper-inner\";\n          tableWrapperInner.appendChild(tableWrapper.firstChild!);\n\n          tableWrapper.appendChild(tableWrapperInner);\n\n          blockContent.appendChild(tableWrapper);\n          const floatingContainer = document.createElement(\"div\");\n          floatingContainer.className = \"table-widgets-container\";\n          floatingContainer.style.position = \"relative\";\n          tableWrapper.appendChild(floatingContainer);\n\n          this.dom = blockContent;\n        }\n\n        ignoreMutation(record: MutationRecord): boolean {\n          return (\n            !(record.target as HTMLElement).closest(\".tableWrapper-inner\") ||\n            super.ignoreMutation(record)\n          );\n        }\n      }\n\n      return new BlockNoteTableView(node, EMPTY_CELL_WIDTH, {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      }) as NodeView; // needs cast, tiptap types (wrongly) doesn't support return tableview here\n    };\n  },\n});\n\nconst TiptapTableParagraph = Node.create({\n  name: \"tableParagraph\",\n  group: \"tableContent\",\n  content: \"inline*\",\n\n  parseHTML() {\n    return [\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\" || !element.textContent) {\n            return false;\n          }\n\n          // Only parse in internal HTML.\n          if (!element.closest(\"[data-content-type]\")) {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.tagName === \"TD\" || parent.tagName === \"TH\") {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"tableParagraph\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", HTMLAttributes, 0];\n  },\n});\n\n/**\n * This extension allows you to create table rows.\n * @see https://www.tiptap.dev/api/nodes/table-row\n */\nconst TiptapTableRow = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableRow\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  content: \"(tableCell | tableHeader)+\",\n\n  tableRole: \"row\",\n  marks: \"deletion insertion modification\",\n  parseHTML() {\n    return [{ tag: \"tr\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"tr\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\n/*\n * This will flatten a node's content to fit into a table cell's paragraph.\n */\nfunction parseTableContent(node: HTMLElement, schema: Schema) {\n  const parser = DOMParser.fromSchema(schema);\n\n  // This will parse the content of the table paragraph as though it were a blockGroup.\n  // Resulting in a structure like:\n  // <blockGroup>\n  //   <blockContainer>\n  //     <p>Hello</p>\n  //   </blockContainer>\n  //   <blockContainer>\n  //     <p>Hello</p>\n  //   </blockContainer>\n  // </blockGroup>\n  const parsedContent = parser.parse(node, {\n    topNode: schema.nodes.blockGroup.create(),\n  });\n  const extractedContent: PMNode[] = [];\n\n  // Try to extract any content within the blockContainer.\n  parsedContent.content.descendants((child) => {\n    // As long as the child is an inline node, we can append it to the fragment.\n    if (child.isInline) {\n      // And append it to the fragment\n      extractedContent.push(child);\n      return false;\n    }\n\n    return undefined;\n  });\n\n  return Fragment.fromArray(extractedContent);\n}\n\nexport type TableBlockConfig = BlockConfig<\n  \"table\",\n  {\n    textColor: {\n      default: \"default\";\n    };\n  },\n  \"table\"\n>;\n\nexport const createTableBlockSpec = () =>\n  createBlockSpecFromTiptapNode(\n    { node: TiptapTableNode, type: \"table\", content: \"table\" },\n    tablePropSchema,\n    [\n      createExtension({\n        key: \"table-extensions\",\n        tiptapExtensions: [\n          TableExtension,\n          TiptapTableParagraph,\n          TiptapTableHeader,\n          TiptapTableCell,\n          TiptapTableRow,\n        ],\n      }),\n      // Extension for keyboard shortcut which deletes the table if it's empty\n      // and all cells are selected. Uses a separate extension as it needs\n      // priority over keyboard handlers in the `TableExtension`'s\n      // `tableEditing` plugin.\n      createExtension({\n        key: \"table-keyboard-delete\",\n        keyboardShortcuts: {\n          Backspace: ({ editor }) => {\n            if (!(editor.prosemirrorState.selection instanceof CellSelection)) {\n              return false;\n            }\n\n            const block = editor.getTextCursorPosition().block;\n            const content = block.content as TableContent<any, any>;\n\n            let numCells = 0;\n            for (const row of content.rows) {\n              for (const cell of row.cells) {\n                // Returns `false` if any cell isn't empty.\n                if (\n                  (\"type\" in cell && cell.content.length > 0) ||\n                  (!(\"type\" in cell) && cell.length > 0)\n                ) {\n                  return false;\n                }\n\n                numCells++;\n              }\n            }\n\n            // Need to use ProseMirror API to check number of selected cells.\n            let selectionNumCells = 0;\n            editor.prosemirrorState.selection.forEachCell(() => {\n              selectionNumCells++;\n            });\n\n            if (selectionNumCells < numCells) {\n              return false;\n            }\n\n            editor.transact(() => {\n              const selectionBlock =\n                editor.getPrevBlock(block) || editor.getNextBlock(block);\n              if (selectionBlock) {\n                editor.setTextCursorPosition(block);\n              }\n\n              editor.removeBlocks([block]);\n            });\n\n            return true;\n          },\n        },\n      }),\n    ],\n  );\n\n// We need to declare this here because we aren't using the table extensions from tiptap, so the types are not automatically inferred.\ndeclare module \"@tiptap/core\" {\n  interface NodeConfig {\n    tableRole?: string;\n  }\n}\n","export const parseVideoElement = (videoElement: HTMLVideoElement) => {\n  const url = videoElement.src || undefined;\n  const previewWidth = videoElement.width || undefined;\n\n  return { url, previewWidth };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createResizableFileBlockWrapper } from \"../File/helpers/render/createResizableFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseVideoElement } from \"./parseVideoElement.js\";\n\nexport const FILE_VIDEO_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z\"></path></svg>';\n\nexport interface VideoOptions {\n  icon?: string;\n}\n\nexport type VideoBlockConfig = ReturnType<typeof createVideoBlockConfig>;\n\nexport const createVideoBlockConfig = createBlockConfig(\n  (_ctx: VideoOptions) => ({\n    type: \"video\" as const,\n    propSchema: {\n      textAlignment: defaultProps.textAlignment,\n      backgroundColor: defaultProps.backgroundColor,\n      name: { default: \"\" as const },\n      url: { default: \"\" as const },\n      caption: { default: \"\" as const },\n      showPreview: { default: true },\n      previewWidth: { default: undefined, type: \"number\" as const },\n    },\n    content: \"none\" as const,\n  }),\n);\n\nexport const videoParse = (_config: VideoOptions) => (element: HTMLElement) => {\n  if (element.tagName === \"VIDEO\") {\n    // Ignore if parent figure has already been parsed.\n    if (element.closest(\"figure\")) {\n      return undefined;\n    }\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseVideoElement(element as HTMLVideoElement),\n      backgroundColor,\n    };\n  }\n\n  if (element.tagName === \"FIGURE\") {\n    const parsedFigure = parseFigureElement(element, \"video\");\n    if (!parsedFigure) {\n      return undefined;\n    }\n\n    const { targetElement, caption } = parsedFigure;\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseVideoElement(targetElement as HTMLVideoElement),\n      backgroundColor,\n      caption,\n    };\n  }\n\n  return undefined;\n};\n\nexport const createVideoBlockSpec = createBlockSpec(\n  createVideoBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"video/*\"],\n    },\n    parse: videoParse(config),\n    render(block, editor) {\n      const icon = document.createElement(\"div\");\n      icon.innerHTML = config.icon ?? FILE_VIDEO_ICON_SVG;\n\n      const videoWrapper = document.createElement(\"div\");\n      videoWrapper.className = \"bn-visual-media-wrapper\";\n\n      const video = document.createElement(\"video\");\n      video.className = \"bn-visual-media\";\n      if (editor.resolveFileUrl) {\n        editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n          video.src = downloadUrl;\n        });\n      } else {\n        video.src = block.props.url;\n      }\n      video.controls = true;\n      video.contentEditable = \"false\";\n      video.draggable = false;\n      video.width = block.props.previewWidth;\n      videoWrapper.appendChild(video);\n\n      return createResizableFileBlockWrapper(\n        block,\n        editor,\n        { dom: videoWrapper },\n        videoWrapper,\n        icon.firstElementChild as HTMLElement,\n      );\n    },\n    toExternalHTML(block) {\n      if (!block.props.url) {\n        const div = document.createElement(\"p\");\n        div.textContent = \"Add video\";\n\n        return {\n          dom: div,\n        };\n      }\n\n      let video;\n      if (block.props.showPreview) {\n        video = document.createElement(\"video\");\n        video.src = block.props.url;\n        if (block.props.previewWidth) {\n          video.width = block.props.previewWidth;\n        }\n      } else {\n        video = document.createElement(\"a\");\n        video.href = block.props.url;\n        video.textContent = block.props.name || block.props.url;\n      }\n\n      if (block.props.caption) {\n        if (block.props.showPreview) {\n          return createFigureWithCaption(video, block.props.caption);\n        } else {\n          return createLinkWithCaption(video, block.props.caption);\n        }\n      }\n\n      return {\n        dom: video,\n      };\n    },\n    runsBefore: [\"file\"],\n  }),\n);\n","import { CellSelection } from \"prosemirror-tables\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockConfig, PropSchema, PropSpec } from \"../schema/index.js\";\nimport { Block } from \"./defaultBlocks.js\";\nimport { Selection } from \"prosemirror-state\";\n\nexport function editorHasBlockWithType<\n  BType extends string,\n  Props extends\n    | PropSchema\n    | Record<string, \"boolean\" | \"number\" | \"string\">\n    | undefined = undefined,\n>(\n  editor: BlockNoteEditor<any, any, any>,\n  blockType: BType,\n  props?: Props,\n): editor is BlockNoteEditor<\n  {\n    [BT in BType]: Props extends PropSchema\n      ? BlockConfig<BT, Props>\n      : Props extends Record<string, \"boolean\" | \"number\" | \"string\">\n        ? BlockConfig<\n            BT,\n            {\n              [PN in keyof Props]: {\n                default: undefined;\n                type: Props[PN];\n                values?: any[];\n              };\n            }\n          >\n        : BlockConfig<BT, PropSchema>;\n  },\n  any,\n  any\n> {\n  if (!(blockType in editor.schema.blockSpecs)) {\n    return false;\n  }\n\n  if (!props) {\n    return true;\n  }\n\n  for (const [propName, propSpec] of Object.entries(props)) {\n    if (!(propName in editor.schema.blockSpecs[blockType].config.propSchema)) {\n      return false;\n    }\n\n    if (typeof propSpec === \"string\") {\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default !== undefined &&\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default !== propSpec\n      ) {\n        return false;\n      }\n\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName].type !==\n          undefined &&\n        editor.schema.blockSpecs[blockType].config.propSchema[propName].type !==\n          propSpec\n      ) {\n        return false;\n      }\n    } else {\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default !== propSpec.default\n      ) {\n        return false;\n      }\n\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default === undefined &&\n        propSpec.default === undefined\n      ) {\n        if (\n          editor.schema.blockSpecs[blockType].config.propSchema[propName]\n            .type !== propSpec.type\n        ) {\n          return false;\n        }\n      }\n\n      if (\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .values !== typeof propSpec.values\n      ) {\n        return false;\n      }\n\n      if (\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .values === \"object\" &&\n        typeof propSpec.values === \"object\"\n      ) {\n        for (const value of propSpec.values) {\n          if (\n            !editor.schema.blockSpecs[blockType].config.propSchema[\n              propName\n            ].values.includes(value)\n          ) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function blockHasType<\n  BType extends string,\n  Props extends\n    | PropSchema\n    | Record<string, \"boolean\" | \"number\" | \"string\">\n    | undefined = undefined,\n>(\n  block: Block<any, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  blockType: BType,\n  props?: Props,\n): block is Block<\n  {\n    [BT in BType]: Props extends PropSchema\n      ? BlockConfig<BT, Props>\n      : Props extends Record<string, \"boolean\" | \"number\" | \"string\">\n        ? BlockConfig<\n            BT,\n            {\n              [PN in keyof Props]: PropSpec<\n                Props[PN] extends \"boolean\"\n                  ? boolean\n                  : Props[PN] extends \"number\"\n                    ? number\n                    : Props[PN] extends \"string\"\n                      ? string\n                      : never\n              >;\n            }\n          >\n        : BlockConfig<BT, PropSchema>;\n  },\n  any,\n  any\n> {\n  return (\n    editorHasBlockWithType(editor, blockType, props) && block.type === blockType\n  );\n}\n\nexport function isTableCellSelection(\n  selection: Selection,\n): selection is CellSelection {\n  return selection instanceof CellSelection;\n}\n","import { Mapping } from \"prosemirror-transform\";\nimport {\n  absolutePositionToRelativePosition,\n  relativePositionToAbsolutePosition,\n  ySyncPluginKey,\n} from \"y-prosemirror\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport * as Y from \"yjs\";\nimport type { ProsemirrorBinding } from \"y-prosemirror\";\n\n/**\n * This is used to track a mapping for each editor. The mapping stores the mappings for each transaction since the first transaction that was tracked.\n */\nconst editorToMapping = new Map<BlockNoteEditor<any, any, any>, Mapping>();\n\n/**\n * This initializes a single mapping for an editor instance.\n */\nfunction getMapping(editor: BlockNoteEditor<any, any, any>) {\n  if (editorToMapping.has(editor)) {\n    // Mapping already initialized, so we don't need to do anything\n    return editorToMapping.get(editor)!;\n  }\n  const mapping = new Mapping();\n  editor._tiptapEditor.on(\"transaction\", ({ transaction }) => {\n    mapping.appendMapping(transaction.mapping);\n  });\n  editor._tiptapEditor.on(\"destroy\", () => {\n    // Cleanup the mapping when the editor is destroyed\n    editorToMapping.delete(editor);\n  });\n\n  // There only is one mapping per editor, so we can just set it\n  editorToMapping.set(editor, mapping);\n\n  return mapping;\n}\n\n/**\n * This is used to keep track of positions of elements in the editor.\n * It is needed because y-prosemirror's sync plugin can disrupt normal prosemirror position mapping.\n *\n * It is specifically made to be able to be used whether the editor is being used in a collaboratively, or single user, providing the same API.\n *\n * @param editor The editor to track the position of.\n * @param position The position to track.\n * @param side The side of the position to track. \"left\" is the default. \"right\" would move with the change if the change is in the right direction.\n * @returns A function that returns the position of the element.\n */\nexport function trackPosition(\n  /**\n   * The editor to track the position of.\n   */\n  editor: BlockNoteEditor<any, any, any>,\n  /**\n   * The position to track.\n   */\n  position: number,\n  /**\n   * This is the side of the position to track. \"left\" is the default. \"right\" would move with the change if the change is in the right direction.\n   */\n  side: \"left\" | \"right\" = \"left\",\n): () => number {\n  const ySyncPluginState = ySyncPluginKey.getState(editor.prosemirrorState) as {\n    doc: Y.Doc;\n    binding: ProsemirrorBinding;\n  };\n\n  if (!ySyncPluginState) {\n    // No y-prosemirror sync plugin, so we need to track the mapping manually\n    // This will initialize the mapping for this editor, if needed\n    const mapping = getMapping(editor);\n\n    // This is the start point of tracking the mapping\n    const trackedMapLength = mapping.maps.length;\n\n    return () => {\n      const pos = mapping\n        // Only read the history of the mapping that we care about\n        .slice(trackedMapLength)\n        .map(position, side === \"left\" ? -1 : 1);\n\n      return pos;\n    };\n  }\n\n  const relativePosition = absolutePositionToRelativePosition(\n    // Track the position after the position if we are on the right side\n    position + (side === \"right\" ? 1 : -1),\n    ySyncPluginState.binding.type,\n    ySyncPluginState.binding.mapping,\n  );\n\n  return () => {\n    const curYSyncPluginState = ySyncPluginKey.getState(\n      editor.prosemirrorState,\n    ) as typeof ySyncPluginState;\n    const pos = relativePositionToAbsolutePosition(\n      curYSyncPluginState.doc,\n      curYSyncPluginState.binding.type,\n      relativePosition,\n      curYSyncPluginState.binding.mapping,\n    );\n\n    // This can happen if the element is garbage collected\n    if (pos === null) {\n      throw new Error(\"Position not found, cannot track positions\");\n    }\n\n    return pos + (side === \"right\" ? -1 : 1);\n  };\n}\n","import { findParentNode } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\n\nimport { trackPosition } from \"../../api/positionMapping.js\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\n\nconst findBlock = findParentNode((node) => node.type.name === \"blockContainer\");\n\nexport type SuggestionMenuState = UiElementPosition & {\n  query: string;\n  ignoreQueryLength?: boolean;\n};\n\nclass SuggestionMenuView {\n  public state?: SuggestionMenuState;\n  public emitUpdate: (triggerCharacter: string) => void;\n  private rootEl?: Document | ShadowRoot;\n  pluginState: SuggestionPluginState;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<any, any, any>,\n    emitUpdate: (menuName: string, state: SuggestionMenuState) => void,\n    view: EditorView,\n  ) {\n    this.pluginState = undefined;\n\n    this.emitUpdate = (menuName: string) => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      }\n\n      emitUpdate(menuName, {\n        ...this.state,\n        ignoreQueryLength: this.pluginState?.ignoreQueryLength,\n      });\n    };\n\n    this.rootEl = view.root;\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    this.rootEl?.addEventListener(\"scroll\", this.handleScroll, true);\n  }\n\n  handleScroll = () => {\n    if (this.state?.show) {\n      const decorationNode = this.rootEl?.querySelector(\n        `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`,\n      );\n      if (!decorationNode) {\n        return;\n      }\n      this.state.referencePos = decorationNode\n        .getBoundingClientRect()\n        .toJSON() as DOMRect;\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const prev: SuggestionPluginState =\n      suggestionMenuPluginKey.getState(prevState);\n    const next: SuggestionPluginState = suggestionMenuPluginKey.getState(\n      view.state,\n    );\n\n    // See how the state changed\n    const started = prev === undefined && next !== undefined;\n    const stopped = prev !== undefined && next === undefined;\n    const changed = prev !== undefined && next !== undefined;\n\n    // Cancel when suggestion isn't active\n    if (!started && !changed && !stopped) {\n      return;\n    }\n\n    this.pluginState = stopped ? prev : next;\n\n    if (stopped || !this.editor.isEditable) {\n      if (this.state) {\n        this.state.show = false;\n      }\n      this.emitUpdate(this.pluginState!.triggerCharacter);\n\n      return;\n    }\n\n    const decorationNode = this.rootEl?.querySelector(\n      `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`,\n    );\n\n    if (this.editor.isEditable && decorationNode) {\n      this.state = {\n        show: true,\n        referencePos: decorationNode\n          .getBoundingClientRect()\n          .toJSON() as DOMRect,\n        query: this.pluginState!.query,\n      };\n\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  }\n\n  destroy() {\n    this.rootEl?.removeEventListener(\"scroll\", this.handleScroll, true);\n  }\n\n  closeMenu = () => {\n    this.editor.transact((tr) => tr.setMeta(suggestionMenuPluginKey, null));\n  };\n\n  clearQuery = () => {\n    if (this.pluginState === undefined) {\n      return;\n    }\n\n    this.editor._tiptapEditor\n      .chain()\n      .focus()\n      // TODO need to make an API for this\n      .deleteRange({\n        from:\n          this.pluginState.queryStartPos() -\n          (this.pluginState.deleteTriggerCharacter\n            ? this.pluginState.triggerCharacter!.length\n            : 0),\n        to: this.editor.transact((tr) => tr.selection.from),\n      })\n      .run();\n  };\n}\n\ntype SuggestionPluginState =\n  | {\n      triggerCharacter: string;\n      deleteTriggerCharacter: boolean;\n      queryStartPos: () => number;\n      query: string;\n      decorationId: string;\n      ignoreQueryLength?: boolean;\n    }\n  | undefined;\n\nconst suggestionMenuPluginKey = new PluginKey(\"SuggestionMenuPlugin\");\n\n/**\n * A ProseMirror plugin for suggestions, designed to make '/'-commands possible as well as mentions.\n *\n * This is basically a simplified version of TipTap's [Suggestions](https://github.com/ueberdosis/tiptap/tree/db92a9b313c5993b723c85cd30256f1d4a0b65e1/packages/suggestion) plugin.\n *\n * This version is adapted from the aforementioned version in the following ways:\n * - This version supports generic items instead of only strings (to allow for more advanced filtering for example)\n * - This version hides some unnecessary complexity from the user of the plugin.\n * - This version handles key events differently\n */\nexport const SuggestionMenu = createExtension(({ editor }) => {\n  const triggerCharacters: string[] = [];\n  let view: SuggestionMenuView | undefined = undefined;\n  const store = createStore<\n    (SuggestionMenuState & { triggerCharacter: string }) | undefined\n  >(undefined);\n  return {\n    key: \"suggestionMenu\",\n    store,\n    addTriggerCharacter: (triggerCharacter: string) => {\n      triggerCharacters.push(triggerCharacter);\n    },\n    removeTriggerCharacter: (triggerCharacter: string) => {\n      triggerCharacters.splice(triggerCharacters.indexOf(triggerCharacter), 1);\n    },\n    closeMenu: () => {\n      view?.closeMenu();\n    },\n    clearQuery: () => {\n      view?.clearQuery();\n    },\n    shown: () => {\n      return view?.state?.show || false;\n    },\n    openSuggestionMenu: (\n      triggerCharacter: string,\n      pluginState?: {\n        deleteTriggerCharacter?: boolean;\n        ignoreQueryLength?: boolean;\n      },\n    ) => {\n      if (editor.headless) {\n        return;\n      }\n\n      editor.focus();\n\n      editor.transact((tr) => {\n        if (pluginState?.deleteTriggerCharacter) {\n          tr.insertText(triggerCharacter);\n        }\n        tr.scrollIntoView().setMeta(suggestionMenuPluginKey, {\n          triggerCharacter: triggerCharacter,\n          deleteTriggerCharacter: pluginState?.deleteTriggerCharacter || false,\n          ignoreQueryLength: pluginState?.ignoreQueryLength || false,\n        });\n      });\n    },\n    // TODO this whole plugin needs to be refactored (but I've done the minimal)\n    prosemirrorPlugins: [\n      new Plugin({\n        key: suggestionMenuPluginKey,\n\n        view: (v) => {\n          view = new SuggestionMenuView(\n            editor,\n            (triggerCharacter, state) => {\n              store.setState({ ...state, triggerCharacter });\n            },\n            v,\n          );\n          return view;\n        },\n\n        state: {\n          // Initialize the plugin's internal state.\n          init(): SuggestionPluginState {\n            return undefined;\n          },\n\n          // Apply changes to the plugin state from an editor transaction.\n          apply: (\n            transaction,\n            prev,\n            _oldState,\n            newState,\n          ): SuggestionPluginState => {\n            // Ignore transactions in code blocks.\n            if (transaction.selection.$from.parent.type.spec.code) {\n              return prev;\n            }\n\n            // Either contains the trigger character if the menu should be shown,\n            // or null if it should be hidden.\n            const suggestionPluginTransactionMeta: {\n              triggerCharacter: string;\n              deleteTriggerCharacter?: boolean;\n              ignoreQueryLength?: boolean;\n            } | null = transaction.getMeta(suggestionMenuPluginKey);\n\n            if (\n              typeof suggestionPluginTransactionMeta === \"object\" &&\n              suggestionPluginTransactionMeta !== null\n            ) {\n              if (prev) {\n                // Close the previous menu if it exists\n                view?.closeMenu();\n              }\n              const trackedPosition = trackPosition(\n                editor,\n                newState.selection.from -\n                  // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.\n                  suggestionPluginTransactionMeta.triggerCharacter.length,\n              );\n              return {\n                triggerCharacter:\n                  suggestionPluginTransactionMeta.triggerCharacter,\n                deleteTriggerCharacter:\n                  suggestionPluginTransactionMeta.deleteTriggerCharacter !==\n                  false,\n                // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller\n                queryStartPos: () =>\n                  trackedPosition() +\n                  suggestionPluginTransactionMeta.triggerCharacter.length,\n                query: \"\",\n                decorationId: `id_${Math.floor(Math.random() * 0xffffffff)}`,\n                ignoreQueryLength:\n                  suggestionPluginTransactionMeta?.ignoreQueryLength,\n              };\n            }\n\n            // Checks if the menu is hidden, in which case it doesn't need to be hidden or updated.\n            if (prev === undefined) {\n              return prev;\n            }\n\n            // Checks if the menu should be hidden.\n            if (\n              // Highlighting text should hide the menu.\n              newState.selection.from !== newState.selection.to ||\n              // Transactions with plugin metadata should hide the menu.\n              suggestionPluginTransactionMeta === null ||\n              // Certain mouse events should hide the menu.\n              // TODO: Change to global mousedown listener.\n              transaction.getMeta(\"focus\") ||\n              transaction.getMeta(\"blur\") ||\n              transaction.getMeta(\"pointer\") ||\n              // Moving the caret before the character which triggered the menu should hide it.\n              (prev.triggerCharacter !== undefined &&\n                newState.selection.from < prev.queryStartPos()) ||\n              // Moving the caret to a new block should hide the menu.\n              !newState.selection.$from.sameParent(\n                newState.doc.resolve(prev.queryStartPos()),\n              )\n            ) {\n              return undefined;\n            }\n\n            const next = { ...prev };\n\n            // Updates the current query.\n            next.query = newState.doc.textBetween(\n              prev.queryStartPos(),\n              newState.selection.from,\n            );\n\n            return next;\n          },\n        },\n\n        props: {\n          handleTextInput(view, from, to, text) {\n            // only on insert\n            if (from === to) {\n              const doc = view.state.doc;\n              for (const str of triggerCharacters) {\n                const snippet =\n                  str.length > 1\n                    ? doc.textBetween(from - str.length, from) + text\n                    : text;\n\n                if (str === snippet) {\n                  view.dispatch(view.state.tr.insertText(text));\n                  view.dispatch(\n                    view.state.tr\n                      .setMeta(suggestionMenuPluginKey, {\n                        triggerCharacter: snippet,\n                      })\n                      .scrollIntoView(),\n                  );\n                  return true;\n                }\n              }\n            }\n            return false;\n          },\n\n          // Setup decorator on the currently active suggestion.\n          decorations(state) {\n            const suggestionPluginState: SuggestionPluginState = (\n              this as Plugin\n            ).getState(state);\n\n            if (suggestionPluginState === undefined) {\n              return null;\n            }\n\n            // If the menu was opened programmatically by another extension, it may not use a trigger character. In this\n            // case, the decoration is set on the whole block instead, as the decoration range would otherwise be empty.\n            if (!suggestionPluginState.deleteTriggerCharacter) {\n              const blockNode = findBlock(state.selection);\n              if (blockNode) {\n                return DecorationSet.create(state.doc, [\n                  Decoration.node(\n                    blockNode.pos,\n                    blockNode.pos + blockNode.node.nodeSize,\n                    {\n                      nodeName: \"span\",\n                      class: \"bn-suggestion-decorator\",\n                      \"data-decoration-id\": suggestionPluginState.decorationId,\n                    },\n                  ),\n                ]);\n              }\n            }\n            // Creates an inline decoration around the trigger character.\n            return DecorationSet.create(state.doc, [\n              Decoration.inline(\n                suggestionPluginState.queryStartPos() -\n                  suggestionPluginState.triggerCharacter!.length,\n                suggestionPluginState.queryStartPos(),\n                {\n                  nodeName: \"span\",\n                  class: \"bn-suggestion-decorator\",\n                  \"data-decoration-id\": suggestionPluginState.decorationId,\n                },\n              ),\n            ]);\n          },\n        },\n      }),\n    ],\n  } as const;\n});\n","import { Block, PartialBlock } from \"../../blocks/defaultBlocks.js\";\nimport { editorHasBlockWithType } from \"../../blocks/defaultBlockTypeGuards.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n  isStyledTextInlineContent,\n} from \"../../schema/index.js\";\nimport { formatKeyboardShortcut } from \"../../util/browser.js\";\nimport { FilePanelExtension } from \"../FilePanel/FilePanel.js\";\nimport { DefaultSuggestionItem } from \"./DefaultSuggestionItem.js\";\nimport { SuggestionMenu } from \"./SuggestionMenu.js\";\n\n// Sets the editor's text cursor position to the next content editable block,\n// so either a block with inline content or a table. The last block is always a\n// paragraph, so this function won't try to set the cursor position past the\n// last block.\nfunction setSelectionToNextContentEditableBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  let block: Block<BSchema, I, S> | undefined =\n    editor.getTextCursorPosition().block;\n  let contentType = editor.schema.blockSchema[block.type].content;\n\n  while (contentType === \"none\") {\n    block = editor.getTextCursorPosition().nextBlock;\n    if (block === undefined) {\n      return;\n    }\n    contentType = editor.schema.blockSchema[block.type].content as\n      | \"inline\"\n      | \"table\"\n      | \"none\";\n    editor.setTextCursorPosition(block, \"end\");\n  }\n}\n\n// Checks if the current block is empty or only contains a slash, and if so,\n// updates the current block instead of inserting a new one below. If the new\n// block doesn't contain editable content, the cursor is moved to the next block\n// that does.\nexport function insertOrUpdateBlockForSlashMenu<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n): Block<BSchema, I, S> {\n  const currentBlock = editor.getTextCursorPosition().block;\n\n  if (currentBlock.content === undefined) {\n    throw new Error(\"Slash Menu open in a block that doesn't contain content.\");\n  }\n\n  let newBlock: Block<BSchema, I, S>;\n\n  if (\n    Array.isArray(currentBlock.content) &&\n    ((currentBlock.content.length === 1 &&\n      isStyledTextInlineContent(currentBlock.content[0]) &&\n      currentBlock.content[0].type === \"text\" &&\n      currentBlock.content[0].text === \"/\") ||\n      currentBlock.content.length === 0)\n  ) {\n    newBlock = editor.updateBlock(currentBlock, block);\n    // We make sure to reset the cursor position to the new block as calling\n    // `updateBlock` may move it out. This generally happens when the content\n    // changes, or the update makes the block multi-column.\n    editor.setTextCursorPosition(newBlock);\n  } else {\n    newBlock = editor.insertBlocks([block], currentBlock, \"after\")[0];\n    editor.setTextCursorPosition(editor.getTextCursorPosition().nextBlock!);\n  }\n\n  setSelectionToNextContentEditableBlock(editor);\n\n  return newBlock;\n}\n\nexport function getDefaultSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: DefaultSuggestionItem[] = [];\n\n  if (editorHasBlockWithType(editor, \"heading\", { level: \"number\" })) {\n    items.push(\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 1 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-1\"),\n        key: \"heading\",\n        ...editor.dictionary.slash_menu.heading,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 2 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-2\"),\n        key: \"heading_2\",\n        ...editor.dictionary.slash_menu.heading_2,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 3 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-3\"),\n        key: \"heading_3\",\n        ...editor.dictionary.slash_menu.heading_3,\n      },\n    );\n  }\n\n  if (editorHasBlockWithType(editor, \"quote\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"quote\",\n        });\n      },\n      key: \"quote\",\n      ...editor.dictionary.slash_menu.quote,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"toggleListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"toggleListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-6\"),\n      key: \"toggle_list\",\n      ...editor.dictionary.slash_menu.toggle_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"numberedListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"numberedListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-7\"),\n      key: \"numbered_list\",\n      ...editor.dictionary.slash_menu.numbered_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"bulletListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"bulletListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-8\"),\n      key: \"bullet_list\",\n      ...editor.dictionary.slash_menu.bullet_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"checkListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"checkListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-9\"),\n      key: \"check_list\",\n      ...editor.dictionary.slash_menu.check_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"paragraph\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"paragraph\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Alt-0\"),\n      key: \"paragraph\",\n      ...editor.dictionary.slash_menu.paragraph,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"codeBlock\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"codeBlock\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Alt-c\"),\n      key: \"code_block\",\n      ...editor.dictionary.slash_menu.code_block,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"divider\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, { type: \"divider\" });\n      },\n      key: \"divider\",\n      ...editor.dictionary.slash_menu.divider,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"table\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"table\",\n          content: {\n            type: \"tableContent\",\n            rows: [\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n            ],\n          } as any,\n        });\n      },\n      badge: undefined,\n      key: \"table\",\n      ...editor.dictionary.slash_menu.table,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"image\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"image\",\n        });\n\n        // Immediately open the file toolbar\n        editor.getExtension(FilePanelExtension)?.showMenu(insertedBlock.id);\n      },\n      key: \"image\",\n      ...editor.dictionary.slash_menu.image,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"video\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"video\",\n        });\n\n        // Immediately open the file toolbar\n        editor.getExtension(FilePanelExtension)?.showMenu(insertedBlock.id);\n      },\n      key: \"video\",\n      ...editor.dictionary.slash_menu.video,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"audio\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"audio\",\n        });\n\n        // Immediately open the file toolbar\n        editor.getExtension(FilePanelExtension)?.showMenu(insertedBlock.id);\n      },\n      key: \"audio\",\n      ...editor.dictionary.slash_menu.audio,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"file\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"file\",\n        });\n\n        // Immediately open the file toolbar\n        editor.getExtension(FilePanelExtension)?.showMenu(insertedBlock.id);\n      },\n      key: \"file\",\n      ...editor.dictionary.slash_menu.file,\n    });\n  }\n\n  if (\n    editorHasBlockWithType(editor, \"heading\", {\n      level: \"number\",\n      isToggleable: \"boolean\",\n    })\n  ) {\n    items.push(\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 1, isToggleable: true },\n          });\n        },\n        key: \"toggle_heading\",\n        ...editor.dictionary.slash_menu.toggle_heading,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 2, isToggleable: true },\n          });\n        },\n\n        key: \"toggle_heading_2\",\n        ...editor.dictionary.slash_menu.toggle_heading_2,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlockForSlashMenu(editor, {\n            type: \"heading\",\n            props: { level: 3, isToggleable: true },\n          });\n        },\n        key: \"toggle_heading_3\",\n        ...editor.dictionary.slash_menu.toggle_heading_3,\n      },\n    );\n  }\n\n  if (editorHasBlockWithType(editor, \"heading\", { level: \"number\" })) {\n    (editor.schema.blockSchema.heading.propSchema.level.values || [])\n      .filter((level): level is 4 | 5 | 6 => level > 3)\n      .forEach((level) => {\n        items.push({\n          onItemClick: () => {\n            insertOrUpdateBlockForSlashMenu(editor, {\n              type: \"heading\",\n              props: { level: level },\n            });\n          },\n          key: `heading_${level}`,\n          ...editor.dictionary.slash_menu[`heading_${level}`],\n        });\n      });\n  }\n\n  items.push({\n    onItemClick: () => {\n      editor.getExtension(SuggestionMenu)?.openSuggestionMenu(\":\", {\n        deleteTriggerCharacter: true,\n        ignoreQueryLength: true,\n      });\n    },\n    key: \"emoji\",\n    ...editor.dictionary.slash_menu.emoji,\n  });\n\n  return items;\n}\n\nexport function filterSuggestionItems<\n  T extends { title: string; aliases?: readonly string[] },\n>(items: T[], query: string) {\n  return items.filter(\n    ({ title, aliases }) =>\n      title.toLowerCase().includes(query.toLowerCase()) ||\n      (aliases &&\n        aliases.filter((alias) =>\n          alias.toLowerCase().includes(query.toLowerCase()),\n        ).length !== 0),\n  );\n}\n","import Bold from \"@tiptap/extension-bold\";\nimport Code from \"@tiptap/extension-code\";\nimport Italic from \"@tiptap/extension-italic\";\nimport Strike from \"@tiptap/extension-strike\";\nimport Underline from \"@tiptap/extension-underline\";\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  createStyleSpec,\n  createStyleSpecFromTipTapMark,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"../schema/index.js\";\nimport {\n  createAudioBlockSpec,\n  createBulletListItemBlockSpec,\n  createCheckListItemBlockSpec,\n  createCodeBlockSpec,\n  createDividerBlockSpec,\n  createFileBlockSpec,\n  createHeadingBlockSpec,\n  createImageBlockSpec,\n  createNumberedListItemBlockSpec,\n  createParagraphBlockSpec,\n  createQuoteBlockSpec,\n  createToggleListItemBlockSpec,\n  createVideoBlockSpec,\n  defaultProps,\n} from \"./index.js\";\nimport { createTableBlockSpec } from \"./Table/block.js\";\n\nexport const defaultBlockSpecs = {\n  audio: createAudioBlockSpec(),\n  bulletListItem: createBulletListItemBlockSpec(),\n  checkListItem: createCheckListItemBlockSpec(),\n  codeBlock: createCodeBlockSpec(),\n  divider: createDividerBlockSpec(),\n  file: createFileBlockSpec(),\n  heading: createHeadingBlockSpec(),\n  image: createImageBlockSpec(),\n  numberedListItem: createNumberedListItemBlockSpec(),\n  paragraph: createParagraphBlockSpec(),\n  quote: createQuoteBlockSpec(),\n  table: createTableBlockSpec(),\n  toggleListItem: createToggleListItemBlockSpec(),\n  video: createVideoBlockSpec(),\n} as const;\n\n// underscore is used that in case a user overrides DefaultBlockSchema,\n// they can still access the original default block schema\nexport type _DefaultBlockSchema = {\n  [K in keyof typeof defaultBlockSpecs]: (typeof defaultBlockSpecs)[K][\"config\"];\n};\nexport type DefaultBlockSchema = _DefaultBlockSchema;\n\nconst TextColor = createStyleSpec(\n  {\n    type: \"textColor\",\n    propSchema: \"string\",\n  },\n  {\n    render: () => {\n      const span = document.createElement(\"span\");\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    toExternalHTML: (value) => {\n      const span = document.createElement(\"span\");\n      if (value !== defaultProps.textColor.default) {\n        span.style.color =\n          value in COLORS_DEFAULT ? COLORS_DEFAULT[value].text : value;\n      }\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    parse: (element) => {\n      if (element.tagName === \"SPAN\" && element.style.color) {\n        return element.style.color;\n      }\n\n      return undefined;\n    },\n  },\n);\n\nconst BackgroundColor = createStyleSpec(\n  {\n    type: \"backgroundColor\",\n    propSchema: \"string\",\n  },\n  {\n    render: () => {\n      const span = document.createElement(\"span\");\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    toExternalHTML: (value) => {\n      const span = document.createElement(\"span\");\n      if (value !== defaultProps.backgroundColor.default) {\n        span.style.backgroundColor =\n          value in COLORS_DEFAULT ? COLORS_DEFAULT[value].background : value;\n      }\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    parse: (element) => {\n      if (element.tagName === \"SPAN\" && element.style.backgroundColor) {\n        return element.style.backgroundColor;\n      }\n\n      return undefined;\n    },\n  },\n);\n\nexport const defaultStyleSpecs = {\n  bold: createStyleSpecFromTipTapMark(Bold, \"boolean\"),\n  italic: createStyleSpecFromTipTapMark(Italic, \"boolean\"),\n  underline: createStyleSpecFromTipTapMark(Underline, \"boolean\"),\n  strike: createStyleSpecFromTipTapMark(Strike, \"boolean\"),\n  code: createStyleSpecFromTipTapMark(Code, \"boolean\"),\n  textColor: TextColor,\n  backgroundColor: BackgroundColor,\n} satisfies StyleSpecs;\n\nexport const defaultStyleSchema = getStyleSchemaFromSpecs(defaultStyleSpecs);\n\n// underscore is used that in case a user overrides DefaultStyleSchema,\n// they can still access the original default style schema\nexport type _DefaultStyleSchema = typeof defaultStyleSchema;\nexport type DefaultStyleSchema = _DefaultStyleSchema;\n\nexport const defaultInlineContentSpecs = {\n  text: { config: \"text\", implementation: {} as any },\n  link: { config: \"link\", implementation: {} as any },\n} satisfies InlineContentSpecs;\n\nexport const defaultInlineContentSchema = getInlineContentSchemaFromSpecs(\n  defaultInlineContentSpecs,\n);\n\n// underscore is used that in case a user overrides DefaultInlineContentSchema,\n// they can still access the original default inline content schema\nexport type _DefaultInlineContentSchema = typeof defaultInlineContentSchema;\nexport type DefaultInlineContentSchema = _DefaultInlineContentSchema;\n\nexport type PartialBlock<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema,\n> = PartialBlockNoDefaults<BSchema, I, S>;\n\nexport type Block<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema,\n> = BlockNoDefaults<BSchema, I, S>;\n"],"names":["isAppleOS","formatKeyboardShortcut","shortcut","ctrlText","mergeCSSClasses","classes","c","isSafari","createDefaultBlockDOMOutputSpec","blockName","htmlTag","blockContentHTMLAttributes","inlineContentHTMLAttributes","blockContent","attribute","value","inlineContent","defaultBlockToHTML","block","editor","node","blockToNode","toDOM","renderSpec","mergeParagraphs","element","separator","paragraphs","firstParagraph","i","paragraph","camelToDataKebab","str","filenameFromURL","url","parts","isVideoUrl","videoExtensions","ext","_a","propsToAttributes","propSchema","tiptapAttributes","name","spec","asNumber","attributes","getBlockFromPos","getPos","tipTapEditor","type","pos","blockIdentifier","wrapInBlockStructure","blockType","blockProps","isFileBlock","domAttributes","attr","prop","defaultValue","createBlockSpecFromTiptapNode","config","extensions","applyNonSelectableBlockFix","nodeView","event","getParseRules","implementation","rules","props","schema","clone","DOMParser","Fragment","addNodeAndExtensionsToSpec","blockConfig","blockImplementation","priority","Node","_b","_c","_d","HTMLAttributes","div","blockContentDOMAttributes","createBlockConfig","callback","createBlockSpec","blockConfigOrCreator","blockImplementationOrCreator","extensionsOrCreator","options","output","addInlineContentAttributes","inlineContentType","inlineContentProps","addInlineContentKeyboardShortcuts","resolvedPos","createInternalInlineContentSpec","createInlineContentSpecFromTipTapNode","getInlineContentSchemaFromSpecs","specs","key","stylePropsToAttributes","addStyleAttributes","styleType","styleValue","createInternalStyleSpec","createStyleSpecFromTipTapMark","mark","markInstance","DOMSerializer","getStyleSchemaFromSpecs","getStyleParseRules","customParseFunction","htmlElement","stringValue","createStyleSpec","styleConfig","styleImplementation","Mark","renderResult","getNodeById","id","doc","targetNode","posBeforeNode","isNodeBlock","updateBlockCommand","posBeforeBlock","tr","dispatch","updateBlockTr","replaceFromPos","replaceToPos","blockInfo","getBlockInfoFromResolvedPos","cellAnchor","captureCellAnchor","pmSchema","getPmSchema","oldNodeType","newNodeType","newBnBlockNodeType","replaceFromOffset","replaceToOffset","updateChildren","updateBlockContentNode","existingBlock","nodeToBlock","restoreCellAnchor","content","inlineContentToNodes","tableContentToNodes","UnreachableCaseError","start","end","contentDepth","startDepth","endDepth","Slice","childNodes","child","ReplaceStep","updateBlock","blockToUpdate","update","posInfo","blockContainerNode","sel","TextSelection","$head","cellDepth","tableDepth","d","cellPos","tablePos","table","map","TableMap","rel","idx","row","col","textStart","offset","a","cellIndex","relCellPos","textPos","textNode","max","head","COLORS_DEFAULT","COLORS_DARK_MODE_DEFAULT","defaultProps","parseDefaultProps","addDefaultPropsExternalHTML","getBackgroundColorAttribute","attributeName","getTextColorAttribute","getTextAlignmentAttribute","parseFigureElement","figureElement","targetTag","targetElement","captionElement","caption","FilePanelExtension","createExtension","store","createStore","closeMenu","signal","unsubscribeOnChange","unsubscribeOnSelectionChange","blockId","createAddFileButton","buttonIcon","addFileButton","addFileButtonIcon","addFileButtonText","addFileButtonMouseDownHandler","addFileButtonClickHandler","FILE_ICON_SVG","createFileNameWithIcon","file","icon","fileName","createFileBlockWrapper","wrapper","destroyUploadStartHandler","loading","ret","fileNameWithIcon","createFigureWithCaption","figure","createLinkWithCaption","fileCaption","parseAudioElement","audioElement","FILE_AUDIO_ICON_SVG","createAudioBlockConfig","_ctx","audioParse","_config","backgroundColor","parsedFigure","audioRender","audio","downloadUrl","audioToExternalHTML","_editor","createAudioBlockSpec","shikiParserSymbol","shikiHighlighterPromiseSymbol","lazyShikiPlugin","globalThisForShiki","highlighter","parser","hasWarned","createHighlightPlugin","parserOptions","createdHighlighter","language","getLanguageId","createParser","createCodeBlockConfig","defaultLanguage","createCodeBlockSpec","e","code","el","pre","removeSelectChangeListener","select","option","handleLanguageChange","selectWrapper","$from","nextBlock","isAtEnd","endsWithDoubleNewline","newBlock","match","languageName","aliases","createDividerBlockConfig","createDividerBlockSpec","parseEmbedElement","embedElement","createFileBlockConfig","fileParse","createFileBlockSpec","fileSrcLink","defaultToggledState","isToggled","createToggleWrapper","renderedElement","toggledState","dom","toggleWrapper","toggleButton","toggleButtonMouseDown","toggleButtonOnClick","toggleAddBlockButton","toggleAddBlockButtonMouseDown","toggleAddBlockButtonOnClick","updatedBlock","childCount","onEditorChange","newChildCount","mutation","HEADING_LEVELS","createHeadingKeyboardShortcut","level","cursorPosition","createHeadingBlockConfig","defaultLevel","levels","allowToggleHeadings","createHeadingBlockSpec","createResizableFileBlockWrapper","resizeHandlesContainerElement","destroy","leftResizeHandle","rightResizeHandle","eventCaptureElement","resizeParams","width","windowMouseMoveHandler","newWidth","clientX","windowMouseUpHandler","wrapperMouseEnterHandler","wrapperMouseLeaveHandler","leftResizeHandleMouseDownHandler","rightResizeHandleMouseDownHandler","parseImageElement","imageElement","previewWidth","FILE_IMAGE_ICON_SVG","createImageBlockConfig","imageParse","imageRender","imageWrapper","image","imageToExternalHTML","createImageBlockSpec","splitBlockCommand","posInBlock","keepType","keepProps","state","splitBlockTr","nearestBlockContainerPos","getNearestBlockPos","info","getBlockInfo","types","handleEnter","listItemType","selectionEmpty","getBlockInfoFromTransaction","blockContainer","getListItemContent","_node","clonedNodeDiv","blockGroupNode","listItemsFirstChild","listItemNode","remainingListItemChildren","listItemsChildren","createBulletListItemBlockConfig","createBulletListItemBlockSpec","parent","li","p","getBlockInfoFromSelection","createCheckListItemConfig","createCheckListItemBlockSpec","checkbox","calculateListItemIndex","index","isFirst","hasStart","prevBlock","prevBlockIndex","getDecorations","previousPluginState","nextDecorationSet","decorationsToAdd","deco","blockNode","Decoration","decorationsToRemove","NumberedListIndexingDecorationPlugin","Plugin","PluginKey","DecorationSet","createNumberedListItemBlockConfig","createNumberedListItemBlockSpec","startIndex","createToggleListItemBlockConfig","createToggleListItemBlockSpec","paragraphEl","createParagraphBlockConfig","createParagraphBlockSpec","createQuoteBlockConfig","createQuoteBlockSpec","textColor","quote","RESIZE_MIN_WIDTH","EMPTY_CELL_WIDTH","EMPTY_CELL_HEIGHT","TableExtension","Extension","columnResizing","tableEditing","selection","selectionIsEmpty","selectionIsAtStartOfNode","selectionIsInTableParagraphNode","view","goToNextCell","extension","context","callOrReturn","getExtensionField","tablePropSchema","TiptapTableHeader","colwidth","parseTableContent","mergeAttributes","TiptapTableCell","TiptapTableNode","domOutputSpec","colGroup","tableCell","colWidth","BlockNoteTableView","TableView","cellMinWidth","tableWrapper","tableWrapperInner","floatingContainer","record","TiptapTableParagraph","TiptapTableRow","parsedContent","extractedContent","createTableBlockSpec","CellSelection","numCells","cell","selectionNumCells","parseVideoElement","videoElement","FILE_VIDEO_ICON_SVG","createVideoBlockConfig","videoParse","createVideoBlockSpec","videoWrapper","video","editorHasBlockWithType","propName","propSpec","blockHasType","isTableCellSelection","editorToMapping","getMapping","mapping","Mapping","transaction","trackPosition","position","side","ySyncPluginState","ySyncPluginKey","trackedMapLength","relativePosition","absolutePositionToRelativePosition","curYSyncPluginState","relativePositionToAbsolutePosition","findBlock","findParentNode","SuggestionMenuView","emitUpdate","__publicField","decorationNode","suggestionMenuPluginKey","menuName","prevState","prev","next","started","stopped","SuggestionMenu","triggerCharacters","triggerCharacter","pluginState","v","_oldState","newState","suggestionPluginTransactionMeta","trackedPosition","from","to","text","snippet","suggestionPluginState","setSelectionToNextContentEditableBlock","contentType","insertOrUpdateBlockForSlashMenu","currentBlock","isStyledTextInlineContent","getDefaultSlashMenuItems","items","insertedBlock","filterSuggestionItems","query","title","alias","defaultBlockSpecs","TextColor","span","BackgroundColor","defaultStyleSpecs","Bold","Italic","Underline","Strike","Code","defaultStyleSchema","defaultInlineContentSpecs","defaultInlineContentSchema"],"mappings":"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"}},
    {"offset": {"line": 4942, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/TrailingNode-B_zPMWxw.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/html/util/serializeBlocksExternalHTML.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/html/externalHTMLExporter.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/getBlocksChangedByTransaction.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/markdown/util/removeUnderlinesRehypePlugin.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/markdown/util/addSpacesToCheckboxesRehypePlugin.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/markdown/util/convertVideoToMarkdownRehypePlugin.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/markdown/markdownExporter.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/nodeConversions/fragmentToBlocks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/BlockChange/BlockChange.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/YCursorPlugin.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/YSync.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/YUndo.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/ForkYDoc.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/schemaMigration/migrationRules/moveColorAttributes.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/schemaMigration/migrationRules/index.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Collaboration/schemaMigration/SchemaMigration.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/DropCursor/DropCursor.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/FormattingToolbar/FormattingToolbar.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/History/History.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/LinkToolbar/LinkToolbar.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/LinkToolbar/protocols.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/NodeSelectionKeyboard/NodeSelectionKeyboard.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/Placeholder/Placeholder.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/PreviousBlockType/PreviousBlockType.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/getDraggableBlockFromElement.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SideMenu/MultipleNodeSelection.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SideMenu/dragging.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SideMenu/SideMenu.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/TableHandles/TableHandles.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/TrailingNode/TrailingNode.ts"],"sourcesContent":["import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockImplementation,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\n\nfunction addAttributesAndRemoveClasses(element: HTMLElement) {\n  // Removes all BlockNote specific class names.\n  const className =\n    Array.from(element.classList).filter(\n      (className) => !className.startsWith(\"bn-\"),\n    ) || [];\n\n  if (className.length > 0) {\n    element.className = className.join(\" \");\n  } else {\n    element.removeAttribute(\"class\");\n  }\n}\n\nexport function serializeInlineContentExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method or fallback to `render`\n        const output = inlineContentImplementation.toExternalHTML\n          ? inlineContentImplementation.toExternalHTML(\n              inlineContent as any,\n              editor as any,\n            )\n          : inlineContentImplementation.render.call(\n              {\n                renderType: \"dom\",\n                props: undefined,\n              },\n              inlineContent as any,\n              () => {\n                // No-op\n              },\n              editor as any,\n            );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = (\n            editor.schema.styleSpecs[mark.type.name].implementation\n              .toExternalHTML ??\n            editor.schema.styleSpecs[mark.type.name].implementation.render\n          )(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  if (\n    fragment.childNodes.length === 1 &&\n    fragment.firstChild?.nodeType === 1 /* Node.ELEMENT_NODE */\n  ) {\n    addAttributesAndRemoveClasses(fragment.firstChild as HTMLElement);\n  }\n\n  return fragment;\n}\n\n/**\n * TODO: there's still quite some logic that handles getting and filtering properties,\n * we should make sure the `toExternalHTML` methods of default blocks actually handle this,\n * instead of the serializer.\n */\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  // the container node is just used as a workaround to get some block-level attributes.\n  // we should change toExternalHTML so that this is not necessary\n  const attrs = Array.from(bc.dom.attributes);\n\n  const blockImplementation = editor.blockImplementations[block.type as any]\n    .implementation as BlockImplementation;\n  const ret =\n    blockImplementation.toExternalHTML?.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    ) ||\n    blockImplementation.render.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    );\n\n  const elementFragment = doc.createDocumentFragment();\n\n  if ((ret.dom as HTMLElement).classList.contains(\"bn-block-content\")) {\n    const blockContentDataAttributes = [\n      ...attrs,\n      ...Array.from((ret.dom as HTMLElement).attributes),\n    ].filter(\n      (attr) =>\n        attr.name.startsWith(\"data\") &&\n        attr.name !== \"data-content-type\" &&\n        attr.name !== \"data-file-block\" &&\n        attr.name !== \"data-node-view-wrapper\" &&\n        attr.name !== \"data-node-type\" &&\n        attr.name !== \"data-id\" &&\n        attr.name !== \"data-editable\",\n    );\n\n    // ret.dom = ret.dom.firstChild! as any;\n    for (const attr of blockContentDataAttributes) {\n      (ret.dom.firstChild! as HTMLElement).setAttribute(attr.name, attr.value);\n    }\n\n    addAttributesAndRemoveClasses(ret.dom.firstChild! as HTMLElement);\n    elementFragment.append(...Array.from(ret.dom.childNodes));\n  } else {\n    elementFragment.append(ret.dom);\n  }\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentExternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      options,\n    );\n\n    ret.contentDOM.appendChild(ic);\n  }\n\n  let listType = undefined;\n  if (orderedListItemBlockTypes.has(block.type!)) {\n    listType = \"OL\";\n  } else if (unorderedListItemBlockTypes.has(block.type!)) {\n    listType = \"UL\";\n  }\n\n  if (listType) {\n    if (fragment.lastChild?.nodeName !== listType) {\n      const list = doc.createElement(listType);\n\n      if (\n        listType === \"OL\" &&\n        \"start\" in props &&\n        props.start &&\n        props?.start !== 1\n      ) {\n        list.setAttribute(\"start\", props.start + \"\");\n      }\n      fragment.append(list);\n    }\n    fragment.lastChild!.appendChild(elementFragment);\n  } else {\n    fragment.append(elementFragment);\n  }\n\n  if (block.children && block.children.length > 0) {\n    const childFragment = doc.createDocumentFragment();\n    serializeBlocksToFragment(\n      childFragment,\n      editor,\n      block.children,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n    if (\n      fragment.lastChild?.nodeName === \"UL\" ||\n      fragment.lastChild?.nodeName === \"OL\"\n    ) {\n      // add nested lists to the last list item\n      while (\n        childFragment.firstChild?.nodeName === \"UL\" ||\n        childFragment.firstChild?.nodeName === \"OL\"\n      ) {\n        fragment.lastChild!.lastChild!.appendChild(childFragment.firstChild!);\n      }\n    }\n\n    if (editor.pmSchema.nodes[block.type as any].isInGroup(\"blockContent\")) {\n      // default \"blockContainer\" style blocks are flattened (no \"nested block\" support) for externalHTML, so append the child fragment to the outer fragment\n      fragment.append(childFragment);\n    } else {\n      // for columns / column lists, do use nesting\n      ret.contentDOM?.append(childFragment);\n    }\n  }\n}\n\nconst serializeBlocksToFragment = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  for (const block of blocks) {\n    serializeBlock(\n      fragment,\n      editor,\n      block,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n  }\n};\n\nexport const serializeBlocksExternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  serializeBlocksToFragment(\n    fragment,\n    editor,\n    blocks,\n    serializer,\n    orderedListItemBlockTypes,\n    unorderedListItemBlockTypes,\n    options,\n  );\n  return fragment;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport {\n  serializeBlocksExternalHTML,\n  serializeInlineContentExternalHTML,\n} from \"./util/serializeBlocksExternalHTML.js\";\n\n// Used to export BlockNote blocks and ProseMirror nodes to HTML for use outside\n// the editor. Blocks are exported using the `toExternalHTML` method in their\n// `blockSpec`, or `toInternalHTML` if `toExternalHTML` is not defined.\n//\n// The HTML created by this serializer is different to what's rendered by the\n// editor to the DOM. This also means that data is likely to be lost when\n// converting back to original blocks. The differences in the output HTML are:\n// 1. It doesn't include the `blockGroup` and `blockContainer` wrappers meaning\n// that nesting is not preserved for non-list-item blocks.\n// 2. `li` items in the output HTML are wrapped in `ul` or `ol` elements.\n// 3. While nesting for list items is preserved, other types of blocks nested\n// inside a list are un-nested and a new list is created after them.\n// 4. The HTML is wrapped in a single `div` element.\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport const createExternalHTMLExporter = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    exportBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      const html = serializeBlocksExternalHTML(\n        editor,\n        blocks,\n        serializer,\n        new Set<string>([\"numberedListItem\"]),\n        new Set<string>([\"bulletListItem\", \"checkListItem\", \"toggleListItem\"]),\n        options,\n      );\n      const div = document.createElement(\"div\");\n      div.append(html);\n      return div.innerHTML;\n    },\n\n    exportInlineContent: (\n      inlineContent: InlineContent<I, S>[],\n      options: { document?: Document },\n    ) => {\n      const domFragment = serializeInlineContentExternalHTML(\n        editor,\n        inlineContent as any,\n        serializer,\n        options,\n      );\n\n      const parent = document.createElement(\"div\");\n      parent.append(domFragment.cloneNode(true));\n\n      return parent.innerHTML;\n    },\n  };\n};\n","import { combineTransactionSteps } from \"@tiptap/core\";\nimport deepEqual from \"fast-deep-equal\";\nimport type { Node } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../blocks/defaultBlocks.js\";\nimport type { BlockSchema } from \"../schema/index.js\";\nimport type { InlineContentSchema } from \"../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../schema/styles/types.js\";\nimport { nodeToBlock } from \"./nodeConversions/nodeToBlock.js\";\nimport { isNodeBlock } from \"./nodeUtil.js\";\nimport { getPmSchema } from \"./pmUtil.js\";\n\n/**\n * Change detection utilities for BlockNote.\n *\n * High-level algorithm used by getBlocksChangedByTransaction:\n * 1) Merge appended transactions into one document change.\n * 2) Collect a snapshot of blocks before and after (flat map by id, and per-parent child order).\n * 3) Emit inserts and deletes by diffing ids between snapshots.\n * 4) For ids present in both snapshots:\n *    - If parentId changed, emit a move\n *    - Else if block changed (ignoring children), emit an update\n * 5) Finally, detect same-parent sibling reorders by comparing child order per parent.\n *    We use an inlined O(n log n) LIS inside detectReorderedChildren to keep a\n *    longest already-ordered subsequence and mark only the remaining items as moved.\n */\n/**\n * Gets the parent block of a node, if it has one.\n */\nfunction getParentBlockId(doc: Node, pos: number): string | undefined {\n  if (pos === 0) {\n    return undefined;\n  }\n  const resolvedPos = doc.resolve(pos);\n  for (let i = resolvedPos.depth; i > 0; i--) {\n    const parent = resolvedPos.node(i);\n    if (isNodeBlock(parent)) {\n      return parent.attrs.id;\n    }\n  }\n  return undefined;\n}\n\n/**\n * This attributes the changes to a specific source.\n */\nexport type BlockChangeSource =\n  | { type: \"local\" }\n  | { type: \"paste\" }\n  | { type: \"drop\" }\n  | { type: \"undo\" | \"redo\" | \"undo-redo\" }\n  | { type: \"yjs-remote\" };\n\nexport type BlocksChanged<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> = Array<\n  {\n    /**\n     * The affected block.\n     */\n    block: Block<BSchema, ISchema, SSchema>;\n    /**\n     * The source of the change.\n     */\n    source: BlockChangeSource;\n  } & (\n    | {\n        type: \"insert\" | \"delete\";\n        /**\n         * Insert and delete changes don't have a previous block.\n         */\n        prevBlock: undefined;\n      }\n    | {\n        type: \"update\";\n        /**\n         * The previous block.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n      }\n    | {\n        type: \"move\";\n        /**\n         * The affected block.\n         */\n        block: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The block before the move.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The previous parent block (if it existed).\n         */\n        prevParent?: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The current parent block (if it exists).\n         */\n        currentParent?: Block<BSchema, ISchema, SSchema>;\n      }\n  )\n>;\n\nfunction determineChangeSource(transaction: Transaction): BlockChangeSource {\n  if (transaction.getMeta(\"paste\")) {\n    return { type: \"paste\" };\n  }\n  if (transaction.getMeta(\"uiEvent\") === \"drop\") {\n    return { type: \"drop\" };\n  }\n  if (transaction.getMeta(\"history$\")) {\n    return {\n      type: transaction.getMeta(\"history$\").redo ? \"redo\" : \"undo\",\n    };\n  }\n  if (transaction.getMeta(\"y-sync$\")) {\n    if (transaction.getMeta(\"y-sync$\").isUndoRedoOperation) {\n      return { type: \"undo-redo\" };\n    }\n    return { type: \"yjs-remote\" };\n  }\n  return { type: \"local\" };\n}\n\ntype BlockSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> = {\n  byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  >;\n  childrenByParent: Record<string, string[]>;\n};\n\n/**\n * Collects a snapshot of blocks and per-parent child order in a single traversal.\n * Uses \"__root__\" to represent the root level where parentId is undefined.\n */\nfunction collectSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(doc: Node): BlockSnapshot<BSchema, ISchema, SSchema> {\n  const ROOT_KEY = \"__root__\";\n  const byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  > = {};\n  const childrenByParent: Record<string, string[]> = {};\n  const pmSchema = getPmSchema(doc);\n  doc.descendants((node, pos) => {\n    if (!isNodeBlock(node)) {\n      return true;\n    }\n    const parentId = getParentBlockId(doc, pos);\n    const key = parentId ?? ROOT_KEY;\n    if (!childrenByParent[key]) {\n      childrenByParent[key] = [];\n    }\n    const block = nodeToBlock(node, pmSchema);\n    byId[node.attrs.id] = { block, parentId };\n    childrenByParent[key].push(node.attrs.id);\n    return true;\n  });\n  return { byId, childrenByParent };\n}\n\n/**\n * Determines which child ids have been reordered (moved) within the same parent.\n * Uses LIS to keep the longest ordered subsequence and marks the rest as moved.\n */\nfunction detectReorderedChildren(\n  prevOrder: string[] | undefined,\n  nextOrder: string[] | undefined,\n): Set<string> {\n  const moved = new Set<string>();\n  if (!prevOrder || !nextOrder) {\n    return moved;\n  }\n  // Consider only ids present in both orders (ignore inserts/deletes handled elsewhere)\n  const prevIds = new Set(prevOrder);\n  const commonNext: string[] = nextOrder.filter((id) => prevIds.has(id));\n  const commonPrev: string[] = prevOrder.filter((id) =>\n    commonNext.includes(id),\n  );\n\n  if (commonPrev.length <= 1 || commonNext.length <= 1) {\n    return moved;\n  }\n\n  // Map ids to their index in previous order\n  const indexInPrev: Record<string, number> = {};\n  for (let i = 0; i < commonPrev.length; i++) {\n    indexInPrev[commonPrev[i]] = i;\n  }\n\n  // Build sequence of indices representing next order in terms of previous indices\n  const sequence: number[] = commonNext.map((id) => indexInPrev[id]);\n\n  // Inline O(n log n) LIS with reconstruction.\n  // Why LIS? We want the smallest set of siblings to label as \"moved\".\n  // Keeping the longest subsequence that is already in order achieves this,\n  // so only items outside the LIS are reported as moves.\n  const n = sequence.length;\n  const tailsValues: number[] = [];\n  const tailsEndsAtIndex: number[] = [];\n  const previousIndexInLis: number[] = new Array(n).fill(-1);\n\n  const lowerBound = (arr: number[], target: number): number => {\n    let lo = 0;\n    let hi = arr.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (arr[mid] < target) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  };\n\n  for (let i = 0; i < n; i++) {\n    const value = sequence[i];\n    const pos = lowerBound(tailsValues, value);\n    if (pos > 0) {\n      previousIndexInLis[i] = tailsEndsAtIndex[pos - 1];\n    }\n    if (pos === tailsValues.length) {\n      tailsValues.push(value);\n      tailsEndsAtIndex.push(i);\n    } else {\n      tailsValues[pos] = value;\n      tailsEndsAtIndex[pos] = i;\n    }\n  }\n\n  const lisIndexSet = new Set<number>();\n  let k = tailsEndsAtIndex[tailsEndsAtIndex.length - 1] ?? -1;\n  while (k !== -1) {\n    lisIndexSet.add(k);\n    k = previousIndexInLis[k];\n  }\n\n  // Items not part of LIS are considered moved\n  for (let i = 0; i < commonNext.length; i++) {\n    if (!lisIndexSet.has(i)) {\n      moved.add(commonNext[i]);\n    }\n  }\n  return moved;\n}\n\n/**\n * Get the blocks that were changed by a transaction.\n */\nexport function getBlocksChangedByTransaction<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n>(\n  transaction: Transaction,\n  appendedTransactions: Transaction[] = [],\n): BlocksChanged<BSchema, ISchema, SSchema> {\n  const source = determineChangeSource(transaction);\n  const combinedTransaction = combineTransactionSteps(transaction.before, [\n    transaction,\n    ...appendedTransactions,\n  ]);\n\n  const prevSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.before,\n  );\n  const nextSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.doc,\n  );\n\n  const changes: BlocksChanged<BSchema, ISchema, SSchema> = [];\n  const changedIds = new Set<string>();\n\n  // Handle inserted blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => !(id in prevSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"insert\",\n        block: nextSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle deleted blocks\n  Object.keys(prevSnap.byId)\n    .filter((id) => !(id in nextSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"delete\",\n        block: prevSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle updated, moved to different parent, indented, outdented blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => id in prevSnap.byId)\n    .forEach((id) => {\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      const isParentDifferent = prev.parentId !== next.parentId;\n\n      if (isParentDifferent) {\n        changes.push({\n          type: \"move\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n          prevParent: prev.parentId\n            ? prevSnap.byId[prev.parentId]?.block\n            : undefined,\n          currentParent: next.parentId\n            ? nextSnap.byId[next.parentId]?.block\n            : undefined,\n        });\n        changedIds.add(id);\n      } else if (\n        // Compare blocks while ignoring children to avoid reporting a parent\n        // update when only descendants changed.\n        !deepEqual(\n          { ...prev.block, children: undefined } as any,\n          { ...next.block, children: undefined } as any,\n        )\n      ) {\n        changes.push({\n          type: \"update\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n        });\n        changedIds.add(id);\n      }\n    });\n\n  // Handle sibling reorders (parent unchanged but relative order changed)\n  const prevOrderByParent = prevSnap.childrenByParent;\n  const nextOrderByParent = nextSnap.childrenByParent;\n\n  // Use a special key for root-level siblings\n  const ROOT_KEY = \"__root__\";\n  const parents = new Set<string>([\n    ...Object.keys(prevOrderByParent),\n    ...Object.keys(nextOrderByParent),\n  ]);\n\n  const addedMoveForId = new Set<string>();\n\n  parents.forEach((parentKey) => {\n    const movedWithinParent = detectReorderedChildren(\n      prevOrderByParent[parentKey],\n      nextOrderByParent[parentKey],\n    );\n    if (movedWithinParent.size === 0) {\n      return;\n    }\n    movedWithinParent.forEach((id) => {\n      // Only consider ids that exist in both snapshots and whose parent truly did not change\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      if (!prev || !next) {\n        return;\n      }\n      if (prev.parentId !== next.parentId) {\n        return;\n      }\n      // Skip if already accounted for by insert/delete/update/parent move\n      if (changedIds.has(id)) {\n        return;\n      }\n      // Verify we're addressing the right parent bucket\n      const bucketKey = prev.parentId ?? ROOT_KEY;\n      if (bucketKey !== parentKey) {\n        return;\n      }\n      if (addedMoveForId.has(id)) {\n        return;\n      }\n      addedMoveForId.add(id);\n      changes.push({\n        type: \"move\",\n        block: next.block,\n        prevBlock: prev.block,\n        source,\n        prevParent: prev.parentId\n          ? prevSnap.byId[prev.parentId]?.block\n          : undefined,\n        currentParent: next.parentId\n          ? nextSnap.byId[next.parentId]?.block\n          : undefined,\n      });\n      changedIds.add(id);\n    });\n  });\n\n  return changes;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\n/**\n * Rehype plugin which adds a space after each checkbox input element. This is\n * because remark doesn't add any spaces between the checkbox input and the text\n * itself, but these are needed for correct Markdown syntax.\n */\nexport function addSpacesToCheckboxes() {\n  const helper = (tree: HASTParent) => {\n    if (tree.children && \"length\" in tree.children && tree.children.length) {\n      for (let i = tree.children.length - 1; i >= 0; i--) {\n        const child = tree.children[i];\n        const nextChild =\n          i + 1 < tree.children.length ? tree.children[i + 1] : undefined;\n\n        // Checks for paragraph element after checkbox input element.\n        if (\n          child.type === \"element\" &&\n          child.tagName === \"input\" &&\n          child.properties?.type === \"checkbox\" &&\n          nextChild?.type === \"element\" &&\n          nextChild.tagName === \"p\"\n        ) {\n          // Converts paragraph to span, otherwise remark will think it needs to\n          // be on a new line.\n          nextChild.tagName = \"span\";\n          // Adds a space after the checkbox input element.\n          nextChild.children.splice(\n            0,\n            0,\n            fromDom(document.createTextNode(\" \")) as HASTElement,\n          );\n        } else {\n          helper(child as HASTParent);\n        }\n      }\n    }\n  };\n\n  return helper;\n}\n","import { Parent as HASTParent } from \"hast\";\nimport { visit } from \"unist-util-visit\";\n\n// Originally, rehypeParse parses videos as links, which is incorrect.\nexport function convertVideoToMarkdown() {\n  return (tree: HASTParent) => {\n    visit(tree, \"element\", (node, index, parent) => {\n      if (parent && node.tagName === \"video\") {\n        const src = node.properties?.src || node.properties?.[\"data-url\"] || \"\";\n        const name =\n          node.properties?.title || node.properties?.[\"data-name\"] || \"\";\n        parent.children[index!] = {\n          type: \"text\",\n          value: `![${name}](${src})`,\n        };\n      }\n    });\n  };\n}\n","import { Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../html/externalHTMLExporter.js\";\nimport { removeUnderlines } from \"./util/removeUnderlinesRehypePlugin.js\";\nimport { addSpacesToCheckboxes } from \"./util/addSpacesToCheckboxesRehypePlugin.js\";\nimport { convertVideoToMarkdown } from \"./util/convertVideoToMarkdownRehypePlugin.js\";\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport function cleanHTMLToMarkdown(cleanHTMLString: string) {\n  const markdownString = unified()\n    .use(rehypeParse, { fragment: true })\n    .use(convertVideoToMarkdown)\n    .use(removeUnderlines)\n    .use(addSpacesToCheckboxes)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify, {\n      handlers: { text: (node) => node.value },\n    })\n    .processSync(cleanHTMLString);\n\n  return markdownString.value as string;\n}\n\nexport function blocksToMarkdown<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  blocks: PartialBlock<BSchema, I, S>[],\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  options: { document?: Document },\n): string {\n  const exporter = createExternalHTMLExporter(schema, editor);\n  const externalHTML = exporter.exportBlocks(blocks, options);\n\n  return cleanHTMLToMarkdown(externalHTML);\n}\n","import { Fragment } from \"@tiptap/pm/model\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getPmSchema } from \"../pmUtil.js\";\nimport { nodeToBlock } from \"./nodeToBlock.js\";\n\n/**\n * Converts all Blocks within a fragment to BlockNote blocks.\n */\nexport function fragmentToBlocks<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(fragment: Fragment) {\n  // first convert selection to blocknote-style blocks, and then\n  // pass these to the exporter\n  const blocks: BlockNoDefaults<B, I, S>[] = [];\n  fragment.descendants((node) => {\n    const pmSchema = getPmSchema(node);\n    if (node.type.name === \"blockContainer\") {\n      if (node.firstChild?.type.name === \"blockGroup\") {\n        // selection started within a block group\n        // in this case the fragment starts with:\n        // <blockContainer>\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // instead of:\n        // <blockContainer>\n        //   <blockContent ... />\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // so we don't need to serialize this block, just descend into the children of the blockGroup\n        return true;\n      }\n    }\n\n    if (node.type.name === \"columnList\" && node.childCount === 1) {\n      // column lists with a single column should be flattened (not the entire column list has been selected)\n      node.firstChild?.forEach((child) => {\n        blocks.push(nodeToBlock(child, pmSchema));\n      });\n      return false;\n    }\n\n    if (node.type.isInGroup(\"bnBlock\")) {\n      blocks.push(nodeToBlock(node, pmSchema));\n      // don't descend into children, as they're already included in the block returned by nodeToBlock\n      return false;\n    }\n    return true;\n  });\n  return blocks;\n}\n","import { Plugin, PluginKey, Transaction } from \"prosemirror-state\";\nimport {\n  BlocksChanged,\n  getBlocksChangedByTransaction,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\n/**\n * This plugin can filter transactions before they are applied to the editor, but with a higher-level API than `filterTransaction` from prosemirror.\n */\nexport const BlockChangeExtension = createExtension(() => {\n  const beforeChangeCallbacks: ((context: {\n    getChanges: () => BlocksChanged<any, any, any>;\n    tr: Transaction;\n  }) => boolean | void)[] = [];\n  return {\n    key: \"blockChange\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: new PluginKey(\"blockChange\"),\n        filterTransaction: (tr) => {\n          let changes:\n            | ReturnType<typeof getBlocksChangedByTransaction>\n            | undefined = undefined;\n\n          return beforeChangeCallbacks.reduce((acc, cb) => {\n            if (acc === false) {\n              // We only care that we hit a `false` result, so we can stop iterating.\n              return acc;\n            }\n            return (\n              cb({\n                getChanges() {\n                  if (changes) {\n                    return changes;\n                  }\n                  changes = getBlocksChangedByTransaction(tr);\n                  return changes;\n                },\n                tr,\n              }) !== false\n            );\n          }, true);\n        },\n      }),\n    ],\n\n    /**\n     * Subscribe to the block change events.\n     */\n    subscribe(\n      callback: (context: {\n        getChanges: () => BlocksChanged<any, any, any>;\n        tr: Transaction;\n      }) => boolean | void,\n    ) {\n      beforeChangeCallbacks.push(callback);\n\n      return () => {\n        beforeChangeCallbacks.splice(\n          beforeChangeCallbacks.indexOf(callback),\n          1,\n        );\n      };\n    },\n  } as const;\n});\n","import { defaultSelectionBuilder, yCursorPlugin } from \"y-prosemirror\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\nexport type CollaborationUser = {\n  name: string;\n  color: string;\n  [key: string]: string;\n};\n\n/**\n * Determine whether the foreground color should be white or black based on a provided background color\n * Inspired by: https://stackoverflow.com/a/3943023\n */\nfunction isDarkColor(bgColor: string): boolean {\n  const color = bgColor.charAt(0) === \"#\" ? bgColor.substring(1, 7) : bgColor;\n  const r = parseInt(color.substring(0, 2), 16); // hexToR\n  const g = parseInt(color.substring(2, 4), 16); // hexToG\n  const b = parseInt(color.substring(4, 6), 16); // hexToB\n  const uicolors = [r / 255, g / 255, b / 255];\n  const c = uicolors.map((col) => {\n    if (col <= 0.03928) {\n      return col / 12.92;\n    }\n    return Math.pow((col + 0.055) / 1.055, 2.4);\n  });\n  const L = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];\n  return L <= 0.179;\n}\n\nfunction defaultCursorRender(user: CollaborationUser) {\n  const cursorElement = document.createElement(\"span\");\n\n  cursorElement.classList.add(\"bn-collaboration-cursor__base\");\n\n  const caretElement = document.createElement(\"span\");\n  caretElement.setAttribute(\"contentedEditable\", \"false\");\n  caretElement.classList.add(\"bn-collaboration-cursor__caret\");\n  caretElement.setAttribute(\n    \"style\",\n    `background-color: ${user.color}; color: ${\n      isDarkColor(user.color) ? \"white\" : \"black\"\n    }`,\n  );\n\n  const labelElement = document.createElement(\"span\");\n\n  labelElement.classList.add(\"bn-collaboration-cursor__label\");\n  labelElement.setAttribute(\n    \"style\",\n    `background-color: ${user.color}; color: ${\n      isDarkColor(user.color) ? \"white\" : \"black\"\n    }`,\n  );\n  labelElement.insertBefore(document.createTextNode(user.name), null);\n\n  caretElement.insertBefore(labelElement, null);\n\n  cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n  cursorElement.insertBefore(caretElement, null);\n  cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n\n  return cursorElement;\n}\n\nexport const YCursorExtension = createExtension(\n  ({\n    options,\n  }: ExtensionOptions<\n    NonNullable<BlockNoteEditorOptions<any, any, any>[\"collaboration\"]>\n  >) => {\n    const recentlyUpdatedCursors = new Map();\n\n    if (\n      options.provider &&\n      \"awareness\" in options.provider &&\n      typeof options.provider.awareness === \"object\"\n    ) {\n      if (\n        \"setLocalStateField\" in options.provider.awareness &&\n        typeof options.provider.awareness.setLocalStateField === \"function\"\n      ) {\n        options.provider.awareness.setLocalStateField(\"user\", options.user);\n      }\n      if (\n        \"on\" in options.provider.awareness &&\n        typeof options.provider.awareness.on === \"function\"\n      ) {\n        if (options.showCursorLabels !== \"always\") {\n          options.provider.awareness.on(\n            \"change\",\n            ({\n              updated,\n            }: {\n              added: Array<number>;\n              updated: Array<number>;\n              removed: Array<number>;\n            }) => {\n              for (const clientID of updated) {\n                const cursor = recentlyUpdatedCursors.get(clientID);\n\n                if (cursor) {\n                  cursor.element.setAttribute(\"data-active\", \"\");\n\n                  if (cursor.hideTimeout) {\n                    clearTimeout(cursor.hideTimeout);\n                  }\n\n                  recentlyUpdatedCursors.set(clientID, {\n                    element: cursor.element,\n                    hideTimeout: setTimeout(() => {\n                      cursor.element.removeAttribute(\"data-active\");\n                    }, 2000),\n                  });\n                }\n              }\n            },\n          );\n        }\n      }\n    }\n\n    return {\n      key: \"yCursor\",\n      prosemirrorPlugins: [\n        yCursorPlugin(options.provider.awareness, {\n          selectionBuilder: defaultSelectionBuilder,\n          cursorBuilder(user: CollaborationUser, clientID: number) {\n            let cursorData = recentlyUpdatedCursors.get(clientID);\n\n            if (!cursorData) {\n              const cursorElement = (\n                options.renderCursor ?? defaultCursorRender\n              )(user);\n\n              if (options.showCursorLabels !== \"always\") {\n                cursorElement.addEventListener(\"mouseenter\", () => {\n                  const cursor = recentlyUpdatedCursors.get(clientID)!;\n                  cursor.element.setAttribute(\"data-active\", \"\");\n\n                  if (cursor.hideTimeout) {\n                    clearTimeout(cursor.hideTimeout);\n                    recentlyUpdatedCursors.set(clientID, {\n                      element: cursor.element,\n                      hideTimeout: undefined,\n                    });\n                  }\n                });\n\n                cursorElement.addEventListener(\"mouseleave\", () => {\n                  const cursor = recentlyUpdatedCursors.get(clientID)!;\n\n                  recentlyUpdatedCursors.set(clientID, {\n                    element: cursor.element,\n                    hideTimeout: setTimeout(() => {\n                      cursor.element.removeAttribute(\"data-active\");\n                    }, 2000),\n                  });\n                });\n              }\n\n              cursorData = {\n                element: cursorElement,\n                hideTimeout: undefined,\n              };\n\n              recentlyUpdatedCursors.set(clientID, cursorData);\n            }\n\n            return cursorData.element;\n          },\n        }),\n      ],\n      dependsOn: [\"ySync\"],\n      updateUser(user: { name: string; color: string; [key: string]: string }) {\n        options.provider.awareness.setLocalStateField(\"user\", user);\n      },\n    } as const;\n  },\n);\n","import { ySyncPlugin } from \"y-prosemirror\";\nimport { XmlFragment } from \"yjs\";\nimport {\n  ExtensionOptions,\n  createExtension,\n} from \"../../editor/BlockNoteExtension.js\";\n\nexport const YSyncExtension = createExtension(\n  ({ options }: ExtensionOptions<{ fragment: XmlFragment }>) => {\n    return {\n      key: \"ySync\",\n      prosemirrorPlugins: [ySyncPlugin(options.fragment)],\n      runsBefore: [\"default\"],\n    } as const;\n  },\n);\n","import { redoCommand, undoCommand, yUndoPlugin } from \"y-prosemirror\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport const YUndoExtension = createExtension(({ editor }) => {\n  return {\n    key: \"yUndo\",\n    prosemirrorPlugins: [yUndoPlugin({ trackedOrigins: [editor] })],\n    dependsOn: [\"yCursor\", \"ySync\"],\n    undoCommand: undoCommand,\n    redoCommand: redoCommand,\n  } as const;\n});\n","import { yUndoPluginKey } from \"y-prosemirror\";\nimport * as Y from \"yjs\";\nimport {\n  createExtension,\n  createStore,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { YCursorExtension } from \"./YCursorPlugin.js\";\nimport { YSyncExtension } from \"./YSync.js\";\nimport { YUndoExtension } from \"./YUndo.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\n/**\n * To find a fragment in another ydoc, we need to search for it.\n */\nfunction findTypeInOtherYdoc<T extends Y.AbstractType<any>>(\n  ytype: T,\n  otherYdoc: Y.Doc,\n): T {\n  const ydoc = ytype.doc!;\n  if (ytype._item === null) {\n    /**\n     * If is a root type, we need to find the root key in the original ydoc\n     * and use it to get the type in the other ydoc.\n     */\n    const rootKey = Array.from(ydoc.share.keys()).find(\n      (key) => ydoc.share.get(key) === ytype,\n    );\n    if (rootKey == null) {\n      throw new Error(\"type does not exist in other ydoc\");\n    }\n    return otherYdoc.get(rootKey, ytype.constructor as new () => T) as T;\n  } else {\n    /**\n     * If it is a sub type, we use the item id to find the history type.\n     */\n    const ytypeItem = ytype._item;\n    const otherStructs = otherYdoc.store.clients.get(ytypeItem.id.client) ?? [];\n    const itemIndex = Y.findIndexSS(otherStructs, ytypeItem.id.clock);\n    const otherItem = otherStructs[itemIndex] as Y.Item;\n    const otherContent = otherItem.content as Y.ContentType;\n    return otherContent.type as T;\n  }\n}\n\nexport const ForkYDocExtension = createExtension(\n  ({\n    editor,\n    options,\n  }: ExtensionOptions<\n    NonNullable<BlockNoteEditorOptions<any, any, any>[\"collaboration\"]>\n  >) => {\n    let forkedState:\n      | {\n          originalFragment: Y.XmlFragment;\n          undoStack: Y.UndoManager[\"undoStack\"];\n          forkedFragment: Y.XmlFragment;\n        }\n      | undefined = undefined;\n\n    const store = createStore({ isForked: false });\n\n    return {\n      key: \"yForkDoc\",\n      store,\n      /**\n       * Fork the Y.js document from syncing to the remote,\n       * allowing modifications to the document without affecting the remote.\n       * These changes can later be rolled back or applied to the remote.\n       */\n      fork() {\n        if (forkedState) {\n          return;\n        }\n\n        const originalFragment = options.fragment;\n\n        if (!originalFragment) {\n          throw new Error(\"No fragment to fork from\");\n        }\n\n        const doc = new Y.Doc();\n        // Copy the original document to a new Yjs document\n        Y.applyUpdate(doc, Y.encodeStateAsUpdate(originalFragment.doc!));\n\n        // Find the forked fragment in the new Yjs document\n        const forkedFragment = findTypeInOtherYdoc(originalFragment, doc);\n\n        forkedState = {\n          undoStack: yUndoPluginKey.getState(editor.prosemirrorState)!\n            .undoManager.undoStack,\n          originalFragment,\n          forkedFragment,\n        };\n\n        // Need to reset all the yjs plugins\n        editor.unregisterExtension([\n          YUndoExtension,\n          YCursorExtension,\n          YSyncExtension,\n        ]);\n        const newOptions = {\n          ...options,\n          fragment: forkedFragment,\n        };\n        // Register them again, based on the new forked fragment\n        editor.registerExtension([\n          YSyncExtension(newOptions),\n          // No need to register the cursor plugin again, it's a local fork\n          YUndoExtension({}),\n        ]);\n\n        // Tell the store that the editor is now forked\n        store.setState({ isForked: true });\n      },\n\n      /**\n       * Resume syncing the Y.js document to the remote\n       * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.\n       * Otherwise, the original document will be restored and the changes will be discarded.\n       */\n      merge({ keepChanges }: { keepChanges: boolean }) {\n        if (!forkedState) {\n          return;\n        }\n        // Remove the forked fragment's plugins\n        editor.unregisterExtension([\"ySync\", \"yCursor\", \"yUndo\"]);\n\n        const { originalFragment, forkedFragment, undoStack } = forkedState;\n        // Register the plugins again, based on the original fragment (which is still in the original options)\n        editor.registerExtension([\n          YSyncExtension(options),\n          YCursorExtension(options),\n          YUndoExtension({}),\n        ]);\n\n        // Reset the undo stack to the original undo stack\n        yUndoPluginKey.getState(\n          editor.prosemirrorState,\n        )!.undoManager.undoStack = undoStack;\n\n        if (keepChanges) {\n          // Apply any changes that have been made to the fork, onto the original doc\n          const update = Y.encodeStateAsUpdate(\n            forkedFragment.doc!,\n            Y.encodeStateVector(originalFragment.doc!),\n          );\n          // Applying this change will add to the undo stack, allowing it to be undone normally\n          Y.applyUpdate(originalFragment.doc!, update, editor);\n        }\n        // Reset the forked state\n        forkedState = undefined;\n        // Tell the store that the editor is no longer forked\n        store.setState({ isForked: false });\n      },\n    } as const;\n  },\n);\n","import * as Y from \"yjs\";\n\nimport { MigrationRule } from \"./migrationRule.js\";\nimport { defaultProps } from \"../../../../blocks/defaultProps.js\";\n\n// Helper function to recursively traverse a `Y.XMLElement` and its descendant\n// elements.\nconst traverseElement = (\n  rootElement: Y.XmlElement,\n  cb: (element: Y.XmlElement) => void,\n) => {\n  cb(rootElement);\n  rootElement.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, cb);\n    }\n  });\n};\n\n// Moves `textColor` and `backgroundColor` attributes from `blockContainer`\n// nodes to their child `blockContent` nodes. This is due to a schema change\n// introduced in PR #TODO.\nexport const moveColorAttributes: MigrationRule = (fragment, tr) => {\n  // Stores necessary info for all `blockContainer` nodes which still have\n  // `textColor` or `backgroundColor` attributes that need to be moved.\n  const targetBlockContainers: Map<\n    string,\n    {\n      textColor: string | undefined;\n      backgroundColor: string | undefined;\n    }\n  > = new Map();\n  // Finds all elements which still have `textColor` or `backgroundColor`\n  // attributes in the current Yjs fragment.\n  fragment.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, (element) => {\n        if (\n          element.nodeName === \"blockContainer\" &&\n          element.hasAttribute(\"id\")\n        ) {\n          const textColor = element.getAttribute(\"textColor\");\n          const backgroundColor = element.getAttribute(\"backgroundColor\");\n\n          const colors = {\n            textColor:\n              textColor === defaultProps.textColor.default\n                ? undefined\n                : textColor,\n            backgroundColor:\n              backgroundColor === defaultProps.backgroundColor.default\n                ? undefined\n                : backgroundColor,\n          };\n\n          if (colors.textColor || colors.backgroundColor) {\n            targetBlockContainers.set(element.getAttribute(\"id\")!, colors);\n          }\n        }\n      });\n    }\n  });\n\n  if (targetBlockContainers.size === 0) {\n    return false;\n  }\n\n  // Appends transactions to add the `textColor` and `backgroundColor`\n  // attributes found on each `blockContainer` node to move them to the child\n  // `blockContent` node.\n  tr.doc.descendants((node, pos) => {\n    if (\n      node.type.name === \"blockContainer\" &&\n      targetBlockContainers.has(node.attrs.id)\n    ) {\n      const el = tr.doc.nodeAt(pos + 1);\n      if (!el) {\n        throw new Error(\"No element found\");\n      }\n\n      tr.setNodeMarkup(pos + 1, undefined, {\n        // preserve existing attributes\n        ...el.attrs,\n        // add the textColor and backgroundColor attributes\n        ...targetBlockContainers.get(node.attrs.id),\n      });\n    }\n  });\n\n  return true;\n};\n","import { MigrationRule } from \"./migrationRule.js\";\nimport { moveColorAttributes } from \"./moveColorAttributes.js\";\n\nexport default [moveColorAttributes] as MigrationRule[];\n","import { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport * as Y from \"yjs\";\n\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../../editor/BlockNoteExtension.js\";\nimport migrationRules from \"./migrationRules/index.js\";\n\n// This plugin allows us to update collaboration YDocs whenever BlockNote's\n// underlying ProseMirror schema changes. The plugin reads the current Yjs\n// fragment and dispatches additional transactions to the ProseMirror state, in\n// case things are found in the fragment that don't adhere to the editor schema\n// and need to be fixed. These fixes are defined as `MigrationRule`s within the\n// `migrationRules` directory.\nexport const SchemaMigration = createExtension(\n  ({ options }: ExtensionOptions<{ fragment: Y.XmlFragment }>) => {\n    let migrationDone = false;\n    const pluginKey = new PluginKey(\"schemaMigration\");\n\n    return {\n      key: \"schemaMigration\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: pluginKey,\n          appendTransaction: (transactions, _oldState, newState) => {\n            if (migrationDone) {\n              return undefined;\n            }\n\n            if (\n              // If any of the transactions are not due to a yjs sync, we don't need to run the migration\n              !transactions.some((tr) => tr.getMeta(\"y-sync$\")) ||\n              // If none of the transactions result in a document change, we don't need to run the migration\n              transactions.every((tr) => !tr.docChanged) ||\n              // If the fragment is still empty, we can't run the migration (since it has not yet been applied to the Y.Doc)\n              !options.fragment.firstChild\n            ) {\n              return undefined;\n            }\n\n            const tr = newState.tr;\n            for (const migrationRule of migrationRules) {\n              migrationRule(options.fragment, tr);\n            }\n\n            migrationDone = true;\n\n            if (!tr.docChanged) {\n              return undefined;\n            }\n\n            return tr;\n          },\n        }),\n      ],\n    } as const;\n  },\n);\n","import { dropCursor } from \"prosemirror-dropcursor\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\nexport const DropCursorExtension = createExtension(\n  ({\n    editor,\n    options,\n  }: ExtensionOptions<\n    Pick<BlockNoteEditorOptions<any, any, any>, \"dropCursor\">\n  >) => {\n    return {\n      key: \"dropCursor\",\n      prosemirrorPlugins: [\n        (options.dropCursor ?? dropCursor)({\n          width: 5,\n          color: \"#ddeeff\",\n          editor: editor,\n        }),\n      ],\n    } as const;\n  },\n);\n","import { NodeSelection, TextSelection } from \"prosemirror-state\";\n\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\n\nexport const FormattingToolbarExtension = createExtension(({ editor }) => {\n  const store = createStore(false);\n\n  const shouldShow = () => {\n    return editor.transact((tr) => {\n      // Don't show if the selection is empty, or is a text selection with no\n      // text.\n      if (tr.selection.empty) {\n        return false;\n      }\n\n      // Don't show if a block with inline content is selected.\n      if (\n        tr.selection instanceof NodeSelection &&\n        (tr.selection.node.type.spec.content === \"inline*\" ||\n          tr.selection.node.firstChild?.type.spec.content === \"inline*\")\n      ) {\n        return false;\n      }\n\n      // Don't show if the selection is a text selection but contains no text.\n      if (\n        tr.selection instanceof TextSelection &&\n        tr.doc.textBetween(tr.selection.from, tr.selection.to).length === 0\n      ) {\n        return false;\n      }\n\n      // Searches the content of the selection to see if it spans a node with a\n      // code spec.\n      let spansCode = false;\n      tr.selection.content().content.descendants((node) => {\n        if (node.type.spec.code) {\n          spansCode = true;\n        }\n        return !spansCode; // keep descending if we haven't found a code block\n      });\n\n      // Don't show if the selection spans a code block.\n      if (spansCode) {\n        return false;\n      }\n\n      // Show toolbar otherwise.\n      return true;\n    });\n  };\n\n  return {\n    key: \"formattingToolbar\",\n    store,\n    mount({ dom, signal }) {\n      /**\n       * We want to mimic the Notion behavior of not showing the toolbar while the user is holding down the mouse button (to create a selection)\n       */\n      let preventShowWhileMouseDown = false;\n\n      const unsubscribeOnChange = editor.onChange(() => {\n        if (preventShowWhileMouseDown) {\n          return;\n        }\n        // re-evaluate whether the toolbar should be shown\n        store.setState(shouldShow());\n      });\n      const unsubscribeOnSelectionChange = editor.onSelectionChange(() => {\n        if (preventShowWhileMouseDown) {\n          return;\n        }\n        // re-evaluate whether the toolbar should be shown\n        store.setState(shouldShow());\n      });\n\n      // To mimic Notion's behavior, we listen to the mouse down event to set the `preventShowWhileMouseDown` flag\n      dom.addEventListener(\n        \"pointerdown\",\n        () => {\n          preventShowWhileMouseDown = true;\n          store.setState(false);\n        },\n        { signal },\n      );\n      // To mimic Notion's behavior, we listen to the mouse up event to reset the `preventShowWhileMouseDown` flag and show the toolbar (if it should)\n      editor.prosemirrorView.root.addEventListener(\n        \"pointerup\",\n        () => {\n          preventShowWhileMouseDown = false;\n          // We only want to re-show the toolbar if the mouse made the selection\n          if (editor.isFocused()) {\n            store.setState(shouldShow());\n          }\n        },\n        { signal, capture: true },\n      );\n      // If the pointer gets cancelled, we don't want to be stuck in the `preventShowWhileMouseDown` state\n      dom.addEventListener(\n        \"pointercancel\",\n        () => {\n          preventShowWhileMouseDown = false;\n        },\n        {\n          signal,\n          capture: true,\n        },\n      );\n\n      signal.addEventListener(\"abort\", () => {\n        unsubscribeOnChange();\n        unsubscribeOnSelectionChange();\n      });\n    },\n  } as const;\n});\n","import { history, redo, undo } from \"@tiptap/pm/history\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport const HistoryExtension = createExtension(() => {\n  return {\n    key: \"history\",\n    prosemirrorPlugins: [history()],\n    undoCommand: undo,\n    redoCommand: redo,\n  } as const;\n});\n","import { getMarkRange, posToDOMRect } from \"@tiptap/core\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { getPmSchema } from \"../../api/pmUtil.js\";\n\nexport const LinkToolbarExtension = createExtension(({ editor }) => {\n  function getLinkElementAtPos(pos: number) {\n    let currentNode = editor.prosemirrorView.nodeDOM(pos);\n    while (currentNode && currentNode.parentElement) {\n      if (currentNode.nodeName === \"A\") {\n        return currentNode as HTMLAnchorElement;\n      }\n      currentNode = currentNode.parentElement;\n    }\n    return null;\n  }\n\n  function getMarkAtPos(pos: number, markType: string) {\n    return editor.transact((tr) => {\n      const resolvedPos = tr.doc.resolve(pos);\n      const mark = resolvedPos\n        .marks()\n        .find((mark) => mark.type.name === markType);\n\n      if (!mark) {\n        return;\n      }\n\n      const markRange = getMarkRange(resolvedPos, mark.type);\n      if (!markRange) {\n        return;\n      }\n\n      return {\n        range: markRange,\n        mark,\n        get text() {\n          return tr.doc.textBetween(markRange.from, markRange.to);\n        },\n        get position() {\n          // to minimize re-renders, we convert to JSON, which is the same shape anyway\n          return posToDOMRect(\n            editor.prosemirrorView,\n            markRange.from,\n            markRange.to,\n          ).toJSON() as DOMRect;\n        },\n      };\n    });\n  }\n\n  function getLinkAtSelection() {\n    return editor.transact((tr) => {\n      const selection = tr.selection;\n      if (!selection.empty) {\n        return undefined;\n      }\n      return getMarkAtPos(selection.anchor, \"link\");\n    });\n  }\n\n  return {\n    key: \"linkToolbar\",\n\n    getLinkAtSelection,\n    getLinkElementAtPos,\n    getMarkAtPos,\n\n    getLinkAtElement(element: HTMLElement) {\n      return editor.transact(() => {\n        const posAtElement = editor.prosemirrorView.posAtDOM(element, 0) + 1;\n        return getMarkAtPos(posAtElement, \"link\");\n      });\n    },\n\n    editLink(\n      url: string,\n      text: string,\n      position = editor.transact((tr) => tr.selection.anchor),\n    ) {\n      editor.transact((tr) => {\n        const pmSchema = getPmSchema(tr);\n        const { range } = getMarkAtPos(position + 1, \"link\") || {\n          range: {\n            from: tr.selection.from,\n            to: tr.selection.to,\n          },\n        };\n        if (!range) {\n          return;\n        }\n        tr.insertText(text, range.from, range.to);\n        tr.addMark(\n          range.from,\n          range.from + text.length,\n          pmSchema.mark(\"link\", { href: url }),\n        );\n      });\n      editor.prosemirrorView.focus();\n    },\n    deleteLink(position = editor.transact((tr) => tr.selection.anchor)) {\n      editor.transact((tr) => {\n        const pmSchema = getPmSchema(tr);\n        const { range } = getMarkAtPos(position + 1, \"link\") || {\n          range: {\n            from: tr.selection.from,\n            to: tr.selection.to,\n          },\n        };\n        if (!range) {\n          return;\n        }\n\n        tr.removeMark(range.from, range.to, pmSchema.marks[\"link\"]).setMeta(\n          \"preventAutolink\",\n          true,\n        );\n      });\n      editor.prosemirrorView.focus();\n    },\n  } as const;\n});\n","export const VALID_LINK_PROTOCOLS = [\n  \"http\",\n  \"https\",\n  \"ftp\",\n  \"ftps\",\n  \"mailto\",\n  \"tel\",\n  \"callto\",\n  \"sms\",\n  \"cid\",\n  \"xmpp\",\n];\nexport const DEFAULT_LINK_PROTOCOL = \"https\";\n","import { Plugin, PluginKey, TextSelection } from \"prosemirror-state\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(\"node-selection-keyboard\");\n// By default, typing with a node selection active will cause ProseMirror to\n// replace the node with one that contains editable content. This plugin blocks\n// this behaviour without also blocking things like keyboard shortcuts:\n//\n// - Lets through key presses that do not include alphanumeric characters. This\n// includes things like backspace/delete/home/end/etc.\n// - Lets through any key presses that include ctrl/meta keys. These will be\n// shortcuts of some kind like ctrl+C/mod+C.\n// - Special case for Enter key which creates a new paragraph block below and\n// sets the selection to it. This is just to bring the UX closer to Notion\n//\n// While a more elegant solution would probably process transactions instead of\n// keystrokes, this brings us most of the way to Notion's UX without much added\n// complexity.\nexport const NodeSelectionKeyboardExtension = createExtension(\n  () =>\n    ({\n      key: \"nodeSelectionKeyboard\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: PLUGIN_KEY,\n          props: {\n            handleKeyDown: (view, event) => {\n              // Checks for node selection\n              if (\"node\" in view.state.selection) {\n                // Checks if key press uses ctrl/meta modifier\n                if (event.ctrlKey || event.metaKey) {\n                  return false;\n                }\n                // Checks if key press is alphanumeric\n                if (event.key.length === 1) {\n                  event.preventDefault();\n\n                  return true;\n                }\n                // Checks if key press is Enter\n                if (\n                  event.key === \"Enter\" &&\n                  !event.shiftKey &&\n                  !event.altKey &&\n                  !event.ctrlKey &&\n                  !event.metaKey\n                ) {\n                  const tr = view.state.tr;\n                  view.dispatch(\n                    tr\n                      .insert(\n                        view.state.tr.selection.$to.after(),\n                        view.state.schema.nodes[\"paragraph\"].createChecked(),\n                      )\n                      .setSelection(\n                        new TextSelection(\n                          tr.doc.resolve(\n                            view.state.tr.selection.$to.after() + 1,\n                          ),\n                        ),\n                      ),\n                  );\n\n                  return true;\n                }\n              }\n\n              return false;\n            },\n          },\n        }),\n      ],\n    }) as const,\n);\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { v4 } from \"uuid\";\nimport {\n  createExtension,\n  ExtensionOptions,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { BlockNoteEditorOptions } from \"../../editor/BlockNoteEditor.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\nexport const PlaceholderExtension = createExtension(\n  ({\n    editor,\n    options,\n  }: ExtensionOptions<\n    Pick<BlockNoteEditorOptions<any, any, any>, \"placeholders\">\n  >) => {\n    const placeholders = options.placeholders;\n    return {\n      key: \"placeholder\",\n      prosemirrorPlugins: [\n        new Plugin({\n          key: PLUGIN_KEY,\n          view: (view) => {\n            const uniqueEditorSelector = `placeholder-selector-${v4()}`;\n            view.dom.classList.add(uniqueEditorSelector);\n            const styleEl = document.createElement(\"style\");\n\n            const nonce = editor._tiptapEditor.options.injectNonce;\n            if (nonce) {\n              styleEl.setAttribute(\"nonce\", nonce);\n            }\n\n            if (view.root instanceof window.ShadowRoot) {\n              view.root.append(styleEl);\n            } else {\n              view.root.head.appendChild(styleEl);\n            }\n\n            const styleSheet = styleEl.sheet!;\n\n            const getSelector = (additionalSelectors = \"\") =>\n              `.${uniqueEditorSelector} .bn-block-content${additionalSelectors} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;\n\n            try {\n              // FIXME: the names \"default\" and \"emptyDocument\" are hardcoded\n              const {\n                default: defaultPlaceholder,\n                emptyDocument: emptyPlaceholder,\n                ...rest\n              } = placeholders || {};\n\n              // add block specific placeholders\n              for (const [blockType, placeholder] of Object.entries(rest)) {\n                const blockTypeSelector = `[data-content-type=\"${blockType}\"]`;\n\n                styleSheet.insertRule(\n                  `${getSelector(blockTypeSelector)} { content: ${JSON.stringify(\n                    placeholder,\n                  )}; }`,\n                );\n              }\n\n              const onlyBlockSelector = `[data-is-only-empty-block]`;\n              const mustBeFocusedSelector = `[data-is-empty-and-focused]`;\n\n              // placeholder for when there's only one empty block\n              styleSheet.insertRule(\n                `${getSelector(onlyBlockSelector)} { content: ${JSON.stringify(\n                  emptyPlaceholder,\n                )}; }`,\n              );\n\n              // placeholder for default blocks, only when the cursor is in the block (mustBeFocused)\n              styleSheet.insertRule(\n                `${getSelector(mustBeFocusedSelector)} { content: ${JSON.stringify(\n                  defaultPlaceholder,\n                )}; }`,\n              );\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.warn(\n                `Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)`,\n                e,\n              );\n            }\n\n            return {\n              destroy: () => {\n                if (view.root instanceof window.ShadowRoot) {\n                  view.root.removeChild(styleEl);\n                } else {\n                  view.root.head.removeChild(styleEl);\n                }\n              },\n            };\n          },\n          props: {\n            decorations: (state) => {\n              const { doc, selection } = state;\n\n              if (!editor.isEditable) {\n                return;\n              }\n\n              if (!selection.empty) {\n                return;\n              }\n\n              // Don't show placeholder when the cursor is inside a code block\n              if (selection.$from.parent.type.spec.code) {\n                return;\n              }\n\n              const decs = [];\n\n              // decoration for when there's only one empty block\n              // positions are hardcoded for now\n              if (state.doc.content.size === 6) {\n                decs.push(\n                  Decoration.node(2, 4, {\n                    \"data-is-only-empty-block\": \"true\",\n                  }),\n                );\n              }\n\n              const $pos = selection.$anchor;\n              const node = $pos.parent;\n\n              if (node.content.size === 0) {\n                const before = $pos.before();\n\n                decs.push(\n                  Decoration.node(before, before + node.nodeSize, {\n                    \"data-is-empty-and-focused\": \"true\",\n                  }),\n                );\n              }\n\n              return DecorationSet.create(doc, decs);\n            },\n          },\n        }),\n      ],\n    } as const;\n  },\n);\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport const PreviousBlockTypeExtension = createExtension(() => {\n  let timeout: ReturnType<typeof setTimeout>;\n  return {\n    key: \"previousBlockType\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: PLUGIN_KEY,\n        view(_editorView) {\n          return {\n            update: async (view, _prevState) => {\n              if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n                // use setTimeout 0 to clear the decorations so that at least\n                // for one DOM-render the decorations have been applied\n                timeout = setTimeout(() => {\n                  view.dispatch(\n                    view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true }),\n                  );\n                }, 0);\n              }\n            },\n            destroy: () => {\n              if (timeout) {\n                clearTimeout(timeout);\n              }\n            },\n          };\n        },\n        state: {\n          init() {\n            return {\n              // Block attributes, by block ID, from just before the previous transaction.\n              prevTransactionOldBlockAttrs: {} as any,\n              // Block attributes, by block ID, from just before the current transaction.\n              currentTransactionOldBlockAttrs: {} as any,\n              // Set of IDs of blocks whose attributes changed from the current transaction.\n              updatedBlocks: new Set<string>(),\n            };\n          },\n\n          apply(transaction, prev, oldState, newState) {\n            prev.currentTransactionOldBlockAttrs = {};\n            prev.updatedBlocks.clear();\n\n            if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n              return prev;\n            }\n\n            // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n            //  also probably require checking nodes affected by the previous transaction too.\n            // We didn't get this to work yet:\n            // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n            // // const { mapping } = transform;\n            // const changes = getChangedRanges(transform);\n            //\n            // changes.forEach(({ oldRange, newRange }) => {\n            // const oldNodes = findChildrenInRange(\n            //   oldState.doc,\n            //   oldRange,\n            //   (node) => node.attrs.id\n            // );\n            //\n            // const newNodes = findChildrenInRange(\n            //   newState.doc,\n            //   newRange,\n            //   (node) => node.attrs.id\n            // );\n\n            const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n            const oldNodes = findChildren(\n              oldState.doc,\n              (node) => node.attrs.id,\n            );\n            const oldNodesById = new Map(\n              oldNodes.map((node) => [node.node.attrs.id, node]),\n            );\n            const newNodes = findChildren(\n              newState.doc,\n              (node) => node.attrs.id,\n            );\n\n            // Traverses all block containers in the new editor state.\n            for (const node of newNodes) {\n              const oldNode = oldNodesById.get(node.node.attrs.id);\n\n              const oldContentNode = oldNode?.node.firstChild;\n              const newContentNode = node.node.firstChild;\n\n              if (oldNode && oldContentNode && newContentNode) {\n                const newAttrs = {\n                  index: newContentNode.attrs.index,\n                  level: newContentNode.attrs.level,\n                  type: newContentNode.type.name,\n                  depth: newState.doc.resolve(node.pos).depth,\n                };\n\n                const oldAttrs = {\n                  index: oldContentNode.attrs.index,\n                  level: oldContentNode.attrs.level,\n                  type: oldContentNode.type.name,\n                  depth: oldState.doc.resolve(oldNode.pos).depth,\n                };\n\n                currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                prev.currentTransactionOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                // TODO: faster deep equal?\n                if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n                  (oldAttrs as any)[\"depth-change\"] =\n                    oldAttrs.depth - newAttrs.depth;\n\n                  // for debugging:\n                  // console.log(\n                  //   \"id:\",\n                  //   node.node.attrs.id,\n                  //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n                  //   oldAttrs,\n                  //   \"new\",\n                  //   newAttrs\n                  // );\n\n                  prev.updatedBlocks.add(node.node.attrs.id);\n                }\n              }\n            }\n\n            prev.prevTransactionOldBlockAttrs =\n              currentTransactionOriginalOldBlockAttrs;\n\n            return prev;\n          },\n        },\n        props: {\n          decorations(state) {\n            const pluginState = (this as Plugin).getState(state);\n            if (pluginState.updatedBlocks.size === 0) {\n              return undefined;\n            }\n\n            const decorations: Decoration[] = [];\n\n            state.doc.descendants((node, pos) => {\n              if (!node.attrs.id) {\n                return;\n              }\n\n              if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n                return;\n              }\n\n              const prevAttrs =\n                pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n              const decorationAttrs: any = {};\n\n              for (const [nodeAttr, val] of Object.entries(prevAttrs)) {\n                decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n                  val || \"none\";\n              }\n\n              // for debugging:\n              // console.log(\n              //   \"previousBlockTypePlugin committing decorations\",\n              //   decorationAttrs\n              // );\n\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                ...decorationAttrs,\n              });\n\n              decorations.push(decoration);\n            });\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    ],\n  } as const;\n});\n","import { EditorView } from \"prosemirror-view\";\n\nexport function getDraggableBlockFromElement(\n  element: Element,\n  view: EditorView,\n) {\n  while (\n    element &&\n    element.parentElement &&\n    element.parentElement !== view.dom &&\n    element.getAttribute?.(\"data-node-type\") !== \"blockContainer\"\n  ) {\n    element = element.parentElement;\n  }\n  if (element.getAttribute?.(\"data-node-type\") !== \"blockContainer\") {\n    return undefined;\n  }\n  return { node: element as HTMLElement, id: element.getAttribute(\"data-id\")! };\n}\n","import { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Selection } from \"prosemirror-state\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    const fromResult = mapping.mapResult(this.from);\n    const toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos),\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"multiple-node\", anchor: this.anchor, head: this.head };\n  }\n}\n\nSelection.jsonID(\"multiple-node\", MultipleNodeSelection);\n","import { Node } from \"prosemirror-model\";\nimport { NodeSelection, Selection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../api/nodeConversions/fragmentToBlocks.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection.js\";\n\nlet dragImageElement: Element | undefined;\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!,\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!,\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage(view.root);\n  dragImageElement = parentClone;\n\n  // Browsers may have CORS policies which prevents iframes from being\n  // manipulated, so better to stay on the safe side and remove them from the\n  // drag preview. The drag preview doesn't work with iframes anyway.\n  const iframes = dragImageElement.getElementsByTagName(\"iframe\");\n  for (let i = 0; i < iframes.length; i++) {\n    const iframe = iframes[i];\n    const parent = iframe.parentElement;\n\n    if (parent) {\n      parent.removeChild(iframe);\n    }\n  }\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        className !== \"ProseMirror\" &&\n        className !== \"bn-root\" &&\n        className !== \"bn-editor\",\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className + \" bn-drag-preview \" + inheritedClasses;\n\n  if (view.root instanceof ShadowRoot) {\n    view.root.appendChild(dragImageElement);\n  } else {\n    view.root.body.appendChild(dragImageElement);\n  }\n}\n\nexport function unsetDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement !== undefined) {\n    if (rootEl instanceof ShadowRoot) {\n      rootEl.removeChild(dragImageElement);\n    } else {\n      rootEl.body.removeChild(dragImageElement);\n    }\n\n    dragImageElement = undefined;\n  }\n}\n\nexport function dragStart<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  e: { dataTransfer: DataTransfer | null; clientY: number },\n  block: Block<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  if (editor.headless) {\n    return;\n  }\n  const view = editor.prosemirrorView;\n\n  const posInfo = getNodeById(block.id, view.state.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${block.id} not found`);\n  }\n  const pos = posInfo.posBeforeNode;\n\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to)),\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos)),\n      );\n      setDragImage(view, pos);\n    }\n\n    const selectedSlice = view.state.selection.content();\n    const schema = editor.pmSchema;\n\n    const clipboardHTML =\n      view.serializeForClipboard(selectedSlice).dom.innerHTML;\n\n    const externalHTMLExporter = createExternalHTMLExporter(schema, editor);\n\n    const blocks = fragmentToBlocks(selectedSlice.content);\n    const externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n\n    const plainText = cleanHTMLToMarkdown(externalHTML);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"blocknote/html\", clipboardHTML);\n    e.dataTransfer.setData(\"text/html\", externalHTML);\n    e.dataTransfer.setData(\"text/plain\", plainText);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n  }\n}\n","import { DOMParser, Slice } from \"@tiptap/pm/model\";\nimport {\n  EditorState,\n  Plugin,\n  PluginKey,\n  PluginView,\n  TextSelection,\n} from \"@tiptap/pm/state\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\nimport { dragStart, unsetDragImage } from \"./dragging.js\";\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nconst DISTANCE_TO_CONSIDER_EDITOR_BOUNDS = 250;\n\nfunction getBlockFromCoords(\n  view: EditorView,\n  coords: { left: number; top: number },\n  adjustForColumns = true,\n) {\n  const elements = view.root.elementsFromPoint(coords.left, coords.top);\n\n  for (const element of elements) {\n    if (!view.dom.contains(element)) {\n      // probably a ui overlay like formatting toolbar etc\n      continue;\n    }\n    if (adjustForColumns) {\n      const column = element.closest(\"[data-node-type=columnList]\");\n      if (column) {\n        return getBlockFromCoords(\n          view,\n          {\n            // TODO can we do better than this?\n            left: coords.left + 50, // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself\n            top: coords.top,\n          },\n          false,\n        );\n      }\n    }\n    return getDraggableBlockFromElement(element, view);\n  }\n  return undefined;\n}\n\nfunction getBlockFromMousePos(\n  mousePos: {\n    x: number;\n    y: number;\n  },\n  view: EditorView,\n): { node: HTMLElement; id: string } | undefined {\n  // Editor itself may have padding or other styling which affects\n  // size/position, so we get the boundingRect of the first child (i.e. the\n  // blockGroup that wraps all blocks in the editor) for more accurate side\n  // menu placement.\n  if (!view.dom.firstChild) {\n    return;\n  }\n\n  const editorBoundingBox = (\n    view.dom.firstChild as HTMLElement\n  ).getBoundingClientRect();\n\n  // Gets block at mouse cursor's position.\n  const coords = {\n    // Clamps the x position to the editor's bounding box.\n    left: Math.min(\n      Math.max(editorBoundingBox.left + 10, mousePos.x),\n      editorBoundingBox.right - 10,\n    ),\n    top: mousePos.y,\n  };\n\n  const referenceBlock = getBlockFromCoords(view, coords);\n\n  if (!referenceBlock) {\n    // could not find the reference block\n    return undefined;\n  }\n\n  /**\n   * Because blocks may be nested, we need to check the right edge of the parent block:\n   * ```\n   * | BlockA        |\n   * x | BlockB     y|\n   * ```\n   * Hovering at position x (left edge of BlockB) would return BlockA.\n   * Instead, we check at position y (right edge of BlockA) to correctly identify BlockB.\n   */\n  const referenceBlocksBoundingBox =\n    referenceBlock.node.getBoundingClientRect();\n  return getBlockFromCoords(\n    view,\n    {\n      left: referenceBlocksBoundingBox.right - 10,\n      top: mousePos.y,\n    },\n    false,\n  );\n}\n\n/**\n * With the sidemenu plugin we can position a menu next to a hovered block.\n */\nexport class SideMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> implements PluginView\n{\n  public state?: SideMenuState<BSchema, I, S>;\n  public readonly emitUpdate: (state: SideMenuState<BSchema, I, S>) => void;\n\n  private mousePos: { x: number; y: number } | undefined;\n\n  private hoveredBlock: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public isDragOrigin = false;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: SideMenuState<BSchema, I, S>) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.pmView.root.addEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.addEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    this.pmView.root.addEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n\n    // Hides and unfreezes the menu whenever the user presses a key.\n    this.pmView.root.addEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n  }\n\n  updateState = (state: SideMenuState<BSchema, I, S>) => {\n    this.state = state;\n    this.emitUpdate(this.state);\n  };\n\n  updateStateFromMousePos = () => {\n    if (this.menuFrozen || !this.mousePos) {\n      return;\n    }\n\n    const closestEditor = this.findClosestEditorElement({\n      clientX: this.mousePos.x,\n      clientY: this.mousePos.y,\n    });\n\n    if (\n      closestEditor?.element !== this.pmView.dom ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n      return;\n    }\n\n    const block = getBlockFromMousePos(this.mousePos, this.pmView);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.state?.show &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      const blockContentBoundingBox = block.node.getBoundingClientRect();\n      const column = block.node.closest(\"[data-node-type=column]\");\n      this.state = {\n        show: true,\n        referencePos: new DOMRect(\n          column\n            ? // We take the first child as column elements have some default\n              // padding. This is a little weird since this child element will\n              // be the first block, but since it's always non-nested and we\n              // only take the x coordinate, it's ok.\n              column.firstElementChild!.getBoundingClientRect().x\n            : (\n                this.pmView.dom.firstChild as HTMLElement\n              ).getBoundingClientRect().x,\n          blockContentBoundingBox.y,\n          blockContentBoundingBox.width,\n          blockContentBoundingBox.height,\n        ),\n        block: this.editor.getBlock(\n          this.hoveredBlock!.getAttribute(\"data-id\")!,\n        )!,\n      };\n      this.updateState(this.state);\n    }\n  };\n\n  /**\n   * If a block is being dragged, ProseMirror usually gets the context of what's\n   * being dragged from `view.dragging`, which is automatically set when a\n   * `dragstart` event fires in the editor. However, if the user tries to drag\n   * and drop blocks between multiple editors, only the one in which the drag\n   * began has that context, so we need to set it on the others manually. This\n   * ensures that PM always drops the blocks in between other blocks, and not\n   * inside them.\n   *\n   * After the `dragstart` event fires on the drag handle, it sets\n   * `blocknote/html` data on the clipboard. This handler fires right after,\n   * parsing the `blocknote/html` data into nodes and setting them on\n   * `view.dragging`.\n   *\n   * Note: Setting `view.dragging` on `dragover` would be better as the user\n   * could then drag between editors in different windows, but you can only\n   * access `dataTransfer` contents on `dragstart` and `drop` events.\n   */\n  onDragStart = (event: DragEvent) => {\n    const html = event.dataTransfer?.getData(\"blocknote/html\");\n    if (!html) {\n      return;\n    }\n\n    if (this.pmView.dragging) {\n      // already dragging, so no-op\n      return;\n    }\n\n    const element = document.createElement(\"div\");\n    element.innerHTML = html;\n\n    const parser = DOMParser.fromSchema(this.pmView.state.schema);\n    const node = parser.parse(element, {\n      topNode: this.pmView.state.schema.nodes[\"blockGroup\"].create(),\n    });\n\n    this.pmView.dragging = {\n      slice: new Slice(node.content, 0, 0),\n      move: true,\n    };\n  };\n\n  /**\n   * Finds the closest editor visually to the given coordinates\n   */\n  private findClosestEditorElement = (coords: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    // Get all editor elements in the document\n    const editors = Array.from(this.pmView.root.querySelectorAll(\".bn-editor\"));\n\n    if (editors.length === 0) {\n      return null;\n    }\n\n    // Find the editor with the smallest distance to the coordinates\n    let closestEditor = editors[0];\n    let minDistance = Number.MAX_VALUE;\n\n    editors.forEach((editor) => {\n      const rect = editor\n        .querySelector(\".bn-block-group\")!\n        .getBoundingClientRect();\n\n      const distanceX =\n        coords.clientX < rect.left\n          ? rect.left - coords.clientX\n          : coords.clientX > rect.right\n            ? coords.clientX - rect.right\n            : 0;\n\n      const distanceY =\n        coords.clientY < rect.top\n          ? rect.top - coords.clientY\n          : coords.clientY > rect.bottom\n            ? coords.clientY - rect.bottom\n            : 0;\n\n      const distance = Math.sqrt(\n        Math.pow(distanceX, 2) + Math.pow(distanceY, 2),\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestEditor = editor;\n      }\n    });\n\n    return {\n      element: closestEditor,\n      distance: minDistance,\n    };\n  };\n\n  /**\n   * This dragover event handler listens at the document level,\n   * and is trying to handle dragover events for all editors.\n   *\n   * It specifically is trying to handle the following cases:\n   *  - If the dragover event is within the bounds of any editor, then it does nothing\n   *  - If the dragover event is outside the bounds of any editor, but close enough (within DISTANCE_TO_CONSIDER_EDITOR_BOUNDS) to the closest editor,\n   *    then it dispatches a synthetic dragover event to the closest editor (which will trigger the drop-cursor to be shown on that editor)\n   *  - If the dragover event is outside the bounds of the current editor, then it will dispatch a synthetic dragleave event to the current editor\n   *    (which will trigger the drop-cursor to be removed from the current editor)\n   *\n   * The synthetic event is a necessary evil because we do not control prosemirror-dropcursor to be able to show the drop-cursor within the range we want\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const dragEventContext = this.getDragEventContext(event);\n\n    if (!dragEventContext || !dragEventContext.isDropPoint) {\n      // This is not a drag event that we are interested in\n      // so, we close the drop-cursor\n      this.closeDropCursor();\n      return;\n    }\n\n    if (\n      dragEventContext.isDropPoint &&\n      !dragEventContext.isDropWithinEditorBounds\n    ) {\n      // we are the drop point, but the drag over event is not within the bounds of this editor instance\n      // so, we need to dispatch an event that is in the bounds of this editor instance\n      this.dispatchSyntheticEvent(event);\n    }\n  };\n\n  /**\n   * Closes the drop-cursor for the current editor\n   */\n  private closeDropCursor = () => {\n    const evt = new Event(\"dragleave\", { bubbles: false });\n    // It needs to be synthetic, so we don't accidentally think it is a real dragend event\n    (evt as any).synthetic = true;\n    // We dispatch the event to the current editor, so that the drop-cursor is removed for it\n    this.pmView.dom.dispatchEvent(evt);\n  };\n\n  /**\n   * It is surprisingly difficult to determine the information we need to know about a drag event\n   *\n   * This function is trying to determine the following:\n   *  - Whether the current editor instance is the drop point\n   *  - Whether the current editor instance is the drag origin\n   *  - Whether the drop event is within the bounds of the current editor instance\n   */\n  getDragEventContext = (event: DragEvent) => {\n    // We need to check if there is text content that is being dragged (select some text & just drag it)\n    const textContentIsBeingDragged =\n      !event.dataTransfer?.types.includes(\"blocknote/html\") &&\n      !!this.pmView.dragging;\n    // This is the side menu drag from this plugin\n    const sideMenuIsBeingDragged = !!this.isDragOrigin;\n    // Tells us that the current editor instance has a drag ongoing (either text or side menu)\n    const isDragOrigin = textContentIsBeingDragged || sideMenuIsBeingDragged;\n\n    // Tells us which editor instance is the closest to the drag event (whether or not it is actually reasonably close)\n    const closestEditor = this.findClosestEditorElement(event);\n\n    // We arbitrarily decide how far is \"too far\" from the closest editor to be considered a drop point\n    if (\n      !closestEditor ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      // we are too far from the closest editor, or no editor was found\n      return undefined;\n    }\n\n    // We check if the closest editor is the same as the current editor instance (which is the drop point)\n    const isDropPoint = closestEditor.element === this.pmView.dom;\n    // We check if the current editor instance is the same as the editor instance that the drag event is happening within\n    const isDropWithinEditorBounds =\n      isDropPoint && closestEditor.distance === 0;\n\n    // We never want to handle drop events that are not related to us\n    if (!isDropPoint && !isDragOrigin) {\n      // we are not the drop point or drag origin, so not relevant to us\n      return undefined;\n    }\n\n    return {\n      isDropPoint,\n      isDropWithinEditorBounds,\n      isDragOrigin,\n    };\n  };\n\n  /**\n   * The drop event handler listens at the document level,\n   * and handles drop events for all editors.\n   *\n   * It specifically handles the following cases:\n   *  - If we are both the drag origin and drop point:\n   *    - Let normal drop handling take over\n   *  - If we are the drop point but not the drag origin:\n   *    - Collapse selection to prevent PM from deleting unrelated content\n   *    - If drop event is outside our editor bounds, dispatch synthetic drop event to our editor\n   *  - If we are the drag origin but not the drop point:\n   *    - Delete the dragged content from our editor after a delay\n   */\n  onDrop = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const context = this.getDragEventContext(event);\n    if (!context) {\n      this.closeDropCursor();\n      // This is not a drag event that we are interested in\n      return;\n    }\n    const { isDropPoint, isDropWithinEditorBounds, isDragOrigin } = context;\n\n    if (!isDropWithinEditorBounds && isDropPoint) {\n      // Any time that the drop event is outside of the editor bounds (but still close to an editor instance)\n      // We dispatch a synthetic event that is in the bounds of the editor instance, to have the correct drop point\n      this.dispatchSyntheticEvent(event);\n    }\n\n    if (isDropPoint) {\n      // The current instance is the drop point\n\n      if (this.pmView.dragging) {\n        // Do not collapse selection when text content is being dragged\n        return;\n      }\n      // Because the editor selection is unrelated to the dragged content, we\n      // don't want PM to delete its content. Therefore, we collapse the\n      // selection.\n      this.pmView.dispatch(\n        this.pmView.state.tr.setSelection(\n          TextSelection.create(\n            this.pmView.state.tr.doc,\n            this.pmView.state.tr.selection.anchor,\n          ),\n        ),\n      );\n      return;\n    } else if (isDragOrigin) {\n      // The current instance is the drag origin, but not the drop point\n      // our content got dropped somewhere else\n\n      // Because the editor from which the block originates doesn't get a drop\n      // event on it, PM doesn't delete its selected content. Therefore, we\n      // need to do so manually.\n      //\n      // Note: Deleting the selected content from the editor from which the\n      // block originates, may change its height. This can cause the position of\n      // the editor in which the block is being dropping to shift, before it\n      // can handle the drop event. That in turn can cause the drop to happen\n      // somewhere other than the user intended. To get around this, we delay\n      // deleting the selected content until all editors have had the chance to\n      // handle the event.\n      setTimeout(\n        () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),\n        0,\n      );\n      return;\n    }\n  };\n\n  onDragEnd = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n    // When the user starts dragging a block, `view.dragging` is set on all\n    // BlockNote editors. However, when the drag ends, only the editor that the\n    // drag originated in automatically clears `view.dragging`. Therefore, we\n    // have to manually clear it on all editors.\n    this.pmView.dragging = null;\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.state?.show && this.editor.isFocused()) {\n      // Typing in editor should hide side menu\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    this.mousePos = { x: event.clientX, y: event.clientY };\n\n    // We want the full area of the editor to check if the cursor is hovering\n    // above it though.\n    const editorOuterBoundingBox = this.pmView.dom.getBoundingClientRect();\n    const cursorWithinEditor =\n      this.mousePos.x > editorOuterBoundingBox.left &&\n      this.mousePos.x < editorOuterBoundingBox.right &&\n      this.mousePos.y > editorOuterBoundingBox.top &&\n      this.mousePos.y < editorOuterBoundingBox.bottom;\n\n    // TODO: remove parentElement, but then we need to remove padding from boundingbox or find a different solution\n    const editorWrapper = this.pmView.dom!.parentElement!;\n\n    // Doesn't update if the mouse hovers an element that's over the editor but\n    // isn't a part of it or the side menu.\n    if (\n      // Cursor is within the editor area\n      cursorWithinEditor &&\n      // An element is hovered\n      event &&\n      event.target &&\n      // Element is outside the editor\n      !(\n        editorWrapper === event.target ||\n        editorWrapper.contains(event.target as HTMLElement)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate(this.state);\n      }\n\n      return;\n    }\n\n    this.updateStateFromMousePos();\n  };\n\n  private dispatchSyntheticEvent(event: DragEvent) {\n    const evt = new Event(event.type as \"dragover\", event) as any;\n    const dropPointBoundingBox = (\n      this.pmView.dom.firstChild as HTMLElement\n    ).getBoundingClientRect();\n    evt.clientX = event.clientX;\n    evt.clientY = event.clientY;\n\n    evt.clientX = Math.min(\n      Math.max(event.clientX, dropPointBoundingBox.left),\n      dropPointBoundingBox.left + dropPointBoundingBox.width,\n    );\n    evt.clientY = Math.min(\n      Math.max(event.clientY, dropPointBoundingBox.top),\n      dropPointBoundingBox.top + dropPointBoundingBox.height,\n    );\n\n    evt.dataTransfer = event.dataTransfer;\n    evt.preventDefault = () => event.preventDefault();\n    evt.synthetic = true; // prevent recursion\n    this.pmView.dom.dispatchEvent(evt);\n  }\n\n  // Needed in cases where the editor state updates without the mouse cursor\n  // moving, as some state updates can require a side menu update. For example,\n  // adding a button to the side menu which removes the block can cause the\n  // block below to jump up into the place of the removed block when clicked,\n  // allowing the user to click the button again without moving the cursor. This\n  // would otherwise not update the side menu, and so clicking the button again\n  // would attempt to remove the same block again, causing an error.\n  update(_view: EditorView, prevState: EditorState) {\n    const docChanged = !prevState.doc.eq(this.pmView.state.doc);\n    if (docChanged && this.state?.show) {\n      this.updateStateFromMousePos();\n    }\n  }\n\n  destroy() {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n    this.pmView.root.removeEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n  }\n}\n\nexport const sideMenuPluginKey = new PluginKey(\"SideMenuPlugin\");\n\nexport const SideMenuExtension = createExtension(({ editor }) => {\n  let view: SideMenuView<any, any, any> | undefined;\n  const store = createStore<SideMenuState<any, any, any> | undefined>(\n    undefined,\n  );\n\n  return {\n    key: \"sideMenu\",\n    store,\n    prosemirrorPlugins: [\n      new Plugin({\n        key: sideMenuPluginKey,\n        view: (editorView) => {\n          view = new SideMenuView(editor, editorView, (state) => {\n            // TODO: Without spreading the state, in some cases like toggling\n            // `show`, this doesn't trigger an update.\n            store.setState({ ...state });\n          });\n          return view;\n        },\n      }),\n    ],\n\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    blockDragStart(\n      event: { dataTransfer: DataTransfer | null; clientY: number },\n      block: Block<any, any, any>,\n    ) {\n      if (view) {\n        view.isDragOrigin = true;\n      }\n      dragStart(event, block, editor);\n    },\n\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    blockDragEnd() {\n      unsetDragImage(editor.prosemirrorView.root);\n      if (view) {\n        view.isDragOrigin = false;\n      }\n\n      editor.blur();\n    },\n\n    /**\n     * Freezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    freezeMenu() {\n      view!.menuFrozen = true;\n      view!.state!.show = true;\n      view!.emitUpdate(view!.state!);\n    },\n\n    /**\n     * Unfreezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    unfreezeMenu() {\n      view!.menuFrozen = false;\n      view!.state!.show = false;\n      view!.emitUpdate(view!.state!);\n    },\n  } as const;\n});\n","import { EditorState, Plugin, PluginKey, PluginView } from \"prosemirror-state\";\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  deleteColumn,\n  deleteRow,\n  mergeCells,\n  splitCell,\n} from \"prosemirror-tables\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport {\n  RelativeCellIndices,\n  addRowsOrColumns,\n  areInSameColumn,\n  canColumnBeDraggedInto,\n  canRowBeDraggedInto,\n  cropEmptyRowsOrColumns,\n  getCellsAtColumnHandle,\n  getCellsAtRowHandle,\n  getDimensionsOfTable,\n  moveColumn,\n  moveRow,\n} from \"../../api/blockManipulation/tables/tables.js\";\nimport { nodeToBlock } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport {\n  editorHasBlockWithType,\n  isTableCellSelection,\n} from \"../../blocks/defaultBlockTypeGuards.js\";\nimport { DefaultBlockSchema } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  createExtension,\n  createStore,\n} from \"../../editor/BlockNoteExtension.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchemaWithBlock,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\n\nlet dragImageElement: HTMLElement | undefined;\n\n// TODO consider switching this to jotai, it is a bit messy and noisy\nexport type TableHandlesState = {\n  show: boolean;\n  showAddOrRemoveRowsButton: boolean;\n  showAddOrRemoveColumnsButton: boolean;\n  referencePosCell: DOMRect | undefined;\n  referencePosTable: DOMRect;\n\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>;\n  colIndex: number | undefined;\n  rowIndex: number | undefined;\n\n  draggingState:\n    | {\n        draggedCellOrientation: \"row\" | \"col\";\n        originalIndex: number;\n        mousePos: number;\n      }\n    | undefined;\n\n  widgetContainer: HTMLElement | undefined;\n};\n\nfunction setHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    return;\n  }\n\n  dragImageElement = document.createElement(\"div\");\n  dragImageElement.innerHTML = \"_\";\n  dragImageElement.style.opacity = \"0\";\n  dragImageElement.style.height = \"1px\";\n  dragImageElement.style.width = \"1px\";\n  if (rootEl instanceof Document) {\n    rootEl.body.appendChild(dragImageElement);\n  } else {\n    rootEl.appendChild(dragImageElement);\n  }\n}\n\nfunction unsetHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    if (rootEl instanceof Document) {\n      rootEl.body.removeChild(dragImageElement);\n    } else {\n      rootEl.removeChild(dragImageElement);\n    }\n    dragImageElement = undefined;\n  }\n}\n\nfunction getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\n// Finds the DOM element corresponding to the table cell that the target element\n// is currently in. If the target element is not in a table cell, returns null.\nfunction domCellAround(target: Element) {\n  let currentTarget: Element | undefined = target;\n  while (\n    currentTarget &&\n    currentTarget.nodeName !== \"TD\" &&\n    currentTarget.nodeName !== \"TH\" &&\n    !currentTarget.classList.contains(\"tableWrapper\")\n  ) {\n    if (currentTarget.classList.contains(\"ProseMirror\")) {\n      return undefined;\n    }\n    const parent: ParentNode | null = currentTarget.parentNode;\n\n    if (!parent || !(parent instanceof Element)) {\n      return undefined;\n    }\n    currentTarget = parent;\n  }\n\n  return currentTarget.nodeName === \"TD\" || currentTarget.nodeName === \"TH\"\n    ? {\n        type: \"cell\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.closest(\"tbody\"),\n      }\n    : {\n        type: \"wrapper\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.querySelector(\"tbody\"),\n      };\n}\n\n// Hides elements in the DOMwith the provided class names.\nfunction hideElements(selector: string, rootEl: Document | ShadowRoot) {\n  const elementsToHide = rootEl.querySelectorAll(selector);\n\n  for (let i = 0; i < elementsToHide.length; i++) {\n    (elementsToHide[i] as HTMLElement).style.visibility = \"hidden\";\n  }\n}\n\nexport class TableHandlesView implements PluginView {\n  public state?: TableHandlesState;\n  public emitUpdate: () => void;\n\n  public tableId: string | undefined;\n  public tablePos: number | undefined;\n  public tableElement: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public mouseState: \"up\" | \"down\" | \"selecting\" = \"up\";\n\n  public prevWasEditable: boolean | null = null;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      any,\n      any\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: TableHandlesState) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousemove\", this.mouseMoveHandler);\n    pmView.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    window.addEventListener(\"mouseup\", this.mouseUpHandler);\n\n    pmView.root.addEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    pmView.root.addEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n\n  viewMousedownHandler = () => {\n    this.mouseState = \"down\";\n  };\n\n  mouseUpHandler = (event: MouseEvent) => {\n    this.mouseState = \"up\";\n    this.mouseMoveHandler(event);\n  };\n\n  mouseMoveHandler = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    if (this.mouseState === \"selecting\") {\n      return;\n    }\n\n    if (\n      !(event.target instanceof Element) ||\n      !this.pmView.dom.contains(event.target)\n    ) {\n      return;\n    }\n\n    const target = domCellAround(event.target);\n\n    if (\n      target?.type === \"cell\" &&\n      this.mouseState === \"down\" &&\n      !this.state?.draggingState\n    ) {\n      // hide draghandles when selecting text as they could be in the way of the user\n      this.mouseState = \"selecting\";\n\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target.tbodyNode) {\n      return;\n    }\n\n    const tableRect = target.tbodyNode.getBoundingClientRect();\n\n    const blockEl = getDraggableBlockFromElement(target.domNode, this.pmView);\n    if (!blockEl) {\n      return;\n    }\n    this.tableElement = blockEl.node;\n\n    let tableBlock:\n      | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>\n      | undefined;\n\n    const pmNodeInfo = this.editor.transact((tr) =>\n      getNodeById(blockEl.id, tr.doc),\n    );\n    if (!pmNodeInfo) {\n      throw new Error(`Block with ID ${blockEl.id} not found`);\n    }\n\n    const block = nodeToBlock(\n      pmNodeInfo.node,\n      this.editor.pmSchema,\n      this.editor.schema.blockSchema,\n      this.editor.schema.inlineContentSchema,\n      this.editor.schema.styleSchema,\n    );\n\n    if (editorHasBlockWithType(this.editor, \"table\")) {\n      this.tablePos = pmNodeInfo.posBeforeNode + 1;\n      tableBlock = block;\n    }\n\n    if (!tableBlock) {\n      return;\n    }\n\n    this.tableId = blockEl.id;\n    const widgetContainer = target.domNode\n      .closest(\".tableWrapper\")\n      ?.querySelector(\".table-widgets-container\") as HTMLElement;\n\n    if (target?.type === \"wrapper\") {\n      // if we're just to the right or below the table, show the extend buttons\n      // (this is a bit hacky. It would probably be cleaner to render the extend buttons in the Table NodeView instead)\n      const belowTable =\n        event.clientY >= tableRect.bottom - 1 && // -1 to account for fractions of pixels in \"bottom\"\n        event.clientY < tableRect.bottom + 20;\n      const toRightOfTable =\n        event.clientX >= tableRect.right - 1 &&\n        event.clientX < tableRect.right + 20;\n\n      // without this check, we'd also hide draghandles when hovering over them\n      const hideHandles =\n        event.clientX > tableRect.right || event.clientY > tableRect.bottom;\n\n      this.state = {\n        ...this.state!,\n        show: true,\n        showAddOrRemoveRowsButton: belowTable,\n        showAddOrRemoveColumnsButton: toRightOfTable,\n        referencePosTable: tableRect,\n        block: tableBlock,\n        widgetContainer,\n        colIndex: hideHandles ? undefined : this.state?.colIndex,\n        rowIndex: hideHandles ? undefined : this.state?.rowIndex,\n        referencePosCell: hideHandles\n          ? undefined\n          : this.state?.referencePosCell,\n      };\n    } else {\n      const colIndex = getChildIndex(target.domNode);\n      const rowIndex = getChildIndex(target.domNode.parentElement!);\n      const cellRect = target.domNode.getBoundingClientRect();\n\n      if (\n        this.state !== undefined &&\n        this.state.show &&\n        this.tableId === blockEl.id &&\n        this.state.rowIndex === rowIndex &&\n        this.state.colIndex === colIndex\n      ) {\n        // no update needed\n        return;\n      }\n\n      this.state = {\n        show: true,\n        showAddOrRemoveColumnsButton:\n          colIndex === tableBlock.content.rows[0].cells.length - 1,\n        showAddOrRemoveRowsButton:\n          rowIndex === tableBlock.content.rows.length - 1,\n        referencePosTable: tableRect,\n\n        block: tableBlock,\n        draggingState: undefined,\n        referencePosCell: cellRect,\n        colIndex: colIndex,\n        rowIndex: rowIndex,\n\n        widgetContainer,\n      };\n    }\n    this.emitUpdate();\n\n    return false;\n  };\n\n  dragOverHandler = (event: DragEvent) => {\n    if (this.state?.draggingState === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer!.dropEffect = \"move\";\n\n    hideElements(\n      \".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline\",\n      this.pmView.root,\n    );\n\n    // The mouse cursor coordinates, bounded to the table's bounding box. The\n    // bounding box is shrunk by 1px on each side to ensure that the bounded\n    // coordinates are always inside a table cell.\n    const boundedMouseCoords = {\n      left: Math.min(\n        Math.max(event.clientX, this.state.referencePosTable.left + 1),\n        this.state.referencePosTable.right - 1,\n      ),\n      top: Math.min(\n        Math.max(event.clientY, this.state.referencePosTable.top + 1),\n        this.state.referencePosTable.bottom - 1,\n      ),\n    };\n\n    // Gets the table cell element that the bounded mouse cursor coordinates lie\n    // in.\n    const tableCellElements = this.pmView.root\n      .elementsFromPoint(boundedMouseCoords.left, boundedMouseCoords.top)\n      .filter(\n        (element) => element.tagName === \"TD\" || element.tagName === \"TH\",\n      );\n    if (tableCellElements.length === 0) {\n      return;\n    }\n    const tableCellElement = tableCellElements[0];\n\n    let emitStateUpdate = false;\n\n    // Gets current row and column index.\n    const rowIndex = getChildIndex(tableCellElement.parentElement!);\n    const colIndex = getChildIndex(tableCellElement);\n\n    // Checks if the drop cursor needs to be updated. This affects decorations\n    // only so it doesn't trigger a state update.\n    const oldIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? this.state.rowIndex\n        : this.state.colIndex;\n    const newIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? rowIndex\n        : colIndex;\n    const dispatchDecorationsTransaction = newIndex !== oldIndex;\n\n    // Checks if either the hovered cell has changed and updates the row and\n    // column index. Also updates the reference DOMRect.\n    if (this.state.rowIndex !== rowIndex || this.state.colIndex !== colIndex) {\n      this.state.rowIndex = rowIndex;\n      this.state.colIndex = colIndex;\n\n      this.state.referencePosCell = tableCellElement.getBoundingClientRect();\n\n      emitStateUpdate = true;\n    }\n\n    // Checks if the mouse cursor position along the axis that the user is\n    // dragging on has changed and updates it.\n    const mousePos =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? boundedMouseCoords.top\n        : boundedMouseCoords.left;\n    if (this.state.draggingState.mousePos !== mousePos) {\n      this.state.draggingState.mousePos = mousePos;\n\n      emitStateUpdate = true;\n    }\n\n    // Emits a state update if any of the fields have changed.\n    if (emitStateUpdate) {\n      this.emitUpdate();\n    }\n\n    // Dispatches a dummy transaction to force a decorations update if\n    // necessary.\n    if (dispatchDecorationsTransaction) {\n      this.editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, true));\n    }\n  };\n\n  dropHandler = (event: DragEvent) => {\n    this.mouseState = \"up\";\n    if (this.state === undefined || this.state.draggingState === undefined) {\n      return false;\n    }\n\n    if (\n      this.state.rowIndex === undefined ||\n      this.state.colIndex === undefined\n    ) {\n      throw new Error(\n        \"Attempted to drop table row or column, but no table block was hovered prior.\",\n      );\n    }\n\n    event.preventDefault();\n\n    const { draggingState, colIndex, rowIndex } = this.state;\n\n    const columnWidths = this.state.block.content.columnWidths;\n\n    if (draggingState.draggedCellOrientation === \"row\") {\n      if (\n        !canRowBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          rowIndex,\n        )\n      ) {\n        // If the target row is invalid, don't move the row\n        return false;\n      }\n      const newTable = moveRow(\n        this.state.block,\n        draggingState.originalIndex,\n        rowIndex,\n      );\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          rows: newTable as any,\n        },\n      });\n    } else {\n      if (\n        !canColumnBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          colIndex,\n        )\n      ) {\n        // If the target column is invalid, don't move the column\n        return false;\n      }\n      const newTable = moveColumn(\n        this.state.block,\n        draggingState.originalIndex,\n        colIndex,\n      );\n      const [columnWidth] = columnWidths.splice(draggingState.originalIndex, 1);\n      columnWidths.splice(colIndex, 0, columnWidth);\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          columnWidths,\n          rows: newTable as any,\n        },\n      });\n    }\n\n    // Have to reset text cursor position to the block as `updateBlock` moves\n    // the existing selection out of the block.\n    this.editor.setTextCursorPosition(this.state.block.id);\n\n    return true;\n  };\n  // Updates drag handles when the table is modified or removed.\n  update() {\n    if (!this.state || !this.state.show) {\n      return;\n    }\n\n    // Hide handles if the table block has been removed.\n    this.state.block = this.editor.getBlock(this.state.block.id)!;\n    if (\n      !this.state.block ||\n      this.state.block.type !== \"table\" ||\n      // when collaborating, the table element might be replaced and out of date\n      // because yjs replaces the element when for example you change the color via the side menu\n      !this.tableElement?.isConnected\n    ) {\n      this.state.show = false;\n      this.state.showAddOrRemoveRowsButton = false;\n      this.state.showAddOrRemoveColumnsButton = false;\n      this.emitUpdate();\n\n      return;\n    }\n\n    const { height: rowCount, width: colCount } = getDimensionsOfTable(\n      this.state.block,\n    );\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      // If rows or columns are deleted in the update, the hovered indices for\n      // those may now be out of bounds. If this is the case, they are moved to\n      // the new last row or column.\n      if (this.state.rowIndex >= rowCount) {\n        this.state.rowIndex = rowCount - 1;\n      }\n      if (this.state.colIndex >= colCount) {\n        this.state.colIndex = colCount - 1;\n      }\n    }\n\n    // Update bounding boxes.\n    const tableBody = this.tableElement!.querySelector(\"tbody\");\n\n    if (!tableBody) {\n      throw new Error(\n        \"Table block does not contain a 'tbody' HTML element. This should never happen.\",\n      );\n    }\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      const row = tableBody.children[this.state.rowIndex];\n      const cell = row.children[this.state.colIndex];\n      if (cell) {\n        this.state.referencePosCell = cell.getBoundingClientRect();\n      } else {\n        this.state.rowIndex = undefined;\n        this.state.colIndex = undefined;\n      }\n    }\n    this.state.referencePosTable = tableBody.getBoundingClientRect();\n\n    this.emitUpdate();\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.removeEventListener(\"mouseup\", this.mouseUpHandler);\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n}\n\nexport const tableHandlesPluginKey = new PluginKey(\"TableHandlesPlugin\");\n\nexport const TableHandlesExtension = createExtension(({ editor }) => {\n  let view: TableHandlesView | undefined = undefined;\n\n  const store = createStore<TableHandlesState | undefined>(undefined);\n\n  return {\n    key: \"tableHandles\",\n    store,\n    prosemirrorPlugins: [\n      new Plugin({\n        key: tableHandlesPluginKey,\n        view: (editorView) => {\n          view = new TableHandlesView(editor as any, editorView, (state) => {\n            store.setState({\n              ...state,\n              draggingState: state.draggingState\n                ? { ...state.draggingState }\n                : undefined,\n            });\n          });\n          return view;\n        },\n        // We use decorations to render the drop cursor when dragging a table row\n        // or column. The decorations are updated in the `dragOverHandler` method.\n        props: {\n          decorations: (state) => {\n            if (\n              view === undefined ||\n              view.state === undefined ||\n              view.state.draggingState === undefined ||\n              view.tablePos === undefined\n            ) {\n              return;\n            }\n\n            const newIndex =\n              view.state.draggingState.draggedCellOrientation === \"row\"\n                ? view.state.rowIndex\n                : view.state.colIndex;\n\n            if (newIndex === undefined) {\n              return;\n            }\n\n            const decorations: Decoration[] = [];\n            const { block, draggingState } = view.state;\n            const { originalIndex, draggedCellOrientation } = draggingState;\n\n            // Return empty decorations if:\n            // - Dragging to same position\n            // - No block exists\n            // - Row drag not allowed\n            // - Column drag not allowed\n            if (\n              newIndex === originalIndex ||\n              !block ||\n              (draggedCellOrientation === \"row\" &&\n                !canRowBeDraggedInto(block, originalIndex, newIndex)) ||\n              (draggedCellOrientation === \"col\" &&\n                !canColumnBeDraggedInto(block, originalIndex, newIndex))\n            ) {\n              return DecorationSet.create(state.doc, decorations);\n            }\n\n            // Gets the table to show the drop cursor in.\n            const tableResolvedPos = state.doc.resolve(view.tablePos + 1);\n\n            if (view.state.draggingState.draggedCellOrientation === \"row\") {\n              const cellsInRow = getCellsAtRowHandle(\n                view.state.block,\n                newIndex,\n              );\n\n              cellsInRow.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n                decorations.push(\n                  // The widget is a small bar which spans the width of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.left = \"0\";\n                    widget.style.right = \"0\";\n                    // This is only necessary because the drop indicator's height\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the row is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.bottom = \"-2px\";\n                    } else {\n                      widget.style.top = \"-3px\";\n                    }\n                    widget.style.height = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            } else {\n              const cellsInColumn = getCellsAtColumnHandle(\n                view.state.block,\n                newIndex,\n              );\n\n              cellsInColumn.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n\n                decorations.push(\n                  // The widget is a small bar which spans the height of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.top = \"0\";\n                    widget.style.bottom = \"0\";\n                    // This is only necessary because the drop indicator's width\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the column is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.right = \"-2px\";\n                    } else {\n                      widget.style.left = \"-3px\";\n                    }\n                    widget.style.width = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            }\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    ],\n\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the column drag handle.\n     */\n    colDragStart(event: {\n      dataTransfer: DataTransfer | null;\n      clientX: number;\n    }) {\n      if (\n        view === undefined ||\n        view.state === undefined ||\n        view.state.colIndex === undefined\n      ) {\n        throw new Error(\n          \"Attempted to drag table column, but no table block was hovered prior.\",\n        );\n      }\n\n      view.state.draggingState = {\n        draggedCellOrientation: \"col\",\n        originalIndex: view.state.colIndex,\n        mousePos: event.clientX,\n      };\n      view.emitUpdate();\n\n      editor.transact((tr) =>\n        tr.setMeta(tableHandlesPluginKey, {\n          draggedCellOrientation:\n            view!.state!.draggingState!.draggedCellOrientation,\n          originalIndex: view!.state!.colIndex,\n          newIndex: view!.state!.colIndex,\n          tablePos: view!.tablePos,\n        }),\n      );\n\n      if (editor.headless) {\n        return;\n      }\n\n      setHiddenDragImage(editor.prosemirrorView.root);\n      event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n      event.dataTransfer!.effectAllowed = \"move\";\n    },\n\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the row drag handle.\n     */\n    rowDragStart(event: {\n      dataTransfer: DataTransfer | null;\n      clientY: number;\n    }) {\n      if (view!.state === undefined || view!.state.rowIndex === undefined) {\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\",\n        );\n      }\n\n      view!.state.draggingState = {\n        draggedCellOrientation: \"row\",\n        originalIndex: view!.state.rowIndex,\n        mousePos: event.clientY,\n      };\n      view!.emitUpdate();\n\n      editor.transact((tr) =>\n        tr.setMeta(tableHandlesPluginKey, {\n          draggedCellOrientation:\n            view!.state!.draggingState!.draggedCellOrientation,\n          originalIndex: view!.state!.rowIndex,\n          newIndex: view!.state!.rowIndex,\n          tablePos: view!.tablePos,\n        }),\n      );\n\n      if (editor.headless) {\n        return;\n      }\n\n      setHiddenDragImage(editor.prosemirrorView.root);\n      event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n      event.dataTransfer!.effectAllowed = \"copyMove\";\n    },\n\n    /**\n     * Callback that should be set on the `dragEnd` event for both the element\n     * used as the row drag handle, and the one used as the column drag handle.\n     */\n    dragEnd() {\n      if (view!.state === undefined) {\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\",\n        );\n      }\n\n      view!.state.draggingState = undefined;\n      view!.emitUpdate();\n\n      editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, null));\n\n      if (editor.headless) {\n        return;\n      }\n\n      unsetHiddenDragImage(editor.prosemirrorView.root);\n    },\n\n    /**\n     * Freezes the drag handles. When frozen, they will stay attached to the same\n     * cell regardless of which cell is hovered by the mouse cursor.\n     */\n    freezeHandles() {\n      view!.menuFrozen = true;\n    },\n\n    /**\n     * Unfreezes the drag handles. When frozen, they will stay attached to the\n     * same cell regardless of which cell is hovered by the mouse cursor.\n     */\n    unfreezeHandles() {\n      view!.menuFrozen = false;\n    },\n\n    getCellsAtRowHandle(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      relativeRowIndex: RelativeCellIndices[\"row\"],\n    ) {\n      return getCellsAtRowHandle(block, relativeRowIndex);\n    },\n\n    /**\n     * Get all the cells in a column of the table block.\n     */\n    getCellsAtColumnHandle(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      relativeColumnIndex: RelativeCellIndices[\"col\"],\n    ) {\n      return getCellsAtColumnHandle(block, relativeColumnIndex);\n    },\n\n    /**\n     * Sets the selection to the given cell or a range of cells.\n     * @returns The new state after the selection has been set.\n     */\n    setCellSelection(\n      state: EditorState,\n      relativeStartCell: RelativeCellIndices,\n      relativeEndCell: RelativeCellIndices = relativeStartCell,\n    ) {\n      if (!view) {\n        throw new Error(\"Table handles view not initialized\");\n      }\n\n      const tableResolvedPos = state.doc.resolve(view.tablePos! + 1);\n      const startRowResolvedPos = state.doc.resolve(\n        tableResolvedPos.posAtIndex(relativeStartCell.row) + 1,\n      );\n      const startCellResolvedPos = state.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        startRowResolvedPos.posAtIndex(relativeStartCell.col),\n      );\n      const endRowResolvedPos = state.doc.resolve(\n        tableResolvedPos.posAtIndex(relativeEndCell.row) + 1,\n      );\n      const endCellResolvedPos = state.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        endRowResolvedPos.posAtIndex(relativeEndCell.col),\n      );\n\n      // Begin a new transaction to set the selection\n      const tr = state.tr;\n\n      // Set the selection to the given cell or a range of cells\n      tr.setSelection(\n        new CellSelection(startCellResolvedPos, endCellResolvedPos),\n      );\n\n      // Quickly apply the transaction to get the new state to update the selection before splitting the cell\n      return state.apply(tr);\n    },\n\n    /**\n     * Adds a row or column to the table using prosemirror-table commands\n     */\n    addRowOrColumn(\n      index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n      direction:\n        | { orientation: \"row\"; side: \"above\" | \"below\" }\n        | { orientation: \"column\"; side: \"left\" | \"right\" },\n    ) {\n      editor.exec((beforeState, dispatch) => {\n        const state = this.setCellSelection(\n          beforeState,\n          direction.orientation === \"row\"\n            ? { row: index, col: 0 }\n            : { row: 0, col: index },\n        );\n\n        if (direction.orientation === \"row\") {\n          if (direction.side === \"above\") {\n            return addRowBefore(state, dispatch);\n          } else {\n            return addRowAfter(state, dispatch);\n          }\n        } else {\n          if (direction.side === \"left\") {\n            return addColumnBefore(state, dispatch);\n          } else {\n            return addColumnAfter(state, dispatch);\n          }\n        }\n      });\n    },\n\n    /**\n     * Removes a row or column from the table using prosemirror-table commands\n     */\n    removeRowOrColumn(\n      index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n      direction: \"row\" | \"column\",\n    ) {\n      if (direction === \"row\") {\n        return editor.exec((beforeState, dispatch) => {\n          const state = this.setCellSelection(beforeState, {\n            row: index,\n            col: 0,\n          });\n          return deleteRow(state, dispatch);\n        });\n      } else {\n        return editor.exec((beforeState, dispatch) => {\n          const state = this.setCellSelection(beforeState, {\n            row: 0,\n            col: index,\n          });\n          return deleteColumn(state, dispatch);\n        });\n      }\n    },\n\n    /**\n     * Merges the cells in the table block.\n     */\n    mergeCells(cellsToMerge?: {\n      relativeStartCell: RelativeCellIndices;\n      relativeEndCell: RelativeCellIndices;\n    }) {\n      return editor.exec((beforeState, dispatch) => {\n        const state = cellsToMerge\n          ? this.setCellSelection(\n              beforeState,\n              cellsToMerge.relativeStartCell,\n              cellsToMerge.relativeEndCell,\n            )\n          : beforeState;\n\n        return mergeCells(state, dispatch);\n      });\n    },\n\n    /**\n     * Splits the cell in the table block.\n     * If no cell is provided, the current cell selected will be split.\n     */\n    splitCell(relativeCellToSplit?: RelativeCellIndices) {\n      return editor.exec((beforeState, dispatch) => {\n        const state = relativeCellToSplit\n          ? this.setCellSelection(beforeState, relativeCellToSplit)\n          : beforeState;\n\n        return splitCell(state, dispatch);\n      });\n    },\n\n    /**\n     * Gets the start and end cells of the current cell selection.\n     * @returns The start and end cells of the current cell selection.\n     */\n    getCellSelection():\n      | undefined\n      | {\n          from: RelativeCellIndices;\n          to: RelativeCellIndices;\n          /**\n           * All of the cells that are within the selected range.\n           */\n          cells: RelativeCellIndices[];\n        } {\n      // Based on the current selection, find the table cells that are within the selected range\n\n      return editor.transact((tr) => {\n        const selection = tr.selection;\n\n        let $fromCell = selection.$from;\n        let $toCell = selection.$to;\n        if (isTableCellSelection(selection)) {\n          // When the selection is a table cell selection, we can find the\n          // from and to cells by iterating over the ranges in the selection\n          const { ranges } = selection;\n          ranges.forEach((range) => {\n            $fromCell = range.$from.min($fromCell ?? range.$from);\n            $toCell = range.$to.max($toCell ?? range.$to);\n          });\n        } else {\n          // When the selection is a normal text selection\n          // Assumes we are within a tableParagraph\n          // And find the from and to cells by resolving the positions\n          $fromCell = tr.doc.resolve(\n            selection.$from.pos - selection.$from.parentOffset - 1,\n          );\n          $toCell = tr.doc.resolve(\n            selection.$to.pos - selection.$to.parentOffset - 1,\n          );\n\n          // Opt-out when the selection is not pointing into cells\n          if ($fromCell.pos === 0 || $toCell.pos === 0) {\n            return undefined;\n          }\n        }\n\n        // Find the row and table that the from and to cells are in\n        const $fromRow = tr.doc.resolve(\n          $fromCell.pos - $fromCell.parentOffset - 1,\n        );\n        const $toRow = tr.doc.resolve($toCell.pos - $toCell.parentOffset - 1);\n\n        // Find the table\n        const $table = tr.doc.resolve($fromRow.pos - $fromRow.parentOffset - 1);\n\n        // Find the column and row indices of the from and to cells\n        const fromColIndex = $fromCell.index($fromRow.depth);\n        const fromRowIndex = $fromRow.index($table.depth);\n        const toColIndex = $toCell.index($toRow.depth);\n        const toRowIndex = $toRow.index($table.depth);\n\n        const cells: RelativeCellIndices[] = [];\n        for (let row = fromRowIndex; row <= toRowIndex; row++) {\n          for (let col = fromColIndex; col <= toColIndex; col++) {\n            cells.push({ row, col });\n          }\n        }\n\n        return {\n          from: {\n            row: fromRowIndex,\n            col: fromColIndex,\n          },\n          to: {\n            row: toRowIndex,\n            col: toColIndex,\n          },\n          cells,\n        };\n      });\n    },\n\n    /**\n     * Gets the direction of the merge based on the current cell selection.\n     *\n     * Returns undefined when there is no cell selection, or the selection is not within a table.\n     */\n    getMergeDirection(\n      block:\n        | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>\n        | undefined,\n    ) {\n      return editor.transact((tr) => {\n        const isSelectingTableCells = isTableCellSelection(tr.selection)\n          ? tr.selection\n          : undefined;\n\n        if (\n          !isSelectingTableCells ||\n          !block ||\n          // Only offer the merge button if there is more than one cell selected.\n          isSelectingTableCells.ranges.length <= 1\n        ) {\n          return undefined;\n        }\n\n        const cellSelection = this.getCellSelection();\n\n        if (!cellSelection) {\n          return undefined;\n        }\n\n        if (areInSameColumn(cellSelection.from, cellSelection.to, block)) {\n          return \"vertical\";\n        }\n\n        return \"horizontal\";\n      });\n    },\n\n    cropEmptyRowsOrColumns(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      removeEmpty: \"columns\" | \"rows\",\n    ) {\n      return cropEmptyRowsOrColumns(block, removeEmpty);\n    },\n\n    addRowsOrColumns(\n      block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n      addType: \"columns\" | \"rows\",\n      numToAdd: number,\n    ) {\n      return addRowsOrColumns(block, addType, numToAdd);\n    },\n  } as const;\n});\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { createExtension } from \"../../editor/BlockNoteExtension.js\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\nconst plugin = new PluginKey(\"trailingNode\");\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNodeExtension = createExtension(() => {\n  return {\n    key: \"trailingNode\",\n    prosemirrorPlugins: [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create()),\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              return true; // not a blockContainer, but for example Columns. Insert trailing node\n            }\n\n            const lastContentNode = lastNode.firstChild;\n\n            if (!lastContentNode) {\n              throw new Error(\"Expected blockContent\");\n            }\n\n            // If last node is not empty (size > 4) or it doesn't contain\n            // inline content, we need to add a trailing node.\n            return (\n              lastNode.nodeSize > 4 ||\n              lastContentNode.type.spec.content !== \"inline*\"\n            );\n          },\n        },\n      }),\n    ],\n  } as const;\n});\n"],"names":["addAttributesAndRemoveClasses","element","className","serializeInlineContentExternalHTML","editor","blockContent","serializer","options","nodes","inlineContentToNodes","tableContentToNodes","UnreachableCaseError","fragment","node","inlineContentImplementation","inlineContent","nodeToCustomInlineContent","output","contentFragment","dom","mark","newDom","domOutputSpec","DOMSerializer","nodeFragment","Fragment","_a","serializeBlock","block","orderedListItemBlockTypes","unorderedListItemBlockTypes","doc","BC_NODE","props","name","spec","bc","_b","attrs","blockImplementation","ret","_c","elementFragment","blockContentDataAttributes","attr","ic","listType","_d","list","childFragment","serializeBlocksToFragment","_e","_f","_g","_h","_i","blocks","serializeBlocksExternalHTML","createExternalHTMLExporter","schema","html","div","domFragment","parent","getParentBlockId","pos","resolvedPos","i","isNodeBlock","determineChangeSource","transaction","collectSnapshot","ROOT_KEY","byId","childrenByParent","pmSchema","getPmSchema","parentId","key","nodeToBlock","detectReorderedChildren","prevOrder","nextOrder","moved","prevIds","commonNext","id","commonPrev","indexInPrev","sequence","n","tailsValues","tailsEndsAtIndex","previousIndexInLis","lowerBound","arr","target","lo","hi","mid","value","lisIndexSet","k","getBlocksChangedByTransaction","appendedTransactions","source","combinedTransaction","combineTransactionSteps","prevSnap","nextSnap","changes","changedIds","prev","next","deepEqual","prevOrderByParent","nextOrderByParent","parents","addedMoveForId","parentKey","movedWithinParent","removeUnderlines","removeUnderlinesHelper","tree","numChildElements","numElementsAdded","addSpacesToCheckboxes","helper","child","nextChild","fromDom","convertVideoToMarkdown","visit","index","src","cleanHTMLToMarkdown","cleanHTMLString","unified","rehypeParse","rehypeRemark","remarkGfm","remarkStringify","blocksToMarkdown","externalHTML","fragmentToBlocks","BlockChangeExtension","createExtension","beforeChangeCallbacks","Plugin","PluginKey","tr","acc","cb","callback","isDarkColor","bgColor","color","r","g","b","c","col","defaultCursorRender","user","cursorElement","caretElement","labelElement","YCursorExtension","recentlyUpdatedCursors","updated","clientID","cursor","yCursorPlugin","defaultSelectionBuilder","cursorData","YSyncExtension","ySyncPlugin","YUndoExtension","yUndoPlugin","undoCommand","redoCommand","findTypeInOtherYdoc","ytype","otherYdoc","ydoc","rootKey","ytypeItem","otherStructs","itemIndex","Y","ForkYDocExtension","forkedState","store","createStore","originalFragment","forkedFragment","yUndoPluginKey","newOptions","keepChanges","undoStack","update","traverseElement","rootElement","moveColorAttributes","targetBlockContainers","textColor","backgroundColor","colors","defaultProps","el","migrationRules","SchemaMigration","migrationDone","pluginKey","transactions","_oldState","newState","migrationRule","DropCursorExtension","dropCursor","FormattingToolbarExtension","shouldShow","NodeSelection","TextSelection","spansCode","signal","preventShowWhileMouseDown","unsubscribeOnChange","unsubscribeOnSelectionChange","HistoryExtension","history","undo","redo","LinkToolbarExtension","getLinkElementAtPos","currentNode","getMarkAtPos","markType","markRange","getMarkRange","posToDOMRect","getLinkAtSelection","selection","posAtElement","url","text","position","range","VALID_LINK_PROTOCOLS","DEFAULT_LINK_PROTOCOL","PLUGIN_KEY","NodeSelectionKeyboardExtension","view","event","PlaceholderExtension","placeholders","uniqueEditorSelector","v4","styleEl","nonce","styleSheet","getSelector","additionalSelectors","defaultPlaceholder","emptyPlaceholder","rest","blockType","placeholder","blockTypeSelector","onlyBlockSelector","mustBeFocusedSelector","e","state","decs","Decoration","$pos","before","DecorationSet","nodeAttributes","PreviousBlockTypeExtension","timeout","_editorView","_prevState","oldState","currentTransactionOriginalOldBlockAttrs","oldNodes","findChildren","oldNodesById","newNodes","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","pluginState","decorations","prevAttrs","decorationAttrs","nodeAttr","val","decoration","getDraggableBlockFromElement","MultipleNodeSelection","Selection","$anchor","$head","__publicField","parentNode","_pos","from","to","Slice","mapping","fromResult","toResult","dragImageElement","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","iframes","iframe","inheritedClasses","rootEl","dragStart","posInfo","getNodeById","draggedBlockInSelection","multipleBlocksSelected","selectedSlice","clipboardHTML","externalHTMLExporter","plainText","DISTANCE_TO_CONSIDER_EDITOR_BOUNDS","getBlockFromCoords","coords","adjustForColumns","elements","getBlockFromMousePos","mousePos","editorBoundingBox","referenceBlock","referenceBlocksBoundingBox","SideMenuView","pmView","emitUpdate","closestEditor","blockContentBoundingBox","column","DOMParser","editors","minDistance","rect","distanceX","distanceY","distance","dragEventContext","evt","textContentIsBeingDragged","sideMenuIsBeingDragged","isDragOrigin","isDropPoint","isDropWithinEditorBounds","context","_event","editorOuterBoundingBox","cursorWithinEditor","editorWrapper","dropPointBoundingBox","_view","prevState","sideMenuPluginKey","SideMenuExtension","editorView","setHiddenDragImage","unsetHiddenDragImage","getChildIndex","domCellAround","currentTarget","hideElements","selector","elementsToHide","TableHandlesView","tableRect","blockEl","tableBlock","pmNodeInfo","editorHasBlockWithType","widgetContainer","belowTable","toRightOfTable","hideHandles","colIndex","rowIndex","cellRect","boundedMouseCoords","tableCellElements","tableCellElement","emitStateUpdate","oldIndex","dispatchDecorationsTransaction","tableHandlesPluginKey","draggingState","columnWidths","canRowBeDraggedInto","newTable","moveRow","canColumnBeDraggedInto","moveColumn","columnWidth","rowCount","colCount","getDimensionsOfTable","tableBody","cell","TableHandlesExtension","newIndex","originalIndex","draggedCellOrientation","tableResolvedPos","getCellsAtRowHandle","row","rowResolvedPos","cellResolvedPos","cellNode","decorationPos","widget","getCellsAtColumnHandle","relativeRowIndex","relativeColumnIndex","relativeStartCell","relativeEndCell","startRowResolvedPos","startCellResolvedPos","endRowResolvedPos","endCellResolvedPos","CellSelection","direction","beforeState","dispatch","addRowBefore","addRowAfter","addColumnBefore","addColumnAfter","deleteRow","deleteColumn","cellsToMerge","mergeCells","relativeCellToSplit","splitCell","$fromCell","$toCell","isTableCellSelection","ranges","$fromRow","$toRow","$table","fromColIndex","fromRowIndex","toColIndex","toRowIndex","cells","isSelectingTableCells","cellSelection","areInSameColumn","removeEmpty","cropEmptyRowsOrColumns","addType","numToAdd","addRowsOrColumns","plugin","TrailingNodeExtension","_","__","shouldInsertNodeAtEnd","endPosition","type","contentType","_state","lastNode","lastContentNode"],"mappings":"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"}},
    {"offset": {"line": 6746, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/extensions.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/SuggestionMenu/getDefaultEmojiPickerItems.ts"],"sourcesContent":["import type { Emoji, EmojiMartData } from \"@emoji-mart/data\";\n\nimport { defaultInlineContentSchema } from \"../../blocks/defaultBlocks.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { DefaultGridSuggestionItem } from \"./DefaultGridSuggestionItem.js\";\n\n// Temporary fix for https://github.com/missive/emoji-mart/pull/929\nlet emojiLoadingPromise:\n  | Promise<{\n      emojiMart: typeof import(\"emoji-mart\");\n      emojiData: EmojiMartData;\n    }>\n  | undefined;\n\nasync function loadEmojiMart() {\n  if (emojiLoadingPromise) {\n    return emojiLoadingPromise;\n  }\n\n  emojiLoadingPromise = (async () => {\n    // load dynamically because emoji-mart doesn't specify type: module and breaks in nodejs\n    const [emojiMartModule, emojiDataModule] = await Promise.all([\n      import(\"emoji-mart\"),\n      // use a dynamic import to encourage bundle-splitting\n      // and a smaller initial client bundle size\n      import(\"@emoji-mart/data\"),\n    ]);\n\n    const emojiMart =\n      \"default\" in emojiMartModule ? emojiMartModule.default : emojiMartModule;\n    const emojiData =\n      \"default\" in emojiDataModule\n        ? (emojiDataModule.default as EmojiMartData)\n        : (emojiDataModule as EmojiMartData);\n\n    await emojiMart.init({ data: emojiData });\n\n    return { emojiMart, emojiData };\n  })();\n\n  return emojiLoadingPromise;\n}\n\nexport async function getDefaultEmojiPickerItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  query: string,\n): Promise<DefaultGridSuggestionItem[]> {\n  if (\n    !(\"text\" in editor.schema.inlineContentSchema) ||\n    editor.schema.inlineContentSchema[\"text\"] !==\n      defaultInlineContentSchema[\"text\"]\n  ) {\n    return [];\n  }\n\n  const { emojiData, emojiMart } = await loadEmojiMart();\n\n  const emojisToShow =\n    query.trim() === \"\"\n      ? Object.values(emojiData.emojis)\n      : ((await emojiMart!.SearchIndex.search(query)) as Emoji[]);\n\n  return emojisToShow.map((emoji) => ({\n    id: emoji.skins[0].native,\n    onItemClick: () => editor.insertInlineContent(emoji.skins[0].native + \" \"),\n  }));\n}\n"],"names":["emojiLoadingPromise","loadEmojiMart","emojiMartModule","emojiDataModule","emojiMart","emojiData","getDefaultEmojiPickerItems","editor","query","defaultInlineContentSchema","emoji"],"mappings":";;;;;;;;;;;AAYA,IAAIA;AAOJ,eAAeC,IAAgB;IAC7B,OAAID,KAAAA,CAIJA,IAAAA,CAAuB,YAAY;QAEjC,MAAM,CAACE,GAAiBC,CAAe,CAAA,GAAI,MAAM,QAAQ,GAAA,CAAI;;;SAK5D,GAEKC,IACJ,aAAaF,IAAkBA,EAAgB,OAAA,GAAUA,GACrDG,IACJ,aAAaF,IACRA,EAAgB,OAAA,GAChBA;QAEP,OAAA,MAAMC,EAAU,IAAA,CAAK;YAAE,MAAMC;QAAAA,CAAW,GAEjC;YAAE,WAAAD;YAAW,WAAAC;QAAA;IACtB,CAAA,EAAA,GAEOL,CAAAA;AACT;AAEA,eAAsBM,EAKpBC,CAAAA,EACAC,CAAAA,EACsC;IACtC,IACE,CAAA,CAAE,UAAUD,EAAO,MAAA,CAAO,mBAAA,KAC1BA,EAAO,MAAA,CAAO,mBAAA,CAAoB,IAAA,KAChCE,2UAAAA,CAA2B,IAAA,EAE7B,OAAO,CAAA,CAAA;IAGT,MAAM,EAAE,WAAAJ,CAAAA,EAAW,WAAAD,CAAAA,CAAA,CAAA,GAAc,MAAMH,EAAA;IAOvC,OAAA,CAJEO,EAAM,IAAA,CAAA,MAAW,KACb,OAAO,MAAA,CAAOH,EAAU,MAAM,IAC5B,MAAMD,EAAW,WAAA,CAAY,MAAA,CAAOI,CAAK,CAAA,EAE7B,GAAA,CAAI,CAACE,IAAAA,CAAW;YAClC,IAAIA,EAAM,KAAA,CAAM,CAAC,CAAA,CAAE,MAAA;YACnB,aAAa,IAAMH,EAAO,mBAAA,CAAoBG,EAAM,KAAA,CAAM,CAAC,CAAA,CAAE,MAAA,GAAS,GAAG;QAAA,CAAA,CACzE;AACJ"}},
    {"offset": {"line": 7002, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/BlockNoteSchema-C-l154WP.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/topo-sort.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/schema.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/PageBreak/block.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/File/helpers/uploadToTmpFilesDotOrg_DEV_ONLY.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/PageBreak/getPageBreakSlashMenuItems.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/blocks/BlockNoteSchema.ts"],"sourcesContent":["/**\n * Instead of depending on the NPM package, we vendor this file from https://github.com/n1ru4l/toposort/blob/main/src/toposort.ts (MIT)\n *\n * There was a recent publish, despite not having been updated in 2 years, which is suspicious.\n *\n * This file is also simple enough that we can maintain it ourselves.\n */\n\nexport type DirectedAcyclicGraph = Map<string, Iterable<string>>;\nexport type DependencyGraph = DirectedAcyclicGraph;\n\nexport type TaskList = Array<Set<string>>;\n\n// Add more specific types for better type safety\nexport type NodeId = string;\nexport type DependencyMap = Map<NodeId, Set<NodeId>>;\n\nexport function toposort(dag: DirectedAcyclicGraph): TaskList {\n  const inDegrees = countInDegrees(dag);\n\n  let { roots, nonRoots } = getRootsAndNonRoots(inDegrees);\n\n  const sorted: TaskList = [];\n\n  while (roots.size) {\n    sorted.push(roots);\n\n    const newRoots = new Set<NodeId>();\n    for (const root of roots) {\n      const dependents = dag.get(root);\n      if (!dependents) {\n        // Handle case where node has no dependents\n        continue;\n      }\n\n      for (const dependent of dependents) {\n        const currentDegree = inDegrees.get(dependent);\n        if (currentDegree === undefined) {\n          // Handle case where dependent node is not in inDegrees\n          continue;\n        }\n\n        const newDegree = currentDegree - 1;\n        inDegrees.set(dependent, newDegree);\n\n        if (newDegree === 0) {\n          newRoots.add(dependent);\n        }\n      }\n    }\n\n    roots = newRoots;\n  }\n  nonRoots = getRootsAndNonRoots(inDegrees).nonRoots;\n\n  if (nonRoots.size) {\n    throw new Error(\n      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(nonRoots).join(\", \")}`,\n    );\n  }\n\n  return sorted;\n}\n\nexport function toposortReverse(deps: DependencyGraph): TaskList {\n  const dag = reverse(deps);\n  return toposort(dag);\n}\n\ntype InDegrees = Map<NodeId, number>;\n\nfunction countInDegrees(dag: DirectedAcyclicGraph): InDegrees {\n  const counts: InDegrees = new Map();\n\n  for (const [vx, dependents] of dag.entries()) {\n    // Initialize count for current node if not present\n    if (!counts.has(vx)) {\n      counts.set(vx, 0);\n    }\n\n    for (const dependent of dependents) {\n      const currentCount = counts.get(dependent) ?? 0;\n      counts.set(dependent, currentCount + 1);\n    }\n  }\n\n  return counts;\n}\n\nfunction getRootsAndNonRoots(counts: InDegrees) {\n  const roots = new Set<NodeId>();\n  const nonRoots = new Set<NodeId>();\n\n  for (const [id, deg] of counts.entries()) {\n    if (deg === 0) {\n      roots.add(id);\n    } else {\n      nonRoots.add(id);\n    }\n  }\n\n  return { roots, nonRoots };\n}\n\nfunction reverse(deps: DirectedAcyclicGraph): DependencyGraph {\n  const reversedDeps: DependencyMap = new Map();\n\n  for (const [name, dependsOn] of deps.entries()) {\n    // Ensure the source node exists in the reversed map\n    if (!reversedDeps.has(name)) {\n      reversedDeps.set(name, new Set());\n    }\n\n    for (const dependsOnName of dependsOn) {\n      if (!reversedDeps.has(dependsOnName)) {\n        reversedDeps.set(dependsOnName, new Set());\n      }\n      reversedDeps.get(dependsOnName)!.add(name);\n    }\n  }\n\n  return reversedDeps;\n}\n\nexport function createDependencyGraph(): DependencyMap {\n  return new Map();\n}\n\nexport function addDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): DependencyMap {\n  if (!graph.has(from)) {\n    graph.set(from, new Set());\n  }\n  graph.get(from)!.add(to);\n  return graph;\n}\n\nexport function removeDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  if (!dependents) {\n    return false;\n  }\n  return dependents.delete(to);\n}\n\nexport function hasDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  return dependents ? dependents.has(to) : false;\n}\n\n/**\n * Sorts a list of items by their dependencies\n * @returns A function which can retrieve the priority of an item\n */\nexport function sortByDependencies(\n  items: { key: string; runsBefore?: ReadonlyArray<string> }[],\n) {\n  const dag = createDependencyGraph();\n\n  for (const item of items) {\n    if (Array.isArray(item.runsBefore) && item.runsBefore.length > 0) {\n      item.runsBefore.forEach((runBefore) => {\n        addDependency(dag, item.key, runBefore);\n      });\n    } else {\n      addDependency(dag, \"default\", item.key);\n    }\n  }\n  const sortedSpecs = toposortReverse(dag);\n  const defaultIndex = sortedSpecs.findIndex((set) => set.has(\"default\"));\n\n  /**\n   * The priority of an item is described relative to the \"default\" (an arbitrary string which can be used as the reference)\n   *\n   * Since items are topologically sorted, we can see what their relative position is to the \"default\"\n   * Each layer away from the default is 10 priority points (arbitrarily chosen)\n   * The default is fixed at 101 (1 point higher than any tiptap extension, giving priority to custom blocks than any defaults)\n   *\n   * This is a bit of a hack, but it's a simple way to ensure that custom items are always rendered with higher priority than default items\n   * and that custom items are rendered in the order they are defined in the list\n   */\n\n  /**\n   * Retrieves the priority of an item based on its position in the topologically sorted list\n   * @param key - The key of the item to get the priority of\n   * @returns The priority of the item\n   */\n  return (key: string) => {\n    const index = sortedSpecs.findIndex((set) => set.has(key));\n    // the default index should map to 101\n    // one before the default index is 91\n    // one after is 111\n    return 91 + (index + defaultIndex) * 10;\n  };\n}\n","import { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { sortByDependencies } from \"../util/topo-sort.js\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentConfig,\n  InlineContentSchema,\n  InlineContentSpec,\n  InlineContentSpecs,\n  LooseBlockSpec,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  addNodeAndExtensionsToSpec,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"./index.js\";\n\nfunction removeUndefined<T extends Record<string, any> | undefined>(obj: T): T {\n  if (!obj) {\n    return obj;\n  }\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => value !== undefined),\n  ) as T;\n}\n\nexport class CustomBlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> {\n  // Helper so that you can use typeof schema.BlockNoteEditor\n  public readonly BlockNoteEditor: BlockNoteEditor<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly Block: BlockNoDefaults<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly PartialBlock: PartialBlockNoDefaults<\n    BSchema,\n    ISchema,\n    SSchema\n  > = \"only for types\" as any;\n\n  public inlineContentSpecs: InlineContentSpecs;\n  public styleSpecs: StyleSpecs;\n  public blockSpecs: {\n    [K in keyof BSchema]: K extends string\n      ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n      : never;\n  };\n\n  public blockSchema: BSchema;\n  public inlineContentSchema: ISchema;\n  public styleSchema: SSchema;\n\n  constructor(\n    private opts: {\n      blockSpecs: BlockSpecs;\n      inlineContentSpecs: InlineContentSpecs;\n      styleSpecs: StyleSpecs;\n    },\n  ) {\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n  }\n\n  private init() {\n    const getPriority = sortByDependencies(\n      Object.entries({\n        ...this.opts.blockSpecs,\n        ...this.opts.inlineContentSpecs,\n        ...this.opts.styleSpecs,\n      }).map(([key, val]) => ({\n        key: key,\n        runsBefore: val.implementation?.runsBefore ?? [],\n      })),\n    );\n\n    const blockSpecs = Object.fromEntries(\n      Object.entries(this.opts.blockSpecs).map(([key, blockSpec]) => {\n        return [\n          key,\n          addNodeAndExtensionsToSpec(\n            blockSpec.config,\n            blockSpec.implementation,\n            blockSpec.extensions,\n            getPriority(key),\n          ),\n        ];\n      }),\n    ) as {\n      [K in keyof BSchema]: K extends string\n        ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n        : never;\n    };\n\n    const inlineContentSpecs = Object.fromEntries(\n      Object.entries(this.opts.inlineContentSpecs).map(\n        ([key, inlineContentSpec]) => {\n          // Case for text and links.\n          if (typeof inlineContentSpec.config !== \"object\") {\n            return [key, inlineContentSpec];\n          }\n\n          return [\n            key,\n            {\n              ...inlineContentSpec,\n              implementation: {\n                ...inlineContentSpec.implementation,\n                node: inlineContentSpec.implementation?.node.extend({\n                  priority: getPriority(key),\n                }),\n              },\n            },\n          ];\n        },\n      ),\n    ) as InlineContentSpecs;\n\n    const styleSpecs = Object.fromEntries(\n      Object.entries(this.opts.styleSpecs).map(([key, styleSpec]) => [\n        key,\n        {\n          ...styleSpec,\n          implementation: {\n            ...styleSpec.implementation,\n            mark: styleSpec.implementation?.mark.extend({\n              priority: getPriority(key),\n            }),\n          },\n        },\n      ]),\n    ) as StyleSpecs;\n\n    return {\n      blockSpecs,\n      blockSchema: Object.fromEntries(\n        Object.entries(blockSpecs).map(([key, blockDef]) => {\n          return [key, blockDef.config];\n        }),\n      ) as any,\n      inlineContentSpecs: removeUndefined(inlineContentSpecs),\n      styleSpecs: removeUndefined(styleSpecs),\n      inlineContentSchema: getInlineContentSchemaFromSpecs(\n        inlineContentSpecs,\n      ) as any,\n      styleSchema: getStyleSchemaFromSpecs(styleSpecs) as any,\n    };\n  }\n\n  /**\n   * Adds additional block specs to the current schema in a builder pattern.\n   * This method allows extending the schema after it has been created.\n   *\n   * @param additionalBlockSpecs - Additional block specs to add to the schema\n   * @returns The current schema instance for chaining\n   */\n  public extend<\n    AdditionalBlockSpecs extends BlockSpecs = Record<string, never>,\n    AdditionalInlineContentSpecs extends Record<\n      string,\n      InlineContentSpec<InlineContentConfig>\n    > = Record<string, never>,\n    AdditionalStyleSpecs extends StyleSpecs = Record<string, never>,\n  >(opts: {\n    blockSpecs?: AdditionalBlockSpecs;\n    inlineContentSpecs?: AdditionalInlineContentSpecs;\n    styleSpecs?: AdditionalStyleSpecs;\n  }): CustomBlockNoteSchema<\n    AdditionalBlockSpecs extends undefined | Record<string, never>\n      ? BSchema\n      : BSchema & {\n          [K in keyof AdditionalBlockSpecs]: K extends string\n            ? AdditionalBlockSpecs[K][\"config\"]\n            : never;\n        },\n    AdditionalInlineContentSpecs extends undefined | Record<string, never>\n      ? ISchema\n      : ISchema & {\n          [K in keyof AdditionalInlineContentSpecs]: AdditionalInlineContentSpecs[K][\"config\"];\n        },\n    AdditionalStyleSpecs extends undefined | Record<string, never>\n      ? SSchema\n      : SSchema & {\n          [K in keyof AdditionalStyleSpecs]: AdditionalStyleSpecs[K][\"config\"];\n        }\n  > {\n    // Merge the new specs with existing ones\n    Object.assign(this.opts.blockSpecs, opts.blockSpecs);\n    Object.assign(this.opts.inlineContentSpecs, opts.inlineContentSpecs);\n    Object.assign(this.opts.styleSpecs, opts.styleSpecs);\n\n    // Reinitialize the block specs with the merged specs\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n\n    return this as any;\n  }\n}\n","import {\n  BlockSchema,\n  createBlockConfig,\n  createBlockSpec,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteSchema } from \"../BlockNoteSchema.js\";\n\nexport type PageBreakBlockConfig = ReturnType<\n  typeof createPageBreakBlockConfig\n>;\n\nexport const createPageBreakBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"pageBreak\" as const,\n      propSchema: {},\n      content: \"none\",\n    }) as const,\n);\n\nexport const createPageBreakBlockSpec = createBlockSpec(\n  createPageBreakBlockConfig,\n  {\n    parse(element) {\n      if (\n        element.tagName === \"DIV\" &&\n        element.hasAttribute(\"data-page-break\")\n      ) {\n        return {};\n      }\n\n      return undefined;\n    },\n    render() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n    toExternalHTML() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n  },\n);\n\n/**\n * Adds page break support to the given schema.\n */\nexport const withPageBreak = <\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: BlockNoteSchema<B, I, S>,\n) => {\n  return schema.extend({\n    blockSpecs: {\n      pageBreak: createPageBreakBlockSpec(),\n    },\n  });\n};\n","/**\n * Uploads a file to tmpfiles.org and returns the URL to the uploaded file.\n *\n * @warning This function should only be used for development purposes, replace with your own backend!\n */\nexport const uploadToTmpFilesDotOrg_DEV_ONLY = async (\n  file: File,\n): Promise<string> => {\n  const body = new FormData();\n  body.append(\"file\", file);\n\n  const ret = await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: body,\n  });\n  return (await ret.json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\",\n  );\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { DefaultSuggestionItem } from \"../../extensions/SuggestionMenu/DefaultSuggestionItem.js\";\nimport { insertOrUpdateBlockForSlashMenu } from \"../../extensions/SuggestionMenu/getDefaultSlashMenuItems.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { createPageBreakBlockConfig } from \"./block.js\";\n\nexport function checkPageBreakBlocksInSchema<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n): editor is BlockNoteEditor<\n  {\n    pageBreak: ReturnType<typeof createPageBreakBlockConfig>;\n  },\n  I,\n  S\n> {\n  return \"pageBreak\" in editor.schema.blockSchema;\n}\n\nexport function getPageBreakSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: (Omit<DefaultSuggestionItem, \"key\"> & { key: \"page_break\" })[] =\n    [];\n\n  if (checkPageBreakBlocksInSchema(editor)) {\n    items.push({\n      ...editor.dictionary.slash_menu.page_break,\n      onItemClick: () => {\n        insertOrUpdateBlockForSlashMenu(editor, {\n          type: \"pageBreak\",\n        });\n      },\n      key: \"page_break\",\n    });\n  }\n\n  return items;\n}\n","import {\n  BlockSchema,\n  BlockSchemaFromSpecs,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSchemaFromSpecs,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport {\n  defaultBlockSpecs,\n  defaultInlineContentSpecs,\n  defaultStyleSpecs,\n} from \"./defaultBlocks.js\";\n\nexport class BlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> extends CustomBlockNoteSchema<BSchema, ISchema, SSchema> {\n  public static create<\n    BSpecs extends BlockSpecs | undefined = undefined,\n    ISpecs extends InlineContentSpecs | undefined = undefined,\n    SSpecs extends StyleSpecs | undefined = undefined,\n  >(options?: {\n    /**\n     * A list of custom block types that should be available in the editor.\n     */\n    blockSpecs?: BSpecs;\n    /**\n     * A list of custom InlineContent types that should be available in the editor.\n     */\n    inlineContentSpecs?: ISpecs;\n    /**\n     * A list of custom Styles that should be available in the editor.\n     */\n    styleSpecs?: SSpecs;\n  }): BlockNoteSchema<\n    BSpecs extends undefined\n      ? BlockSchemaFromSpecs<typeof defaultBlockSpecs>\n      : BlockSchemaFromSpecs<NonNullable<BSpecs>>,\n    ISpecs extends undefined\n      ? InlineContentSchemaFromSpecs<typeof defaultInlineContentSpecs>\n      : InlineContentSchemaFromSpecs<NonNullable<ISpecs>>,\n    SSpecs extends undefined\n      ? StyleSchemaFromSpecs<typeof defaultStyleSpecs>\n      : StyleSchemaFromSpecs<NonNullable<SSpecs>>\n  > {\n    return new BlockNoteSchema<any, any, any>({\n      blockSpecs: options?.blockSpecs ?? defaultBlockSpecs,\n      inlineContentSpecs:\n        options?.inlineContentSpecs ?? defaultInlineContentSpecs,\n      styleSpecs: options?.styleSpecs ?? defaultStyleSpecs,\n    });\n  }\n}\n"],"names":["toposort","dag","inDegrees","countInDegrees","roots","nonRoots","getRootsAndNonRoots","sorted","newRoots","root","dependents","dependent","currentDegree","newDegree","toposortReverse","deps","reverse","counts","vx","currentCount","id","deg","reversedDeps","name","dependsOn","dependsOnName","createDependencyGraph","addDependency","graph","from","to","sortByDependencies","items","item","runBefore","sortedSpecs","defaultIndex","set","key","removeUndefined","obj","value","CustomBlockNoteSchema","opts","__publicField","blockSpecs","inlineContentSpecs","styleSpecs","blockSchema","inlineContentSchema","styleSchema","getPriority","val","_a","blockSpec","addNodeAndExtensionsToSpec","inlineContentSpec","styleSpec","blockDef","getInlineContentSchemaFromSpecs","getStyleSchemaFromSpecs","createPageBreakBlockConfig","createBlockConfig","createPageBreakBlockSpec","createBlockSpec","element","pageBreak","withPageBreak","schema","uploadToTmpFilesDotOrg_DEV_ONLY","file","body","checkPageBreakBlocksInSchema","editor","getPageBreakSlashMenuItems","insertOrUpdateBlockForSlashMenu","BlockNoteSchema","options","defaultBlockSpecs","defaultInlineContentSpecs","defaultStyleSpecs"],"mappings":"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"}},
    {"offset": {"line": 7293, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/en-njEqD7AG.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/i18n/locales/en.ts"],"sourcesContent":["export const en = {\n  slash_menu: {\n    heading: {\n      title: \"Heading 1\",\n      subtext: \"Top-level heading\",\n      aliases: [\"h\", \"heading1\", \"h1\"],\n      group: \"Headings\",\n    },\n    heading_2: {\n      title: \"Heading 2\",\n      subtext: \"Key section heading\",\n      aliases: [\"h2\", \"heading2\", \"subheading\"],\n      group: \"Headings\",\n    },\n    heading_3: {\n      title: \"Heading 3\",\n      subtext: \"Subsection and group heading\",\n      aliases: [\"h3\", \"heading3\", \"subheading\"],\n      group: \"Headings\",\n    },\n    heading_4: {\n      title: \"Heading 4\",\n      subtext: \"Minor subsection heading\",\n      aliases: [\"h4\", \"heading4\", \"subheading4\"],\n      group: \"Subheadings\",\n    },\n    heading_5: {\n      title: \"Heading 5\",\n      subtext: \"Small subsection heading\",\n      aliases: [\"h5\", \"heading5\", \"subheading5\"],\n      group: \"Subheadings\",\n    },\n    heading_6: {\n      title: \"Heading 6\",\n      subtext: \"Lowest-level heading\",\n      aliases: [\"h6\", \"heading6\", \"subheading6\"],\n      group: \"Subheadings\",\n    },\n    toggle_heading: {\n      title: \"Toggle Heading 1\",\n      subtext: \"Toggleable top-level heading\",\n      aliases: [\"h\", \"heading1\", \"h1\", \"collapsable\"],\n      group: \"Subheadings\",\n    },\n    toggle_heading_2: {\n      title: \"Toggle Heading 2\",\n      subtext: \"Toggleable key section heading\",\n      aliases: [\"h2\", \"heading2\", \"subheading\", \"collapsable\"],\n      group: \"Subheadings\",\n    },\n    toggle_heading_3: {\n      title: \"Toggle Heading 3\",\n      subtext: \"Toggleable subsection and group heading\",\n      aliases: [\"h3\", \"heading3\", \"subheading\", \"collapsable\"],\n      group: \"Subheadings\",\n    },\n    quote: {\n      title: \"Quote\",\n      subtext: \"Quote or excerpt\",\n      aliases: [\"quotation\", \"blockquote\", \"bq\"],\n      group: \"Basic blocks\",\n    },\n    toggle_list: {\n      title: \"Toggle List\",\n      subtext: \"List with hideable sub-items\",\n      aliases: [\"li\", \"list\", \"toggleList\", \"toggle list\", \"collapsable list\"],\n      group: \"Basic blocks\",\n    },\n    numbered_list: {\n      title: \"Numbered List\",\n      subtext: \"List with ordered items\",\n      aliases: [\"ol\", \"li\", \"list\", \"numberedlist\", \"numbered list\"],\n      group: \"Basic blocks\",\n    },\n    bullet_list: {\n      title: \"Bullet List\",\n      subtext: \"List with unordered items\",\n      aliases: [\"ul\", \"li\", \"list\", \"bulletlist\", \"bullet list\"],\n      group: \"Basic blocks\",\n    },\n    check_list: {\n      title: \"Check List\",\n      subtext: \"List with checkboxes\",\n      aliases: [\n        \"ul\",\n        \"li\",\n        \"list\",\n        \"checklist\",\n        \"check list\",\n        \"checked list\",\n        \"checkbox\",\n      ],\n      group: \"Basic blocks\",\n    },\n    paragraph: {\n      title: \"Paragraph\",\n      subtext: \"The body of your document\",\n      aliases: [\"p\", \"paragraph\"],\n      group: \"Basic blocks\",\n    },\n    code_block: {\n      title: \"Code Block\",\n      subtext: \"Code block with syntax highlighting\",\n      aliases: [\"code\", \"pre\"],\n      group: \"Basic blocks\",\n    },\n    page_break: {\n      title: \"Page Break\",\n      subtext: \"Page separator\",\n      aliases: [\"page\", \"break\", \"separator\"],\n      group: \"Basic blocks\",\n    },\n    table: {\n      title: \"Table\",\n      subtext: \"Table with editable cells\",\n      aliases: [\"table\"],\n      group: \"Advanced\",\n    },\n    image: {\n      title: \"Image\",\n      subtext: \"Resizable image with caption\",\n      aliases: [\n        \"image\",\n        \"imageUpload\",\n        \"upload\",\n        \"img\",\n        \"picture\",\n        \"media\",\n        \"url\",\n      ],\n      group: \"Media\",\n    },\n    video: {\n      title: \"Video\",\n      subtext: \"Resizable video with caption\",\n      aliases: [\n        \"video\",\n        \"videoUpload\",\n        \"upload\",\n        \"mp4\",\n        \"film\",\n        \"media\",\n        \"url\",\n      ],\n      group: \"Media\",\n    },\n    audio: {\n      title: \"Audio\",\n      subtext: \"Embedded audio with caption\",\n      aliases: [\n        \"audio\",\n        \"audioUpload\",\n        \"upload\",\n        \"mp3\",\n        \"sound\",\n        \"media\",\n        \"url\",\n      ],\n      group: \"Media\",\n    },\n    file: {\n      title: \"File\",\n      subtext: \"Embedded file\",\n      aliases: [\"file\", \"upload\", \"embed\", \"media\", \"url\"],\n      group: \"Media\",\n    },\n    emoji: {\n      title: \"Emoji\",\n      subtext: \"Search for and insert an emoji\",\n      aliases: [\"emoji\", \"emote\", \"emotion\", \"face\"],\n      group: \"Others\",\n    },\n    divider: {\n      title: \"Divider\",\n      subtext: \"Visually divide blocks\",\n      aliases: [\"divider\", \"hr\", \"line\", \"horizontal rule\"],\n      group: \"Basic blocks\",\n    },\n  },\n  placeholders: {\n    default: \"Enter text or type '/' for commands\",\n    heading: \"Heading\",\n    toggleListItem: \"Toggle\",\n    bulletListItem: \"List\",\n    numberedListItem: \"List\",\n    checkListItem: \"List\",\n    emptyDocument: undefined,\n    new_comment: \"Write a comment...\",\n    edit_comment: \"Edit comment...\",\n    comment_reply: \"Add comment...\",\n  } as Record<string | \"default\" | \"emptyDocument\", string | undefined>,\n  file_blocks: {\n    add_button_text: {\n      image: \"Add image\",\n      video: \"Add video\",\n      audio: \"Add audio\",\n      file: \"Add file\",\n    } as Record<string, string>,\n  },\n  toggle_blocks: {\n    add_block_button: \"Empty toggle. Click to add a block.\",\n  },\n  // from react package:\n  side_menu: {\n    add_block_label: \"Add block\",\n    drag_handle_label: \"Open block menu\",\n  },\n  drag_handle: {\n    delete_menuitem: \"Delete\",\n    colors_menuitem: \"Colors\",\n    header_row_menuitem: \"Header row\",\n    header_column_menuitem: \"Header column\",\n  },\n  table_handle: {\n    delete_column_menuitem: \"Delete column\",\n    delete_row_menuitem: \"Delete row\",\n    add_left_menuitem: \"Add column left\",\n    add_right_menuitem: \"Add column right\",\n    add_above_menuitem: \"Add row above\",\n    add_below_menuitem: \"Add row below\",\n    split_cell_menuitem: \"Split cell\",\n    merge_cells_menuitem: \"Merge cells\",\n    background_color_menuitem: \"Background color\",\n  },\n  suggestion_menu: {\n    no_items_title: \"No items found\",\n  },\n  color_picker: {\n    text_title: \"Text\",\n    background_title: \"Background\",\n    colors: {\n      default: \"Default\",\n      gray: \"Gray\",\n      brown: \"Brown\",\n      red: \"Red\",\n      orange: \"Orange\",\n      yellow: \"Yellow\",\n      green: \"Green\",\n      blue: \"Blue\",\n      purple: \"Purple\",\n      pink: \"Pink\",\n    },\n  },\n\n  formatting_toolbar: {\n    bold: {\n      tooltip: \"Bold\",\n      secondary_tooltip: \"Mod+B\",\n    },\n    italic: {\n      tooltip: \"Italic\",\n      secondary_tooltip: \"Mod+I\",\n    },\n    underline: {\n      tooltip: \"Underline\",\n      secondary_tooltip: \"Mod+U\",\n    },\n    strike: {\n      tooltip: \"Strike\",\n      secondary_tooltip: \"Mod+Shift+S\",\n    },\n    code: {\n      tooltip: \"Code\",\n      secondary_tooltip: \"\",\n    },\n    colors: {\n      tooltip: \"Colors\",\n    },\n    link: {\n      tooltip: \"Create link\",\n      secondary_tooltip: \"Mod+K\",\n    },\n    file_caption: {\n      tooltip: \"Edit caption\",\n      input_placeholder: \"Edit caption\",\n    },\n    file_replace: {\n      tooltip: {\n        image: \"Replace image\",\n        video: \"Replace video\",\n        audio: \"Replace audio\",\n        file: \"Replace file\",\n      } as Record<string, string>,\n    },\n    file_rename: {\n      tooltip: {\n        image: \"Rename image\",\n        video: \"Rename video\",\n        audio: \"Rename audio\",\n        file: \"Rename file\",\n      } as Record<string, string>,\n      input_placeholder: {\n        image: \"Rename image\",\n        video: \"Rename video\",\n        audio: \"Rename audio\",\n        file: \"Rename file\",\n      } as Record<string, string>,\n    },\n    file_download: {\n      tooltip: {\n        image: \"Download image\",\n        video: \"Download video\",\n        audio: \"Download audio\",\n        file: \"Download file\",\n      } as Record<string, string>,\n    },\n    file_delete: {\n      tooltip: {\n        image: \"Delete image\",\n        video: \"Delete video\",\n        audio: \"Delete audio\",\n        file: \"Delete file\",\n      } as Record<string, string>,\n    },\n    file_preview_toggle: {\n      tooltip: \"Toggle preview\",\n    },\n    nest: {\n      tooltip: \"Nest block\",\n      secondary_tooltip: \"Tab\",\n    },\n    unnest: {\n      tooltip: \"Unnest block\",\n      secondary_tooltip: \"Shift+Tab\",\n    },\n    align_left: {\n      tooltip: \"Align text left\",\n    },\n    align_center: {\n      tooltip: \"Align text center\",\n    },\n    align_right: {\n      tooltip: \"Align text right\",\n    },\n    align_justify: {\n      tooltip: \"Justify text\",\n    },\n    table_cell_merge: {\n      tooltip: \"Merge cells\",\n    },\n    comment: {\n      tooltip: \"Add comment\",\n    },\n  },\n  file_panel: {\n    upload: {\n      title: \"Upload\",\n      file_placeholder: {\n        image: \"Upload image\",\n        video: \"Upload video\",\n        audio: \"Upload audio\",\n        file: \"Upload file\",\n      } as Record<string, string>,\n      upload_error: \"Error: Upload failed\",\n    },\n    embed: {\n      title: \"Embed\",\n      embed_button: {\n        image: \"Embed image\",\n        video: \"Embed video\",\n        audio: \"Embed audio\",\n        file: \"Embed file\",\n      } as Record<string, string>,\n      url_placeholder: \"Enter URL\",\n    },\n  },\n  link_toolbar: {\n    delete: {\n      tooltip: \"Remove link\",\n    },\n    edit: {\n      text: \"Edit link\",\n      tooltip: \"Edit\",\n    },\n    open: {\n      tooltip: \"Open in new tab\",\n    },\n    form: {\n      title_placeholder: \"Edit title\",\n      url_placeholder: \"Edit URL\",\n    },\n  },\n  comments: {\n    edited: \"edited\",\n    save_button_text: \"Save\",\n    cancel_button_text: \"Cancel\",\n    actions: {\n      add_reaction: \"Add reaction\",\n      resolve: \"Resolve\",\n      edit_comment: \"Edit comment\",\n      delete_comment: \"Delete comment\",\n      more_actions: \"More actions\",\n    },\n    reactions: {\n      reacted_by: \"Reacted by\",\n    },\n    sidebar: {\n      marked_as_resolved: \"Marked as resolved\",\n      more_replies: (count: number) => `${count} more replies`,\n    },\n  },\n  generic: {\n    ctrl_shortcut: \"Ctrl\",\n  },\n};\n"],"names":["en","count"],"mappings":";;;;AAAO,MAAMA,IAAK;IAChB,YAAY;QACV,SAAS;YACP,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAK;gBAAY,IAAI;aAAA;YAC/B,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY,YAAY;aAAA;YACxC,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY,YAAY;aAAA;YACxC,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY,aAAa;aAAA;YACzC,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY,aAAa;aAAA;YACzC,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY,aAAa;aAAA;YACzC,OAAO;QAAA;QAET,gBAAgB;YACd,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAK;gBAAY;gBAAM,aAAa;aAAA;YAC9C,OAAO;QAAA;QAET,kBAAkB;YAChB,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY;gBAAc,aAAa;aAAA;YACvD,OAAO;QAAA;QAET,kBAAkB;YAChB,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAY;gBAAc,aAAa;aAAA;YACvD,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAa;gBAAc,IAAI;aAAA;YACzC,OAAO;QAAA;QAET,aAAa;YACX,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAQ;gBAAc;gBAAe,kBAAkB;aAAA;YACvE,OAAO;QAAA;QAET,eAAe;YACb,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAM;gBAAQ;gBAAgB,eAAe;aAAA;YAC7D,OAAO;QAAA;QAET,aAAa;YACX,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAM;gBAAM;gBAAQ;gBAAc,aAAa;aAAA;YACzD,OAAO;QAAA;QAET,YAAY;YACV,OAAO;YACP,SAAS;YACT,SAAS;gBACP;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aAAA;YAEF,OAAO;QAAA;QAET,WAAW;YACT,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAK,WAAW;aAAA;YAC1B,OAAO;QAAA;QAET,YAAY;YACV,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAQ,KAAK;aAAA;YACvB,OAAO;QAAA;QAET,YAAY;YACV,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAQ;gBAAS,WAAW;aAAA;YACtC,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBAAC,OAAO;aAAA;YACjB,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBACP;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aAAA;YAEF,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBACP;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aAAA;YAEF,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBACP;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aAAA;YAEF,OAAO;QAAA;QAET,MAAM;YACJ,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAQ;gBAAU;gBAAS;gBAAS,KAAK;aAAA;YACnD,OAAO;QAAA;QAET,OAAO;YACL,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAS;gBAAS;gBAAW,MAAM;aAAA;YAC7C,OAAO;QAAA;QAET,SAAS;YACP,OAAO;YACP,SAAS;YACT,SAAS;gBAAC;gBAAW;gBAAM;gBAAQ,iBAAiB;aAAA;YACpD,OAAO;QAAA;IACT;IAEF,cAAc;QACZ,SAAS;QACT,SAAS;QACT,gBAAgB;QAChB,gBAAgB;QAChB,kBAAkB;QAClB,eAAe;QACf,eAAe,KAAA;QACf,aAAa;QACb,cAAc;QACd,eAAe;IAAA;IAEjB,aAAa;QACX,iBAAiB;YACf,OAAO;YACP,OAAO;YACP,OAAO;YACP,MAAM;QAAA;IACR;IAEF,eAAe;QACb,kBAAkB;IAAA;IAAA,sBAAA;IAGpB,WAAW;QACT,iBAAiB;QACjB,mBAAmB;IAAA;IAErB,aAAa;QACX,iBAAiB;QACjB,iBAAiB;QACjB,qBAAqB;QACrB,wBAAwB;IAAA;IAE1B,cAAc;QACZ,wBAAwB;QACxB,qBAAqB;QACrB,mBAAmB;QACnB,oBAAoB;QACpB,oBAAoB;QACpB,oBAAoB;QACpB,qBAAqB;QACrB,sBAAsB;QACtB,2BAA2B;IAAA;IAE7B,iBAAiB;QACf,gBAAgB;IAAA;IAElB,cAAc;QACZ,YAAY;QACZ,kBAAkB;QAClB,QAAQ;YACN,SAAS;YACT,MAAM;YACN,OAAO;YACP,KAAK;YACL,QAAQ;YACR,QAAQ;YACR,OAAO;YACP,MAAM;YACN,QAAQ;YACR,MAAM;QAAA;IACR;IAGF,oBAAoB;QAClB,MAAM;YACJ,SAAS;YACT,mBAAmB;QAAA;QAErB,QAAQ;YACN,SAAS;YACT,mBAAmB;QAAA;QAErB,WAAW;YACT,SAAS;YACT,mBAAmB;QAAA;QAErB,QAAQ;YACN,SAAS;YACT,mBAAmB;QAAA;QAErB,MAAM;YACJ,SAAS;YACT,mBAAmB;QAAA;QAErB,QAAQ;YACN,SAAS;QAAA;QAEX,MAAM;YACJ,SAAS;YACT,mBAAmB;QAAA;QAErB,cAAc;YACZ,SAAS;YACT,mBAAmB;QAAA;QAErB,cAAc;YACZ,SAAS;gBACP,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;QACR;QAEF,aAAa;YACX,SAAS;gBACP,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;YAER,mBAAmB;gBACjB,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;QACR;QAEF,eAAe;YACb,SAAS;gBACP,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;QACR;QAEF,aAAa;YACX,SAAS;gBACP,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;QACR;QAEF,qBAAqB;YACnB,SAAS;QAAA;QAEX,MAAM;YACJ,SAAS;YACT,mBAAmB;QAAA;QAErB,QAAQ;YACN,SAAS;YACT,mBAAmB;QAAA;QAErB,YAAY;YACV,SAAS;QAAA;QAEX,cAAc;YACZ,SAAS;QAAA;QAEX,aAAa;YACX,SAAS;QAAA;QAEX,eAAe;YACb,SAAS;QAAA;QAEX,kBAAkB;YAChB,SAAS;QAAA;QAEX,SAAS;YACP,SAAS;QAAA;IACX;IAEF,YAAY;QACV,QAAQ;YACN,OAAO;YACP,kBAAkB;gBAChB,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;YAER,cAAc;QAAA;QAEhB,OAAO;YACL,OAAO;YACP,cAAc;gBACZ,OAAO;gBACP,OAAO;gBACP,OAAO;gBACP,MAAM;YAAA;YAER,iBAAiB;QAAA;IACnB;IAEF,cAAc;QACZ,QAAQ;YACN,SAAS;QAAA;QAEX,MAAM;YACJ,MAAM;YACN,SAAS;QAAA;QAEX,MAAM;YACJ,SAAS;QAAA;QAEX,MAAM;YACJ,mBAAmB;YACnB,iBAAiB;QAAA;IACnB;IAEF,UAAU;QACR,QAAQ;QACR,kBAAkB;QAClB,oBAAoB;QACpB,SAAS;YACP,cAAc;YACd,SAAS;YACT,cAAc;YACd,gBAAgB;YAChB,cAAc;QAAA;QAEhB,WAAW;YACT,YAAY;QAAA;QAEd,SAAS;YACP,oBAAoB;YACpB,cAAc,CAACC,IAAkB,GAAGA,CAAK,CAAA,aAAA,CAAA;QAAA;IAC3C;IAEF,SAAS;QACP,eAAe;IAAA;AAEnB"}},
    {"offset": {"line": 7796, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/internship/mindrian/frontend/node_modules/.pnpm/@blocknote+core@0.44.1_@tip_46b4d8523240bf6739690e1026591f08/node_modules/@blocknote/core/dist/blocknote.js","sources":["file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/schema/inlineContent/createSpec.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/insertBlocks/insertBlocks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/replaceBlocks/util/fixColumnList.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/replaceBlocks/replaceBlocks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/html/util/serializeBlocksInternalHTML.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/exporters/html/internalHTMLSerializer.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/moveBlocks/moveBlocks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/nestBlock/nestBlock.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/getBlock/getBlock.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/BlockManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/EventManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/parsers/html/util/nestedLists.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/parsers/html/parseHTML.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/parsers/markdown/parseMarkdown.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/ExportManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/fromClipboard/acceptedMIMETypes.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/fromClipboard/handleFileInsertion.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/fromClipboard/fileDropExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/parsers/markdown/detectMarkdown.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/fromClipboard/handleVSCodePaste.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/fromClipboard/pasteExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/clipboard/toClipboard/copyExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/BackgroundColor/BackgroundColorExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/HardBreak/HardBreak.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/commands/mergeBlocks/mergeBlocks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/KeyboardShortcuts/KeyboardShortcutsExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/Suggestions/SuggestionMarks.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/TextAlignment/TextAlignmentExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/extensions/tiptap-extensions/TextColor/TextColorExtension.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/pm-nodes/BlockContainer.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/pm-nodes/BlockGroup.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/pm-nodes/Doc.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/ExtensionManager/extensions.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/ExtensionManager/index.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/selections/selection.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/selections/textCursorPosition.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/SelectionManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/StateManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/api/blockManipulation/insertContentAt.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/managers/StyleManager.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/transformPasted.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/editor/BlockNoteEditor.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/exporter/Exporter.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/exporter/mapping.ts","file:///C:/Users/Lab%20account/Desktop/internship/mindrian/frontend/node_modules/.pnpm/%40blocknote%2Bcore%400.44.1_%40tip_46b4d8523240bf6739690e1026591f08/node_modules/%40blocknote/core/src/util/combineByGroup.ts"],"sourcesContent":["import { Node } from \"@tiptap/core\";\n\nimport { TagParseRule } from \"@tiptap/pm/model\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { propsToAttributes } from \"../blocks/internal.js\";\nimport { Props } from \"../propTypes.js\";\nimport { StyleSchema } from \"../styles/types.js\";\nimport {\n  addInlineContentAttributes,\n  addInlineContentKeyboardShortcuts,\n  createInlineContentSpecFromTipTapNode,\n} from \"./internal.js\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentFromConfig,\n  InlineContentSpec,\n  PartialCustomInlineContentFromConfig,\n} from \"./types.js\";\n\nexport type CustomInlineContentImplementation<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  meta?: {\n    draggable?: boolean;\n  };\n\n  /**\n   * Parses an external HTML element into a inline content of this type when it returns the block props object, otherwise undefined\n   */\n  parse?: (el: HTMLElement) => Partial<Props<T[\"propSchema\"]>> | undefined;\n\n  /**\n   * Renders an inline content to DOM elements\n   */\n  render: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * A callback that allows overriding the inline content element\n     */\n    updateInlineContent: (\n      update: PartialCustomInlineContentFromConfig<T, S>,\n    ) => void,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n    // (note) if we want to fix the manual cast, we need to prevent circular references and separate block definition and render implementations\n    // or allow manually passing <BSchema>, but that's not possible without passing the other generics because Typescript doesn't support partial inferred generics\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  };\n\n  /**\n   * Renders an inline content to external HTML elements for use outside the editor\n   * If not provided, falls back to the render method\n   */\n  toExternalHTML?: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n  ) =>\n    | {\n        dom: HTMLElement | DocumentFragment;\n        contentDOM?: HTMLElement;\n      }\n    | undefined;\n\n  runsBefore?: string[];\n};\n\nexport function getInlineContentParseRules<C extends CustomInlineContentConfig>(\n  config: C,\n  customParseFunction?: CustomInlineContentImplementation<C, any>[\"parse\"],\n) {\n  const rules: TagParseRule[] = [\n    {\n      tag: `[data-inline-content-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = customParseFunction?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n    });\n  }\n  return rules;\n}\n\nexport function createInlineContentSpec<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n>(\n  inlineContentConfig: T,\n  inlineContentImplementation: CustomInlineContentImplementation<T, S>,\n): InlineContentSpec<T> {\n  const node = Node.create({\n    name: inlineContentConfig.type,\n    inline: true,\n    group: \"inline\",\n    draggable: inlineContentImplementation.meta?.draggable,\n    selectable: inlineContentConfig.content === \"styled\",\n    atom: inlineContentConfig.content === \"none\",\n    content: inlineContentConfig.content === \"styled\" ? \"inline*\" : \"\",\n\n    addAttributes() {\n      return propsToAttributes(inlineContentConfig.propSchema);\n    },\n\n    addKeyboardShortcuts() {\n      return addInlineContentKeyboardShortcuts(inlineContentConfig);\n    },\n\n    parseHTML() {\n      return getInlineContentParseRules(\n        inlineContentConfig,\n        inlineContentImplementation.parse,\n      );\n    },\n\n    renderHTML({ node }) {\n      const editor = this.options.editor;\n\n      const output = inlineContentImplementation.render.call(\n        { renderType: \"dom\", props: undefined },\n        nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n        () => {\n          // No-op\n        },\n        editor,\n      );\n\n      return addInlineContentAttributes(\n        output,\n        inlineContentConfig.type,\n        node.attrs as Props<T[\"propSchema\"]>,\n        inlineContentConfig.propSchema,\n      );\n    },\n\n    addNodeView() {\n      return (props) => {\n        const { node, getPos } = props;\n        const editor = this.options.editor as BlockNoteEditor<any, any, S>;\n\n        const output = inlineContentImplementation.render.call(\n          { renderType: \"nodeView\", props },\n          nodeToCustomInlineContent(\n            node,\n            editor.schema.inlineContentSchema,\n            editor.schema.styleSchema,\n          ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n          (update) => {\n            const content = inlineContentToNodes([update], editor.pmSchema);\n\n            const pos = getPos();\n\n            if (!pos) {\n              return;\n            }\n\n            editor.transact((tr) =>\n              tr.replaceWith(pos, pos + node.nodeSize, content),\n            );\n          },\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          node.attrs as Props<T[\"propSchema\"]>,\n          inlineContentConfig.propSchema,\n        );\n      };\n    },\n  });\n\n  return createInlineContentSpecFromTipTapNode(\n    node,\n    inlineContentConfig.propSchema,\n    {\n      ...inlineContentImplementation,\n      toExternalHTML: inlineContentImplementation.toExternalHTML,\n      render(inlineContent, updateInlineContent, editor) {\n        const output = inlineContentImplementation.render(\n          inlineContent,\n          updateInlineContent,\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          inlineContent.props,\n          inlineContentConfig.propSchema,\n        );\n      },\n    },\n  ) as InlineContentSpec<T>;\n}\n","import { Fragment, Slice } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport { ReplaceStep } from \"prosemirror-transform\";\nimport { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport function insertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" = \"before\",\n): Block<BSchema, I, S>[] {\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const nodesToInsert = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  let pos = posInfo.posBeforeNode;\n  if (placement === \"after\") {\n    pos += posInfo.node.nodeSize;\n  }\n\n  tr.step(\n    new ReplaceStep(pos, pos, new Slice(Fragment.from(nodesToInsert), 0, 0)),\n  );\n\n  // Now that the `PartialBlock`s have been converted to nodes, we can\n  // re-convert them into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return insertedBlocks;\n}\n","import { Slice, type Node } from \"prosemirror-model\";\nimport { type Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\n/**\n * Checks if a `column` node is empty, i.e. if it has only a single empty\n * paragraph.\n * @param column The column to check.\n * @returns Whether the column is empty.\n */\nexport function isEmptyColumn(column: Node) {\n  if (!column || column.type.name !== \"column\") {\n    throw new Error(\"Invalid columnPos: does not point to column node.\");\n  }\n\n  const blockContainer = column.firstChild;\n  if (!blockContainer) {\n    throw new Error(\"Invalid column: does not have child node.\");\n  }\n\n  const blockContent = blockContainer.firstChild;\n  if (!blockContent) {\n    throw new Error(\"Invalid blockContainer: does not have child node.\");\n  }\n\n  return (\n    column.childCount === 1 &&\n    blockContainer.childCount === 1 &&\n    blockContent.type.name === \"paragraph\" &&\n    blockContent.content.content.length === 0\n  );\n}\n\n/**\n * Removes all empty `column` nodes in a `columnList`. A `column` node is empty\n * if it has only a single empty block. If, however, removing the `column`s\n * leaves the `columnList` that has fewer than two, ProseMirror will re-add\n * empty columns.\n * @param tr The `Transaction` to add the changes to.\n * @param columnListPos The position just before the `columnList` node.\n */\nexport function removeEmptyColumns(tr: Transaction, columnListPos: number) {\n  const $columnListPos = tr.doc.resolve(columnListPos);\n  const columnList = $columnListPos.nodeAfter;\n  if (!columnList || columnList.type.name !== \"columnList\") {\n    throw new Error(\n      \"Invalid columnListPos: does not point to columnList node.\",\n    );\n  }\n\n  for (\n    let columnIndex = columnList.childCount - 1;\n    columnIndex >= 0;\n    columnIndex--\n  ) {\n    const columnPos = tr.doc\n      .resolve($columnListPos.pos + 1)\n      .posAtIndex(columnIndex);\n    const $columnPos = tr.doc.resolve(columnPos);\n    const column = $columnPos.nodeAfter;\n    if (!column || column.type.name !== \"column\") {\n      throw new Error(\"Invalid columnPos: does not point to column node.\");\n    }\n\n    if (isEmptyColumn(column)) {\n      tr.delete(columnPos, columnPos + column.nodeSize);\n    }\n  }\n}\n\n/**\n * Fixes potential issues in a `columnList` node after a\n * `blockContainer`/`column` node is (re)moved from it:\n *\n * - Removes all empty `column` nodes. A `column` node is empty if it has only\n * a single empty block.\n * - If all but one `column` nodes are empty, replaces the `columnList` with\n * the content of the non-empty `column`.\n * - If all `column` nodes are empty, removes the `columnList` entirely.\n * @param tr The `Transaction` to add the changes to.\n * @param columnListPos\n * @returns The position just before the `columnList` node.\n */\nexport function fixColumnList(tr: Transaction, columnListPos: number) {\n  removeEmptyColumns(tr, columnListPos);\n\n  const $columnListPos = tr.doc.resolve(columnListPos);\n  const columnList = $columnListPos.nodeAfter;\n  if (!columnList || columnList.type.name !== \"columnList\") {\n    throw new Error(\n      \"Invalid columnListPos: does not point to columnList node.\",\n    );\n  }\n\n  if (columnList.childCount > 2) {\n    // Do nothing if the `columnList` has more than two non-empty `column`s. In\n    // the case that the `columnList` has exactly two columns, we may need to\n    // still remove it, as it's possible that one or both columns are empty.\n    // This is because after `removeEmptyColumns` is called, if the\n    // `columnList` has fewer than two `column`s, ProseMirror will re-add empty\n    // `column`s until there are two total, in order to fit the schema.\n    return;\n  }\n\n  if (columnList.childCount < 2) {\n    // Throw an error if the `columnList` has fewer than two columns. After\n    // `removeEmptyColumns` is called, if the `columnList` has fewer than two\n    // `column`s, ProseMirror will re-add empty `column`s until there are two\n    // total, in order to fit the schema. So if there are fewer than two here,\n    // either the schema, or ProseMirror's internals, must have changed.\n    throw new Error(\"Invalid columnList: contains fewer than two children.\");\n  }\n\n  const firstColumnBeforePos = columnListPos + 1;\n  const $firstColumnBeforePos = tr.doc.resolve(firstColumnBeforePos);\n  const firstColumn = $firstColumnBeforePos.nodeAfter;\n\n  const lastColumnAfterPos = columnListPos + columnList.nodeSize - 1;\n  const $lastColumnAfterPos = tr.doc.resolve(lastColumnAfterPos);\n  const lastColumn = $lastColumnAfterPos.nodeBefore;\n\n  if (!firstColumn || !lastColumn) {\n    throw new Error(\"Invalid columnList: does not contain children.\");\n  }\n\n  const firstColumnEmpty = isEmptyColumn(firstColumn);\n  const lastColumnEmpty = isEmptyColumn(lastColumn);\n\n  if (firstColumnEmpty && lastColumnEmpty) {\n    // Removes `columnList`\n    tr.delete(columnListPos, columnListPos + columnList.nodeSize);\n\n    return;\n  }\n\n  if (firstColumnEmpty) {\n    tr.step(\n      new ReplaceAroundStep(\n        // Replaces `columnList`.\n        columnListPos,\n        columnListPos + columnList.nodeSize,\n        // Replaces with content of last `column`.\n        lastColumnAfterPos - lastColumn.nodeSize + 1,\n        lastColumnAfterPos - 1,\n        // Doesn't append anything.\n        Slice.empty,\n        0,\n        false,\n      ),\n    );\n\n    return;\n  }\n\n  if (lastColumnEmpty) {\n    tr.step(\n      new ReplaceAroundStep(\n        // Replaces `columnList`.\n        columnListPos,\n        columnListPos + columnList.nodeSize,\n        // Replaces with content of first `column`.\n        firstColumnBeforePos + 1,\n        firstColumnBeforePos + firstColumn.nodeSize - 1,\n        // Doesn't append anything.\n        Slice.empty,\n        0,\n        false,\n      ),\n    );\n\n    return;\n  }\n}\n","import { type Node } from \"prosemirror-model\";\nimport { type Transaction } from \"prosemirror-state\";\nimport type { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\nimport { fixColumnList } from \"./util/fixColumnList.js\";\n\nexport function removeAndInsertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n): {\n  insertedBlocks: Block<BSchema, I, S>[];\n  removedBlocks: Block<BSchema, I, S>[];\n} {\n  const pmSchema = getPmSchema(tr);\n  // Converts the `PartialBlock`s to ProseMirror nodes to insert them into the\n  // document.\n  const nodesToInsert: Node[] = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id,\n    ),\n  );\n  const removedBlocks: Block<BSchema, I, S>[] = [];\n  const columnListPositions = new Set<number>();\n\n  const idOfFirstBlock =\n    typeof blocksToRemove[0] === \"string\"\n      ? blocksToRemove[0]\n      : blocksToRemove[0].id;\n  let removedSize = 0;\n\n  tr.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      !node.type.isInGroup(\"bnBlock\") ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    // Saves the block that is being deleted.\n    removedBlocks.push(nodeToBlock(node, pmSchema));\n    idsOfBlocksToRemove.delete(node.attrs.id);\n\n    if (blocksToInsert.length > 0 && node.attrs.id === idOfFirstBlock) {\n      const oldDocSize = tr.doc.nodeSize;\n      tr.insert(pos, nodesToInsert);\n      const newDocSize = tr.doc.nodeSize;\n\n      removedSize += oldDocSize - newDocSize;\n    }\n\n    const oldDocSize = tr.doc.nodeSize;\n\n    const $pos = tr.doc.resolve(pos - removedSize);\n\n    if ($pos.node().type.name === \"column\") {\n      columnListPositions.add($pos.before(-1));\n    } else if ($pos.node().type.name === \"columnList\") {\n      columnListPositions.add($pos.before());\n    }\n\n    if (\n      $pos.node().type.name === \"blockGroup\" &&\n      $pos.node($pos.depth - 1).type.name !== \"doc\" &&\n      $pos.node().childCount === 1\n    ) {\n      // Checks if the block is the only child of a parent `blockGroup` node.\n      // In this case, we need to delete the parent `blockGroup` node instead\n      // of just the `blockContainer`.\n      tr.delete($pos.before(), $pos.after());\n    } else {\n      tr.delete(pos - removedSize, pos - removedSize + node.nodeSize);\n    }\n\n    const newDocSize = tr.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  // Throws an error if not all blocks could be found.\n  if (idsOfBlocksToRemove.size > 0) {\n    const notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds,\n    );\n  }\n\n  columnListPositions.forEach((pos) => fixColumnList(tr, pos));\n\n  // Converts the nodes created from `blocksToInsert` into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return { insertedBlocks, removedBlocks };\n}\n","import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\n\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\nexport function serializeInlineContentInternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  blockType?: string,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema, blockType);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema, blockType);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method\n        const output = inlineContentImplementation.render.call(\n          {\n            renderType: \"dom\",\n            props: undefined,\n          },\n          inlineContent as any,\n          () => {\n            // No-op\n          },\n          editor as any,\n        );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = editor.schema.styleSpecs[\n            mark.type.name\n          ].implementation.render(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  return fragment;\n}\n\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n  const children = block.children || [];\n\n  const impl = editor.blockImplementations[block.type as any].implementation;\n  const ret = impl.render.call(\n    {\n      renderType: \"dom\",\n      props: undefined,\n    },\n    { ...block, props, children } as any,\n    editor as any,\n  );\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentInternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      block.type,\n      options,\n    );\n    ret.contentDOM.appendChild(ic);\n  }\n\n  const pmType = editor.pmSchema.nodes[block.type as any];\n\n  if (pmType.isInGroup(\"bnBlock\")) {\n    if (block.children && block.children.length > 0) {\n      const fragment = serializeBlocks(\n        editor,\n        block.children,\n        serializer,\n        options,\n      );\n\n      ret.contentDOM?.append(fragment);\n    }\n    return ret.dom;\n  }\n\n  // wrap the block in a blockContainer\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  bc.contentDOM?.appendChild(ret.dom);\n\n  if (block.children && block.children.length > 0) {\n    bc.contentDOM?.appendChild(\n      serializeBlocksInternalHTML(editor, block.children, serializer, options),\n    );\n  }\n  return bc.dom;\n}\n\nfunction serializeBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const block of blocks) {\n    const blockDOM = serializeBlock(editor, block, serializer, options);\n    fragment.appendChild(blockDOM);\n  }\n\n  return fragment;\n}\n\nexport const serializeBlocksInternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) => {\n  const BG_NODE = editor.pmSchema.nodes[\"blockGroup\"];\n\n  const bg = BG_NODE.spec!.toDOM!(BG_NODE.create({})) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  const fragment = serializeBlocks(editor, blocks, serializer, options);\n\n  bg.contentDOM?.appendChild(fragment);\n\n  return bg.dom;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { serializeBlocksInternalHTML } from \"./util/serializeBlocksInternalHTML.js\";\n// Used to serialize BlockNote blocks and ProseMirror nodes to HTML without\n// losing data. Blocks are exported using the `toInternalHTML` method in their\n// `blockSpec`.\n//\n// The HTML created by this serializer is the same as what's rendered by the\n// editor to the DOM. This means that it retains the same structure as the\n// editor, including the `blockGroup` and `blockContainer` wrappers. This also\n// means that it can be converted back to the original blocks without any data\n// loss.\nexport const createInternalHTMLSerializer = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    serializeBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      return serializeBlocksInternalHTML(editor, blocks, serializer, options)\n        .outerHTML;\n    },\n  };\n};\n","import {\n  NodeSelection,\n  Selection,\n  TextSelection,\n  Transaction,\n} from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\n\nimport { Block } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor\";\nimport { BlockIdentifier } from \"../../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../../getBlockInfoFromPos.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\n\ntype BlockSelectionData = (\n  | {\n      type: \"text\";\n      headBlockId: string;\n      anchorOffset: number;\n      headOffset: number;\n    }\n  | {\n      type: \"node\";\n    }\n  | {\n      type: \"cell\";\n      anchorCellOffset: number;\n      headCellOffset: number;\n    }\n) & {\n  anchorBlockId: string;\n};\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param editor The BlockNote editor instance to get the selection data from.\n */\nfunction getBlockSelectionData(\n  editor: BlockNoteEditor<any, any, any>,\n): BlockSelectionData {\n  return editor.transact((tr) => {\n    const anchorBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.anchor);\n\n    if (tr.selection instanceof CellSelection) {\n      return {\n        type: \"cell\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        anchorCellOffset:\n          tr.selection.$anchorCell.pos - anchorBlockPosInfo.posBeforeNode,\n        headCellOffset:\n          tr.selection.$headCell.pos - anchorBlockPosInfo.posBeforeNode,\n      };\n    } else if (tr.selection instanceof NodeSelection) {\n      return {\n        type: \"node\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n      };\n    } else {\n      const headBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.head);\n\n      return {\n        type: \"text\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        headBlockId: headBlockPosInfo.node.attrs.id,\n        anchorOffset: tr.selection.anchor - anchorBlockPosInfo.posBeforeNode,\n        headOffset: tr.selection.head - headBlockPosInfo.posBeforeNode,\n      };\n    }\n  });\n}\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param tr The transaction to update the selection in.\n * @param data The selection data to update the selection with (generated by\n * `getBlockSelectionData`).\n */\nfunction updateBlockSelectionFromData(\n  tr: Transaction,\n  data: BlockSelectionData,\n) {\n  const anchorBlockPos = getNodeById(data.anchorBlockId, tr.doc)?.posBeforeNode;\n  if (anchorBlockPos === undefined) {\n    throw new Error(\n      `Could not find block with ID ${data.anchorBlockId} to update selection`,\n    );\n  }\n\n  let selection: Selection;\n  if (data.type === \"cell\") {\n    selection = CellSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorCellOffset,\n      anchorBlockPos + data.headCellOffset,\n    );\n  } else if (data.type === \"node\") {\n    selection = NodeSelection.create(tr.doc, anchorBlockPos + 1);\n  } else {\n    const headBlockPos = getNodeById(data.headBlockId, tr.doc)?.posBeforeNode;\n    if (headBlockPos === undefined) {\n      throw new Error(\n        `Could not find block with ID ${data.headBlockId} to update selection`,\n      );\n    }\n\n    selection = TextSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorOffset,\n      headBlockPos + data.headOffset,\n    );\n  }\n\n  tr.setSelection(selection);\n}\n\n/**\n * Replaces any `columnList` blocks with the children of their columns. This is\n * done here instead of in `getSelection` as we still need to remove the entire\n * `columnList` node but only insert the `blockContainer` nodes inside it.\n * @param blocks The blocks to flatten.\n */\nfunction flattenColumns(\n  blocks: Block<any, any, any>[],\n): Block<any, any, any>[] {\n  return blocks\n    .map((block) => {\n      if (block.type === \"columnList\") {\n        return block.children\n          .map((column) => flattenColumns(column.children))\n          .flat();\n      }\n\n      return {\n        ...block,\n        children: flattenColumns(block.children),\n      };\n    })\n    .flat();\n}\n\n/**\n * Removes the selected blocks from the editor, then inserts them before/after a\n * reference block. Also updates the selection to match the original selection\n * using `getBlockSelectionData` and `updateBlockSelectionFromData`.\n * @param editor The BlockNote editor instance to move the blocks in.\n * @param referenceBlock The reference block to insert the selected blocks\n * before/after.\n * @param placement Whether to insert the selected blocks before or after the\n * reference block.\n */\nexport function moveSelectedBlocksAndSelection(\n  editor: BlockNoteEditor<any, any, any>,\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\",\n) {\n  // We want this to be a single step in the undo history\n  editor.transact((tr) => {\n    const blocks = editor.getSelection()?.blocks || [\n      editor.getTextCursorPosition().block,\n    ];\n    const selectionData = getBlockSelectionData(editor);\n\n    editor.removeBlocks(blocks);\n    editor.insertBlocks(flattenColumns(blocks), referenceBlock, placement);\n\n    updateBlockSelectionFromData(tr, selectionData);\n  });\n}\n\n// Checks if a block is in a valid place after being moved. This check is\n// primitive at the moment and only returns false if the block's parent is a\n// `columnList` block. This is because regular blocks cannot be direct children\n// of `columnList` blocks.\nfunction checkPlacementIsValid(parentBlock?: Block<any, any, any>): boolean {\n  return !parentBlock || parentBlock.type !== \"columnList\";\n}\n\n// Gets the placement for moving a block up. This has 3 cases:\n// 1. If the block has a previous sibling without children, the placement is\n// before it.\n// 2. If the block has a previous sibling with children, the placement is after\n// the last child.\n// 3. If the block has no previous sibling, but is nested, the placement is\n// before its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the top of the document.\nfunction getMoveUpPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  prevBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!prevBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"before\";\n    }\n  } else if (prevBlock.children.length > 0) {\n    referenceBlock = prevBlock.children[prevBlock.children.length - 1];\n    placement = \"after\";\n  } else {\n    referenceBlock = prevBlock;\n    placement = \"before\";\n  }\n\n  // Case when the block is already at the top of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveUpPlacement(\n      editor,\n      placement === \"after\"\n        ? referenceBlock\n        : editor.getPrevBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\n// Gets the placement for moving a block down. This has 3 cases:\n// 1. If the block has a next sibling without children, the placement is  after\n// it.\n// 2. If the block has a next sibling with children, the placement is before the\n// first child.\n// 3. If the block has no next sibling, but is nested, the placement is\n// after its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the bottom of the document.\nfunction getMoveDownPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  nextBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!nextBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"after\";\n    }\n  } else if (nextBlock.children.length > 0) {\n    referenceBlock = nextBlock.children[0];\n    placement = \"before\";\n  } else {\n    referenceBlock = nextBlock;\n    placement = \"after\";\n  }\n\n  // Case when the block is already at the bottom of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveDownPlacement(\n      editor,\n      placement === \"before\"\n        ? referenceBlock\n        : editor.getNextBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\nexport function moveBlocksUp(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block = selection?.blocks[0] || editor.getTextCursorPosition().block;\n\n    const moveUpPlacement = getMoveUpPlacement(\n      editor,\n      editor.getPrevBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveUpPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveUpPlacement.referenceBlock,\n      moveUpPlacement.placement,\n    );\n  });\n}\n\nexport function moveBlocksDown(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block =\n      selection?.blocks[selection?.blocks.length - 1] ||\n      editor.getTextCursorPosition().block;\n\n    const moveDownPlacement = getMoveDownPlacement(\n      editor,\n      editor.getNextBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveDownPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveDownPlacement.referenceBlock,\n      moveDownPlacement.placement,\n    );\n  });\n}\n","import { Fragment, NodeType, Slice } from \"prosemirror-model\";\nimport { Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\nimport { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport { getBlockInfoFromTransaction } from \"../../../getBlockInfoFromPos.js\";\n\n// TODO: Unit tests\n/**\n * This is a modified version of https://github.com/ProseMirror/prosemirror-schema-list/blob/569c2770cbb8092d8f11ea53ecf78cb7a4e8f15a/src/schema-list.ts#L232\n *\n * The original function derives too many information from the parentnode and itemtype\n */\nfunction sinkListItem(\n  tr: Transaction,\n  itemType: NodeType,\n  groupType: NodeType,\n) {\n  const { $from, $to } = tr.selection;\n  const range = $from.blockRange(\n    $to,\n    (node) =>\n      node.childCount > 0 &&\n      (node.type.name === \"blockGroup\" || node.type.name === \"column\"), // change necessary to not look at first item child type\n  );\n  if (!range) {\n    return false;\n  }\n  const startIndex = range.startIndex;\n  if (startIndex === 0) {\n    return false;\n  }\n  const parent = range.parent;\n  const nodeBefore = parent.child(startIndex - 1);\n  if (nodeBefore.type !== itemType) {\n    return false;\n  }\n  const nestedBefore =\n    nodeBefore.lastChild && nodeBefore.lastChild.type === groupType; // change necessary to check groupType instead of parent.type\n  const inner = Fragment.from(nestedBefore ? itemType.create() : null);\n  const slice = new Slice(\n    Fragment.from(\n      itemType.create(null, Fragment.from(groupType.create(null, inner))), // change necessary to create \"groupType\" instead of parent.type\n    ),\n    nestedBefore ? 3 : 1,\n    0,\n  );\n\n  const before = range.start;\n  const after = range.end;\n\n  tr.step(\n    new ReplaceAroundStep(\n      before - (nestedBefore ? 3 : 1),\n      after,\n      before,\n      after,\n      slice,\n      1,\n      true,\n    ),\n  ).scrollIntoView();\n\n  return true;\n}\n\nexport function nestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    return sinkListItem(\n      tr,\n      editor.pmSchema.nodes[\"blockContainer\"],\n      editor.pmSchema.nodes[\"blockGroup\"],\n    );\n  });\n}\n\nexport function unnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  editor._tiptapEditor.commands.liftListItem(\"blockContainer\");\n}\n\nexport function canNestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).nodeBefore !== null;\n  });\n}\n\nexport function canUnnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).depth > 1;\n  });\n}\n","import type { Node } from \"prosemirror-model\";\nimport type { Block } from \"../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getPmSchema } from \"../../pmUtil.js\";\n\nexport function getBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  return nodeToBlock(posInfo.node, pmSchema);\n}\n\nexport function getPrevBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const nodeToConvert = $posBeforeNode.nodeBefore;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getNextBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posAfterNode = doc.resolve(\n    posInfo.posBeforeNode + posInfo.node.nodeSize,\n  );\n  const nodeToConvert = $posAfterNode.nodeAfter;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getParentBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const parentNode = $posBeforeNode.node();\n  const grandparentNode = $posBeforeNode.node(-1);\n  const nodeToConvert =\n    grandparentNode.type.name !== \"doc\"\n      ? parentNode.type.name === \"blockGroup\"\n        ? grandparentNode\n        : parentNode\n      : undefined;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n","import { insertBlocks } from \"../../api/blockManipulation/commands/insertBlocks/insertBlocks.js\";\nimport {\n  moveBlocksDown,\n  moveBlocksUp,\n} from \"../../api/blockManipulation/commands/moveBlocks/moveBlocks.js\";\nimport {\n  canNestBlock,\n  canUnnestBlock,\n  nestBlock,\n  unnestBlock,\n} from \"../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { removeAndInsertBlocks } from \"../../api/blockManipulation/commands/replaceBlocks/replaceBlocks.js\";\nimport { updateBlock } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport {\n  getBlock,\n  getNextBlock,\n  getParentBlock,\n  getPrevBlock,\n} from \"../../api/blockManipulation/getBlock/getBlock.js\";\nimport { docToBlocks } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class BlockManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this.editor.transact((tr) => {\n      return docToBlocks(tr.doc, this.editor.pmSchema);\n    });\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getPrevBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getNextBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) =>\n      getParentBlock(tr.doc, blockIdentifier),\n    );\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    const blocks = this.document.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(\n      blockArray: Block<BSchema, ISchema, SSchema>[],\n    ): boolean {\n      for (const block of blockArray) {\n        if (callback(block) === false) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this.editor.transact((tr) =>\n      insertBlocks(tr, blocksToInsert, referenceBlock, placement),\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this.editor.transact((tr) => updateBlock(tr, blockToUpdate, update));\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this.editor.transact(\n      (tr) => removeAndInsertBlocks(tr, blocksToRemove, []).removedBlocks,\n    );\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this.editor.transact((tr) =>\n      removeAndInsertBlocks(tr, blocksToRemove, blocksToInsert),\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return canNestBlock(this.editor);\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    nestBlock(this.editor);\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return canUnnestBlock(this.editor);\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    unnestBlock(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return moveBlocksUp(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return moveBlocksDown(this.editor);\n  }\n}\n","import type { BlockNoteEditor } from \"../BlockNoteEditor.js\";\nimport {\n  getBlocksChangedByTransaction,\n  type BlocksChanged,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { Transaction } from \"prosemirror-state\";\nimport { EventEmitter } from \"../../util/EventEmitter.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\n/**\n * A function that can be used to unsubscribe from an event.\n */\nexport type Unsubscribe = () => void;\n\n/**\n * EventManager is a class which manages the events of the editor\n */\nexport class EventManager<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends EventEmitter<{\n  onChange: [\n    ctx: {\n      editor: BlockNoteEditor<BSchema, I, S>;\n      transaction: Transaction;\n      appendedTransactions: Transaction[];\n    },\n  ];\n  onSelectionChange: [\n    ctx: { editor: BlockNoteEditor<BSchema, I, S>; transaction: Transaction },\n  ];\n  onMount: [ctx: { editor: BlockNoteEditor<BSchema, I, S> }];\n  onUnmount: [ctx: { editor: BlockNoteEditor<BSchema, I, S> }];\n}> {\n  constructor(private editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    // We register tiptap events only once the editor is finished initializing\n    // otherwise we would be trying to register events on a tiptap editor which does not exist yet\n    editor.on(\"create\", () => {\n      editor._tiptapEditor.on(\n        \"update\",\n        ({ transaction, appendedTransactions }) => {\n          this.emit(\"onChange\", { editor, transaction, appendedTransactions });\n        },\n      );\n      editor._tiptapEditor.on(\"selectionUpdate\", ({ transaction }) => {\n        this.emit(\"onSelectionChange\", { editor, transaction });\n      });\n      editor._tiptapEditor.on(\"mount\", () => {\n        this.emit(\"onMount\", { editor });\n      });\n      editor._tiptapEditor.on(\"unmount\", () => {\n        this.emit(\"onUnmount\", { editor });\n      });\n    });\n  }\n\n  /**\n   * Register a callback that will be called when the editor changes.\n   */\n  public onChange(\n    callback: (\n      editor: BlockNoteEditor<BSchema, I, S>,\n      ctx: {\n        getChanges(): BlocksChanged<BSchema, I, S>;\n      },\n    ) => void,\n    /**\n     * If true, the callback will be triggered when the changes are caused by a remote user\n     * @default true\n     */\n    includeUpdatesFromRemote = true,\n  ): Unsubscribe {\n    const cb = ({\n      transaction,\n      appendedTransactions,\n    }: {\n      transaction: Transaction;\n      appendedTransactions: Transaction[];\n    }) => {\n      if (!includeUpdatesFromRemote && isRemoteTransaction(transaction)) {\n        // don't trigger the callback if the changes are caused by a remote user\n        return;\n      }\n      callback(this.editor, {\n        getChanges() {\n          return getBlocksChangedByTransaction(\n            transaction,\n            appendedTransactions,\n          );\n        },\n      });\n    };\n    this.on(\"onChange\", cb);\n\n    return () => {\n      this.off(\"onChange\", cb);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the selection changes.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, I, S>) => void,\n    /**\n     * If true, the callback will be triggered when the selection changes due to a yjs sync (i.e.: other user was typing)\n     */\n    includeSelectionChangedByRemote = false,\n  ): Unsubscribe {\n    const cb = (e: { transaction: Transaction }) => {\n      if (\n        !includeSelectionChangedByRemote &&\n        isRemoteTransaction(e.transaction)\n      ) {\n        // don't trigger the callback if the selection changed because of a remote user\n        return;\n      }\n      callback(this.editor);\n    };\n\n    this.on(\"onSelectionChange\", cb);\n\n    return () => {\n      this.off(\"onSelectionChange\", cb);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is mounted.\n   */\n  public onMount(\n    callback: (ctx: { editor: BlockNoteEditor<BSchema, I, S> }) => void,\n  ): Unsubscribe {\n    this.on(\"onMount\", callback);\n\n    return () => {\n      this.off(\"onMount\", callback);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is unmounted.\n   */\n  public onUnmount(\n    callback: (ctx: { editor: BlockNoteEditor<BSchema, I, S> }) => void,\n  ): Unsubscribe {\n    this.on(\"onUnmount\", callback);\n\n    return () => {\n      this.off(\"onUnmount\", callback);\n    };\n  }\n}\n\nfunction isRemoteTransaction(transaction: Transaction): boolean {\n  return !!transaction.getMeta(\"y-sync$\");\n}\n","function getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\nfunction isWhitespaceNode(node: Node) {\n  return node.nodeType === 3 && !/\\S/.test(node.nodeValue || \"\");\n}\n\n/**\n * Step 1, Turns:\n *\n * <ul>\n *  <li>item</li>\n *  <li>\n *   <ul>\n *      <li>...</li>\n *      <li>...</li>\n *   </ul>\n * </li>\n *\n * Into:\n * <ul>\n *  <li>item</li>\n *  <ul>\n *      <li>...</li>\n *      <li>...</li>\n *  </ul>\n * </ul>\n *\n */\nfunction liftNestedListsToParent(element: HTMLElement) {\n  element.querySelectorAll(\"li > ul, li > ol\").forEach((list) => {\n    const index = getChildIndex(list);\n    const parentListItem = list.parentElement!;\n    const siblingsAfter = Array.from(parentListItem.childNodes).slice(\n      index + 1,\n    );\n    list.remove();\n    siblingsAfter.forEach((sibling) => {\n      sibling.remove();\n    });\n\n    parentListItem.insertAdjacentElement(\"afterend\", list);\n\n    siblingsAfter.reverse().forEach((sibling) => {\n      if (isWhitespaceNode(sibling)) {\n        return;\n      }\n      const siblingContainer = document.createElement(\"li\");\n      siblingContainer.append(sibling);\n      list.insertAdjacentElement(\"afterend\", siblingContainer);\n    });\n    if (parentListItem.childNodes.length === 0) {\n      parentListItem.remove();\n    }\n  });\n}\n\n/**\n * Step 2, Turns (output of liftNestedListsToParent):\n *\n * <li>item</li>\n * <ul>\n *   <li>...</li>\n *   <li>...</li>\n * </ul>\n *\n * Into:\n * <div>\n *  <li>item</li>\n *  <div data-node-type=\"blockGroup\">\n *      <ul>\n *          <li>...</li>\n *          <li>...</li>\n *      </ul>\n *  </div>\n * </div>\n *\n * This resulting format is parsed\n */\nfunction createGroups(element: HTMLElement) {\n  element.querySelectorAll(\"li + ul, li + ol\").forEach((list) => {\n    const listItem = list.previousElementSibling as HTMLElement;\n    const blockContainer = document.createElement(\"div\");\n\n    listItem.insertAdjacentElement(\"afterend\", blockContainer);\n    blockContainer.append(listItem);\n\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    blockContainer.append(blockGroup);\n\n    while (\n      blockContainer.nextElementSibling?.nodeName === \"UL\" ||\n      blockContainer.nextElementSibling?.nodeName === \"OL\"\n    ) {\n      blockGroup.append(blockContainer.nextElementSibling);\n    }\n  });\n}\n\n// prevent XSS, similar to https://github.com/ProseMirror/prosemirror-view/blob/1251b2b412656a2a06263e4187574beb43651273/src/clipboard.ts#L204\n// https://github.com/TypeCellOS/BlockNote/issues/601\nlet _detachedDoc: Document | null = null;\nfunction detachedDoc() {\n  return (\n    _detachedDoc ||\n    (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n  );\n}\n\nexport function nestedListsToBlockNoteStructure(\n  elementOrHTML: HTMLElement | string,\n) {\n  if (typeof elementOrHTML === \"string\") {\n    const element = detachedDoc().createElement(\"div\");\n    element.innerHTML = elementOrHTML;\n    elementOrHTML = element;\n  }\n  liftNestedListsToParent(elementOrHTML);\n  createGroups(elementOrHTML);\n  return elementOrHTML;\n}\n","import { DOMParser, Schema } from \"prosemirror-model\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { nestedListsToBlockNoteStructure } from \"./util/nestedLists.js\";\n\nexport function HTMLToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(html: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlNode = nestedListsToBlockNoteStructure(html);\n  const parser = DOMParser.fromSchema(pmSchema);\n\n  // Other approach might be to use\n  // const doc = pmSchema.nodes[\"doc\"].createAndFill()!;\n  // and context: doc.resolve(3),\n\n  const parentNode = parser.parse(htmlNode, {\n    topNode: pmSchema.nodes[\"blockGroup\"].create(),\n  });\n\n  const blocks: Block<BSchema, I, S>[] = [];\n\n  for (let i = 0; i < parentNode.childCount; i++) {\n    blocks.push(nodeToBlock(parentNode.child(i), pmSchema));\n  }\n\n  return blocks;\n}\n","import { Schema } from \"prosemirror-model\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype, {\n  defaultHandlers as remarkRehypeDefaultHandlers,\n} from \"remark-rehype\";\nimport rehypeStringify from \"rehype-stringify\";\nimport { unified } from \"unified\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { HTMLToBlocks } from \"../html/parseHTML.js\";\nimport { isVideoUrl } from \"../../../util/string.js\";\n\n// modified version of https://github.com/syntax-tree/mdast-util-to-hast/blob/main/lib/handlers/code.js\n// that outputs a data-language attribute instead of a CSS class (e.g.: language-typescript)\nfunction code(state: any, node: any) {\n  const value = node.value ? node.value : \"\";\n  /** @type {Properties} */\n  const properties: any = {};\n\n  if (node.lang) {\n    // changed line\n    properties[\"data-language\"] = node.lang;\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result: any = {\n    type: \"element\",\n    tagName: \"code\",\n    properties,\n    children: [{ type: \"text\", value }],\n  };\n\n  if (node.meta) {\n    result.data = { meta: node.meta };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result);\n\n  // Create `<pre>`.\n  result = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [result],\n  };\n  state.patch(node, result);\n  return result;\n}\n\nfunction video(state: any, node: any) {\n  const url = String(node?.url || \"\");\n  const title = node?.title ? String(node.title) : undefined;\n\n  let result: any = {\n    type: \"element\",\n    tagName: \"video\",\n    properties: {\n      src: url,\n      \"data-name\": title,\n      \"data-url\": url,\n      controls: true,\n    },\n    children: [],\n  };\n  state.patch?.(node, result);\n  result = state.applyData ? state.applyData(node, result) : result;\n\n  return result;\n}\n\nexport function markdownToHTML(markdown: string): string {\n  const htmlString = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype, {\n      handlers: {\n        ...(remarkRehypeDefaultHandlers as any),\n        image: (state: any, node: any) => {\n          const url = String(node?.url || \"\");\n\n          if (isVideoUrl(url)) {\n            return video(state, node);\n          } else {\n            return remarkRehypeDefaultHandlers.image(state, node);\n          }\n        },\n        code,\n      },\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return htmlString.value as string;\n}\n\nexport function markdownToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(markdown: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlString = markdownToHTML(markdown);\n\n  return HTMLToBlocks(htmlString, pmSchema);\n}\n","import { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { createInternalHTMLSerializer } from \"../../api/exporters/html/internalHTMLSerializer.js\";\nimport { blocksToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { HTMLToBlocks } from \"../../api/parsers/html/parseHTML.js\";\nimport {\n  markdownToBlocks,\n  markdownToHTML,\n} from \"../../api/parsers/markdown/parseMarkdown.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class ExportManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    const exporter = createExternalHTMLExporter(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.exportBlocks(blocks, {});\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    const exporter = createInternalHTMLSerializer(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.serializeBlocks(blocks, {});\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return HTMLToBlocks(html, this.editor.pmSchema);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    return blocksToMarkdown(blocks, this.editor.pmSchema, this.editor, {});\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return markdownToBlocks(markdown, this.editor.pmSchema);\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    let htmlToPaste = html;\n    if (!raw) {\n      const blocks = this.tryParseHTMLToBlocks(html);\n      htmlToPaste = this.blocksToFullHTML(blocks);\n    }\n    if (!htmlToPaste) {\n      return;\n    }\n    this.editor.prosemirrorView?.pasteHTML(htmlToPaste);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this.editor.prosemirrorView?.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    const html = markdownToHTML(markdown);\n    return this.pasteHTML(html);\n  }\n}\n","export const acceptedMIMETypes = [\n  \"vscode-editor-data\",\n  \"blocknote/html\",\n  \"text/markdown\",\n  \"text/html\",\n  \"text/plain\",\n  \"Files\",\n] as const;\n","import { Block, PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\n\nfunction checkFileExtensionsMatch(\n  fileExtension1: string,\n  fileExtension2: string,\n) {\n  if (!fileExtension1.startsWith(\".\") || !fileExtension2.startsWith(\".\")) {\n    throw new Error(`The strings provided are not valid file extensions.`);\n  }\n\n  return fileExtension1 === fileExtension2;\n}\n\nfunction checkMIMETypesMatch(mimeType1: string, mimeType2: string) {\n  const types1 = mimeType1.split(\"/\");\n  const types2 = mimeType2.split(\"/\");\n\n  if (types1.length !== 2) {\n    throw new Error(`The string ${mimeType1} is not a valid MIME type.`);\n  }\n  if (types2.length !== 2) {\n    throw new Error(`The string ${mimeType2} is not a valid MIME type.`);\n  }\n\n  if (types1[1] === \"*\" || types2[1] === \"*\") {\n    return types1[0] === types2[0];\n  }\n  if (types1[0] === \"*\" || types2[0] === \"*\") {\n    return types1[1] === types2[1];\n  }\n\n  return types1[0] === types2[0] && types1[1] === types2[1];\n}\n\nfunction insertOrUpdateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  referenceBlock: Block<BSchema, I, S>,\n  newBlock: PartialBlock<BSchema, I, S>,\n  placement: \"before\" | \"after\" = \"after\",\n) {\n  let insertedBlockId: string | undefined;\n\n  if (\n    Array.isArray(referenceBlock.content) &&\n    referenceBlock.content.length === 0\n  ) {\n    insertedBlockId = editor.updateBlock(referenceBlock, newBlock).id;\n  } else {\n    insertedBlockId = editor.insertBlocks(\n      [newBlock],\n      referenceBlock,\n      placement,\n    )[0].id;\n  }\n\n  return insertedBlockId;\n}\n\nexport async function handleFileInsertion<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(event: DragEvent | ClipboardEvent, editor: BlockNoteEditor<BSchema, I, S>) {\n  if (!editor.uploadFile) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"Attempted ot insert file, but uploadFile is not set in the BlockNote editor options\",\n    );\n    return;\n  }\n\n  const dataTransfer =\n    \"dataTransfer\" in event ? event.dataTransfer : event.clipboardData;\n  if (dataTransfer === null) {\n    return;\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | null = null;\n  for (const mimeType of acceptedMIMETypes) {\n    if (dataTransfer.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n  if (format !== \"Files\") {\n    return;\n  }\n\n  const items = dataTransfer.items;\n  if (!items) {\n    return;\n  }\n\n  event.preventDefault();\n\n  for (let i = 0; i < items.length; i++) {\n    // Gets file block corresponding to MIME type.\n    let fileBlockType = \"file\";\n    for (const blockSpec of Object.values(editor.schema.blockSpecs)) {\n      for (const mimeType of blockSpec.implementation.meta?.fileBlockAccept ||\n        []) {\n        const isFileExtension = mimeType.startsWith(\".\");\n        const file = items[i].getAsFile();\n\n        if (file) {\n          if (\n            (!isFileExtension &&\n              file.type &&\n              checkMIMETypesMatch(items[i].type, mimeType)) ||\n            (isFileExtension &&\n              checkFileExtensionsMatch(\n                \".\" + file.name.split(\".\").pop(),\n                mimeType,\n              ))\n          ) {\n            fileBlockType = blockSpec.config.type;\n            break;\n          }\n        }\n      }\n    }\n\n    const file = items[i].getAsFile();\n    if (file) {\n      const fileBlock = {\n        type: fileBlockType,\n        props: {\n          name: file.name,\n        },\n      } as PartialBlock<BSchema, I, S>;\n\n      let insertedBlockId: string | undefined = undefined;\n\n      if (event.type === \"paste\") {\n        const currentBlock = editor.getTextCursorPosition().block;\n        insertedBlockId = insertOrUpdateBlock(editor, currentBlock, fileBlock);\n      } else if (event.type === \"drop\") {\n        const coords = {\n          left: (event as DragEvent).clientX,\n          top: (event as DragEvent).clientY,\n        };\n\n        const pos = editor.prosemirrorView.posAtCoords(coords);\n\n        if (!pos) {\n          return;\n        }\n\n        insertedBlockId = editor.transact((tr) => {\n          const posInfo = getNearestBlockPos(tr.doc, pos.pos);\n          const blockElement = editor.prosemirrorView.dom.querySelector(\n            `[data-id=\"${posInfo.node.attrs.id}\"]`,\n          );\n\n          const blockRect = blockElement?.getBoundingClientRect();\n\n          return insertOrUpdateBlock(\n            editor,\n            editor.getBlock(posInfo.node.attrs.id)!,\n            fileBlock,\n            blockRect && (blockRect.top + blockRect.bottom) / 2 > coords.top\n              ? \"before\"\n              : \"after\",\n          );\n        });\n      } else {\n        return;\n      }\n\n      const updateData = await editor.uploadFile(file, insertedBlockId);\n\n      const updatedFileBlock =\n        typeof updateData === \"string\"\n          ? ({\n              props: {\n                url: updateData,\n              },\n            } as PartialBlock<BSchema, I, S>)\n          : { ...updateData };\n\n      editor.updateBlock(insertedBlockId, updatedFileBlock);\n    }\n  }\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\n\nexport const createDropFileExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"dropFile\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              drop(_view, event) {\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                let format: (typeof acceptedMIMETypes)[number] | null = null;\n                for (const mimeType of acceptedMIMETypes) {\n                  if (event.dataTransfer!.types.includes(mimeType)) {\n                    format = mimeType;\n                    break;\n                  }\n                }\n                if (format === null) {\n                  return true;\n                }\n\n                if (format === \"Files\") {\n                  handleFileInsertion(event, editor);\n                  return true;\n                }\n\n                return false;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","// Headings H1-H6.\nconst h1 = /(^|\\n) {0,3}#{1,6} {1,8}[^\\n]{1,64}\\r?\\n\\r?\\n\\s{0,32}\\S/;\n\n// Bold, italic, underline, strikethrough, highlight.\nconst bold =\n  /(_|__|\\*|\\*\\*|~~|==|\\+\\+)(?!\\s)(?:[^\\s](?:.{0,62}[^\\s])?|\\S)(?=\\1)/;\n\n// Basic inline link (also captures images).\nconst link = /\\[[^\\]]{1,128}\\]\\(https?:\\/\\/\\S{1,999}\\)/;\n\n// Inline code.\nconst code = /(?:\\s|^)`(?!\\s)(?:[^\\s`](?:[^`]{0,46}[^\\s`])?|[^\\s`])`([^\\w]|$)/;\n\n// Unordered list.\nconst ul = /(?:^|\\n)\\s{0,5}-\\s{1}[^\\n]+\\n\\s{0,15}-\\s/;\n\n// Ordered list.\nconst ol = /(?:^|\\n)\\s{0,5}\\d+\\.\\s{1}[^\\n]+\\n\\s{0,15}\\d+\\.\\s/;\n\n// Horizontal rule.\nconst hr = /\\n{2} {0,3}-{2,48}\\n{2}/;\n\n// Fenced code block.\nconst fences =\n  /(?:\\n|^)(```|~~~|\\$\\$)(?!`|~)[^\\s]{0,64} {0,64}[^\\n]{0,64}\\n[\\s\\S]{0,9999}?\\s*\\1 {0,64}(?:\\n+|$)/;\n\n// Classical underlined H1 and H2 headings.\nconst title = /(?:\\n|^)(?!\\s)\\w[^\\n]{0,64}\\r?\\n(-|=)\\1{0,64}\\n\\n\\s{0,64}(\\w|$)/;\n\n// Blockquote.\nconst blockquote =\n  /(?:^|(\\r?\\n\\r?\\n))( {0,3}>[^\\n]{1,333}\\n){1,999}($|(\\r?\\n))/;\n\n// Table Header\nconst tableHeader = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n// Table Divider\nconst tableDivider = /^\\s*\\|(\\s*[-:]+[-:]\\s*\\|)+\\s*$/m;\n\n// Table Row\nconst tableRow = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n/**\n * Returns `true` if the source text might be a markdown document.\n *\n * @param src Source text to analyze.\n */\nexport const isMarkdown = (src: string): boolean =>\n  h1.test(src) ||\n  bold.test(src) ||\n  link.test(src) ||\n  code.test(src) ||\n  ul.test(src) ||\n  ol.test(src) ||\n  hr.test(src) ||\n  fences.test(src) ||\n  title.test(src) ||\n  blockquote.test(src) ||\n  tableHeader.test(src) ||\n  tableDivider.test(src) ||\n  tableRow.test(src);\n","import { EditorView } from \"prosemirror-view\";\n\nexport async function handleVSCodePaste(\n  event: ClipboardEvent,\n  view: EditorView,\n) {\n  const { schema } = view.state;\n\n  if (!event.clipboardData) {\n    return false;\n  }\n\n  const text = event.clipboardData!.getData(\"text/plain\");\n\n  if (!text) {\n    return false;\n  }\n\n  if (!schema.nodes.codeBlock) {\n    view.pasteText(text);\n    return true;\n  }\n\n  const vscode = event.clipboardData!.getData(\"vscode-editor-data\");\n  const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n  const language = vscodeData?.mode;\n\n  if (!language) {\n    return false;\n  }\n\n  // strip carriage return chars from text pasted as code\n  // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n  view.pasteHTML(\n    `<pre><code class=\"language-${language}\">${text.replace(\n      /\\r\\n?/g,\n      \"\\n\",\n    )}</code></pre>`,\n  );\n\n  return true;\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../../editor/BlockNoteEditor\";\nimport { isMarkdown } from \"../../parsers/markdown/detectMarkdown.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\nimport { handleVSCodePaste } from \"./handleVSCodePaste.js\";\n\nfunction defaultPasteHandler({\n  event,\n  editor,\n  prioritizeMarkdownOverHTML,\n  plainTextAsMarkdown,\n}: {\n  event: ClipboardEvent;\n  editor: BlockNoteEditor<any, any, any>;\n  prioritizeMarkdownOverHTML: boolean;\n  plainTextAsMarkdown: boolean;\n}) {\n  // Special case for code blocks, as they do not support any rich text\n  // formatting, so we force pasting plain text.\n  const isInCodeBlock = editor.transact(\n    (tr) =>\n      tr.selection.$from.parent.type.spec.code &&\n      tr.selection.$to.parent.type.spec.code,\n  );\n\n  if (isInCodeBlock) {\n    const data = event.clipboardData?.getData(\"text/plain\");\n\n    if (data) {\n      editor.pasteText(data);\n\n      return true;\n    }\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | undefined;\n  for (const mimeType of acceptedMIMETypes) {\n    if (event.clipboardData!.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n\n  if (!format) {\n    return true;\n  }\n\n  if (format === \"vscode-editor-data\") {\n    handleVSCodePaste(event, editor.prosemirrorView);\n    return true;\n  }\n\n  if (format === \"Files\") {\n    handleFileInsertion(event, editor);\n    return true;\n  }\n\n  const data = event.clipboardData!.getData(format);\n\n  if (format === \"blocknote/html\") {\n    // Is blocknote/html, so no need to convert it\n    editor.pasteHTML(data, true);\n    return true;\n  }\n\n  if (format === \"text/markdown\") {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  if (prioritizeMarkdownOverHTML) {\n    // Use plain text instead of HTML if it looks like Markdown\n    const plainText = event.clipboardData!.getData(\"text/plain\");\n\n    if (isMarkdown(plainText)) {\n      editor.pasteMarkdown(plainText);\n      return true;\n    }\n  }\n\n  if (format === \"text/html\") {\n    editor.pasteHTML(data);\n    return true;\n  }\n\n  if (plainTextAsMarkdown) {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  editor.pasteText(data);\n  return true;\n}\n\nexport const createPasteFromClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  pasteHandler: Exclude<\n    BlockNoteEditorOptions<any, any, any>[\"pasteHandler\"],\n    undefined\n  >,\n) =>\n  Extension.create({\n    name: \"pasteFromClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              paste(_view, event) {\n                event.preventDefault();\n\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                return pasteHandler({\n                  event,\n                  editor,\n                  defaultPasteHandler: ({\n                    prioritizeMarkdownOverHTML = true,\n                    plainTextAsMarkdown = true,\n                  } = {}) => {\n                    return defaultPasteHandler({\n                      event,\n                      editor,\n                      prioritizeMarkdownOverHTML,\n                      plainTextAsMarkdown,\n                    });\n                  },\n                });\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { Fragment, Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin } from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../../exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../nodeConversions/fragmentToBlocks.js\";\nimport {\n  contentNodeToInlineContent,\n  contentNodeToTableContent,\n} from \"../../nodeConversions/nodeToBlock.js\";\n\nfunction fragmentToExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  selectedFragment: Fragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  let isWithinBlockContent = false;\n  const isWithinTable = view.state.selection instanceof CellSelection;\n\n  if (!isWithinTable) {\n    // Checks whether block ancestry should be included when creating external\n    // HTML. If the selection is within a block content node, the block ancestry\n    // is excluded as we only care about the inline content.\n    const fragmentWithoutParents = view.state.doc.slice(\n      view.state.selection.from,\n      view.state.selection.to,\n      false,\n    ).content;\n\n    const children = [];\n    for (let i = 0; i < fragmentWithoutParents.childCount; i++) {\n      children.push(fragmentWithoutParents.child(i));\n    }\n\n    isWithinBlockContent =\n      children.find(\n        (child) =>\n          child.type.isInGroup(\"bnBlock\") ||\n          child.type.name === \"blockGroup\" ||\n          child.type.spec.group === \"blockContent\",\n      ) === undefined;\n    if (isWithinBlockContent) {\n      selectedFragment = fragmentWithoutParents;\n    }\n  }\n\n  let externalHTML: string;\n\n  const externalHTMLExporter = createExternalHTMLExporter(\n    view.state.schema,\n    editor,\n  );\n\n  if (isWithinTable) {\n    if (selectedFragment.firstChild?.type.name === \"table\") {\n      // contentNodeToTableContent expects the fragment of the content of a table, not the table node itself\n      // but cellselection.content() returns the table node itself if all cells and columns are selected\n      selectedFragment = selectedFragment.firstChild.content;\n    }\n\n    // first convert selection to blocknote-style table content, and then\n    // pass this to the exporter\n    const ic = contentNodeToTableContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n\n    // Wrap in table to ensure correct parsing by spreadsheet applications\n    externalHTML = `<table>${externalHTMLExporter.exportInlineContent(\n      ic as any,\n      {},\n    )}</table>`;\n  } else if (isWithinBlockContent) {\n    // first convert selection to blocknote-style inline content, and then\n    // pass this to the exporter\n    const ic = contentNodeToInlineContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n    externalHTML = externalHTMLExporter.exportInlineContent(ic, {});\n  } else {\n    const blocks = fragmentToBlocks<BSchema, I, S>(selectedFragment);\n    externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n  }\n  return externalHTML;\n}\n\nexport function selectedFragmentToHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  editor: BlockNoteEditor<BSchema, I, S>,\n): {\n  clipboardHTML: string;\n  externalHTML: string;\n  markdown: string;\n} {\n  // Checks if a `blockContent` node is being copied and expands\n  // the selection to the parent `blockContainer` node. This is\n  // for the use-case in which only a block without content is\n  // selected, e.g. an image block.\n  if (\n    \"node\" in view.state.selection &&\n    (view.state.selection.node as Node).type.spec.group === \"blockContent\"\n  ) {\n    editor.transact((tr) =>\n      tr.setSelection(\n        new NodeSelection(tr.doc.resolve(view.state.selection.from - 1)),\n      ),\n    );\n  }\n\n  // Uses default ProseMirror clipboard serialization.\n  const clipboardHTML: string = view.serializeForClipboard(\n    view.state.selection.content(),\n  ).dom.innerHTML;\n\n  const selectedFragment = view.state.selection.content().content;\n\n  const externalHTML = fragmentToExternalHTML<BSchema, I, S>(\n    view,\n    selectedFragment,\n    editor,\n  );\n\n  const markdown = cleanHTMLToMarkdown(externalHTML);\n\n  return { clipboardHTML, externalHTML, markdown };\n}\n\nconst checkIfSelectionInNonEditableBlock = () => {\n  // Let browser handle event if selection is empty (nothing\n  // happens).\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) {\n    return true;\n  }\n\n  // Let browser handle event if it's within a non-editable\n  // \"island\". This means it's in selectable content within a\n  // non-editable block. We only need to check one node as it's\n  // not possible for the browser selection to start in an\n  // editable block and end in a non-editable one.\n  let node = selection.focusNode;\n  while (node) {\n    if (\n      node instanceof HTMLElement &&\n      node.getAttribute(\"contenteditable\") === \"false\"\n    ) {\n      return true;\n    }\n\n    node = node.parentElement;\n  }\n\n  return false;\n};\n\nconst copyToClipboard = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  view: EditorView,\n  event: ClipboardEvent,\n) => {\n  // Stops the default browser copy behaviour.\n  event.preventDefault();\n  event.clipboardData!.clearData();\n\n  const { clipboardHTML, externalHTML, markdown } = selectedFragmentToHTML(\n    view,\n    editor,\n  );\n\n  // TODO: Writing to other MIME types not working in Safari for\n  //  some reason.\n  event.clipboardData!.setData(\"blocknote/html\", clipboardHTML);\n  event.clipboardData!.setData(\"text/html\", externalHTML);\n  event.clipboardData!.setData(\"text/plain\", markdown);\n};\n\nexport const createCopyToClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"copyToClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              copy(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                // Prevent default PM handler to be called\n                return true;\n              },\n              cut(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                if (view.editable) {\n                  view.dispatch(view.state.tr.deleteSelection());\n                }\n                // Prevent default PM handler to be called\n                return true;\n              },\n              // This is for the use-case in which only a block without content\n              // is selected, e.g. an image block, and dragged (not using the\n              // drag handle).\n              dragstart(view, event) {\n                // Checks if a `NodeSelection` is active.\n                if (!(\"node\" in view.state.selection)) {\n                  return;\n                }\n\n                // Checks if a `blockContent` node is being dragged.\n                if (\n                  (view.state.selection.node as Node).type.spec.group !==\n                  \"blockContent\"\n                ) {\n                  return;\n                }\n\n                // Expands the selection to the parent `blockContainer` node.\n                editor.transact((tr) =>\n                  tr.setSelection(\n                    new NodeSelection(\n                      tr.doc.resolve(view.state.selection.from - 1),\n                    ),\n                  ),\n                );\n\n                // Stops the default browser drag start behaviour.\n                event.preventDefault();\n                event.dataTransfer!.clearData();\n\n                const { clipboardHTML, externalHTML, markdown } =\n                  selectedFragmentToHTML(view, editor);\n\n                // TODO: Writing to other MIME types not working in Safari for\n                //  some reason.\n                event.dataTransfer!.setData(\"blocknote/html\", clipboardHTML);\n                event.dataTransfer!.setData(\"text/html\", externalHTML);\n                event.dataTransfer!.setData(\"text/plain\", markdown);\n\n                // Prevent default PM handler to be called\n                return true;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { getBackgroundColorAttribute } from \"../../../blocks/defaultProps.js\";\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          backgroundColor: getBackgroundColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","// Stripped down version of the TipTap HardBreak extension:\n// https://github.com/ueberdosis/tiptap/blob/f3258d9ee5fb7979102fe63434f6ea4120507311/packages/extension-hard-break/src/hard-break.ts#L80\n// Changes:\n// - Removed options\n// - Removed keyboard shortcuts & moved them to the `KeyboardShortcutsExtension`\n// - Removed `setHardBreak` command (added a simpler version in the Shift+Enter\n// handler in `KeyboardShortcutsExtension`).\n// - Added priority\nimport { mergeAttributes, Node } from \"@tiptap/core\";\n\nexport const HardBreak = Node.create({\n  name: \"hardBreak\",\n\n  inline: true,\n\n  group: \"inline\",\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  priority: 10,\n\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  renderText() {\n    return \"\\n\";\n  },\n});\n","import { Node } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport {\n  BlockInfo,\n  getBlockInfoFromResolvedPos,\n} from \"../../../getBlockInfoFromPos.js\";\n\n/**\n * Returns the block info from the parent block\n * or undefined if we're at the root\n */\nexport const getParentBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  if ($pos.depth <= 1) {\n    return undefined;\n  }\n\n  // get start pos of parent\n  const parentBeforePos = $pos.posAtIndex(\n    $pos.index($pos.depth - 1),\n    $pos.depth - 1,\n  );\n\n  const parentBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(parentBeforePos),\n  );\n  return parentBlockInfo;\n};\n\n/**\n * Returns the block info from the sibling block before (above) the given block,\n * or undefined if the given block is the first sibling.\n */\nexport const getPrevBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  const indexInParent = $pos.index();\n\n  if (indexInParent === 0) {\n    return undefined;\n  }\n\n  const prevBlockBeforePos = $pos.posAtIndex(indexInParent - 1);\n\n  const prevBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(prevBlockBeforePos),\n  );\n  return prevBlockInfo;\n};\n\n/**\n * If a block has children like this:\n * A\n * - B\n * - C\n * -- D\n *\n * Then the bottom nested block returned is D.\n */\nexport const getBottomNestedBlockInfo = (doc: Node, blockInfo: BlockInfo) => {\n  while (blockInfo.childContainer) {\n    const group = blockInfo.childContainer.node;\n\n    const newPos = doc\n      .resolve(blockInfo.childContainer.beforePos + 1)\n      .posAtIndex(group.childCount - 1);\n    blockInfo = getBlockInfoFromResolvedPos(doc.resolve(newPos));\n  }\n\n  return blockInfo;\n};\n\nconst canMerge = (prevBlockInfo: BlockInfo, nextBlockInfo: BlockInfo) => {\n  return (\n    prevBlockInfo.isBlockContainer &&\n    prevBlockInfo.blockContent.node.type.spec.content === \"inline*\" &&\n    prevBlockInfo.blockContent.node.childCount > 0 &&\n    nextBlockInfo.isBlockContainer &&\n    nextBlockInfo.blockContent.node.type.spec.content === \"inline*\"\n  );\n};\n\nconst mergeBlocks = (\n  state: EditorState,\n  dispatch: ((args?: any) => any) | undefined,\n  prevBlockInfo: BlockInfo,\n  nextBlockInfo: BlockInfo,\n) => {\n  // Un-nests all children of the next block.\n  if (!nextBlockInfo.isBlockContainer) {\n    throw new Error(\n      `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but next block is not a block container`,\n    );\n  }\n\n  // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n  // group nodes.\n  if (nextBlockInfo.childContainer) {\n    const childBlocksStart = state.doc.resolve(\n      nextBlockInfo.childContainer.beforePos + 1,\n    );\n    const childBlocksEnd = state.doc.resolve(\n      nextBlockInfo.childContainer.afterPos - 1,\n    );\n    const childBlocksRange = childBlocksStart.blockRange(childBlocksEnd);\n\n    if (dispatch) {\n      const pos = state.doc.resolve(nextBlockInfo.bnBlock.beforePos);\n      state.tr.lift(childBlocksRange!, pos.depth);\n    }\n  }\n\n  // Deletes the boundary between the two blocks. Can be thought of as\n  // removing the closing tags of the first block and the opening tags of the\n  // second one to stitch them together.\n  if (dispatch) {\n    if (!prevBlockInfo.isBlockContainer) {\n      throw new Error(\n        `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but previous block is not a block container`,\n      );\n    }\n\n    // TODO: test merging between a columnList and paragraph, between two columnLists, and v.v.\n    dispatch(\n      state.tr.delete(\n        prevBlockInfo.blockContent.afterPos - 1,\n        nextBlockInfo.blockContent.beforePos + 1,\n      ),\n    );\n  }\n\n  return true;\n};\n\nexport const mergeBlocksCommand =\n  (posBetweenBlocks: number) =>\n  ({\n    state,\n    dispatch,\n  }: {\n    state: EditorState;\n    dispatch: ((args?: any) => any) | undefined;\n  }) => {\n    const $pos = state.doc.resolve(posBetweenBlocks);\n    const nextBlockInfo = getBlockInfoFromResolvedPos($pos);\n\n    const prevBlockInfo = getPrevBlockInfo(\n      state.doc,\n      nextBlockInfo.bnBlock.beforePos,\n    );\n\n    if (!prevBlockInfo) {\n      return false;\n    }\n\n    const bottomNestedBlockInfo = getBottomNestedBlockInfo(\n      state.doc,\n      prevBlockInfo,\n    );\n\n    if (!canMerge(bottomNestedBlockInfo, nextBlockInfo)) {\n      return false;\n    }\n\n    return mergeBlocks(state, dispatch, bottomNestedBlockInfo, nextBlockInfo);\n  };\n","import { Extension } from \"@tiptap/core\";\n\nimport { TextSelection } from \"prosemirror-state\";\nimport {\n  getBottomNestedBlockInfo,\n  getPrevBlockInfo,\n  mergeBlocksCommand,\n} from \"../../../api/blockManipulation/commands/mergeBlocks/mergeBlocks.js\";\nimport { nestBlock } from \"../../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { fixColumnList } from \"../../../api/blockManipulation/commands/replaceBlocks/util/fixColumnList.js\";\nimport { splitBlockCommand } from \"../../../api/blockManipulation/commands/splitBlock/splitBlock.js\";\nimport { updateBlockCommand } from \"../../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport { FormattingToolbarExtension } from \"../../FormattingToolbar/FormattingToolbar.js\";\nimport { FilePanelExtension } from \"../../FilePanel/FilePanel.js\";\n\nexport const KeyboardShortcutsExtension = Extension.create<{\n  editor: BlockNoteEditor<any, any, any>;\n  tabBehavior: \"prefer-navigate-ui\" | \"prefer-indent\";\n}>({\n  priority: 50,\n\n  // TODO: The shortcuts need a refactor. Do we want to use a command priority\n  //  design as there is now, or clump the logic into a single function?\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ chain, commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const isParagraph =\n              blockInfo.blockContent.node.type.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.command(\n                updateBlockCommand(blockInfo.bnBlock.beforePos, {\n                  type: \"paragraph\",\n                  props: {},\n                }),\n              );\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, and the selection is at the start of the\n        // block. The target block for merging must contain inline content.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const posBetweenBlocks = blockContainer.beforePos;\n\n            if (selectionAtBlockStart && selectionEmpty) {\n              return chain()\n                .command(mergeBlocksCommand(posBetweenBlocks))\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        () =>\n          commands.command(({ state, tr, dispatch }) => {\n            // when at the start of a first block in a column\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              tr.selection.from === blockInfo.blockContent.beforePos + 1;\n            if (!selectionAtBlockStart) {\n              return false;\n            }\n\n            const $pos = tr.doc.resolve(blockInfo.bnBlock.beforePos);\n\n            const prevBlock = $pos.nodeBefore;\n            if (prevBlock) {\n              // should be no previous block\n              return false;\n            }\n\n            const parentBlock = $pos.node();\n            if (parentBlock.type.name !== \"column\") {\n              return false;\n            }\n\n            const $blockPos = tr.doc.resolve(blockInfo.bnBlock.beforePos);\n            const $columnPos = tr.doc.resolve($blockPos.before());\n            const columnListPos = $columnPos.before();\n\n            if (dispatch) {\n              const fragment = tr.doc.slice(\n                blockInfo.bnBlock.beforePos,\n                blockInfo.bnBlock.afterPos,\n              ).content;\n\n              tr.delete(\n                blockInfo.bnBlock.beforePos,\n                blockInfo.bnBlock.afterPos,\n              );\n\n              if ($columnPos.index() === 0) {\n                // Fix `columnList` and insert the block before it.\n                fixColumnList(tr, columnListPos);\n                tr.insert(columnListPos, fragment);\n                tr.setSelection(\n                  TextSelection.near(tr.doc.resolve(columnListPos)),\n                );\n              } else {\n                // Insert the block at the end of the first column and fix\n                // `columnList`.\n                tr.insert($columnPos.pos - 1, fragment);\n                tr.setSelection(\n                  TextSelection.near(tr.doc.resolve($columnPos.pos - 1)),\n                );\n                fixColumnList(tr, columnListPos);\n              }\n            }\n\n            return true;\n          }),\n        // Deletes the current block if it's an empty block with inline content,\n        // and moves the selection to the previous block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const blockEmpty =\n              blockInfo.blockContent.node.childCount === 0 &&\n              blockInfo.blockContent.node.type.spec.content === \"inline*\";\n\n            if (blockEmpty) {\n              const prevBlockInfo = getPrevBlockInfo(\n                state.doc,\n                blockInfo.bnBlock.beforePos,\n              );\n              if (!prevBlockInfo || !prevBlockInfo.isBlockContainer) {\n                return false;\n              }\n\n              let chainedCommands = chain();\n\n              if (\n                prevBlockInfo.blockContent.node.type.spec.content ===\n                \"tableRow+\"\n              ) {\n                const tableBlockEndPos = blockInfo.bnBlock.beforePos - 1;\n                const tableBlockContentEndPos = tableBlockEndPos - 1;\n                const lastRowEndPos = tableBlockContentEndPos - 1;\n                const lastCellEndPos = lastRowEndPos - 1;\n                const lastCellParagraphEndPos = lastCellEndPos - 1;\n\n                chainedCommands = chainedCommands.setTextSelection(\n                  lastCellParagraphEndPos,\n                );\n              } else if (\n                prevBlockInfo.blockContent.node.type.spec.content === \"\"\n              ) {\n                const nonEditableBlockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands = chainedCommands.setNodeSelection(\n                  nonEditableBlockContentStartPos,\n                );\n              } else {\n                const blockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands =\n                  chainedCommands.setTextSelection(blockContentStartPos);\n              }\n\n              return chainedCommands\n                .deleteRange({\n                  from: blockInfo.bnBlock.beforePos,\n                  to: blockInfo.bnBlock.afterPos,\n                })\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        // Deletes previous block if it contains no content and isn't a table,\n        // when the selection is empty and at the start of the block. Moves the\n        // current block into the deleted block's place.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            if (!blockInfo.isBlockContainer) {\n              // TODO\n              throw new Error(`todo`);\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const prevBlockInfo = getPrevBlockInfo(\n              state.doc,\n              blockInfo.bnBlock.beforePos,\n            );\n\n            if (prevBlockInfo && selectionAtBlockStart && selectionEmpty) {\n              const bottomBlock = getBottomNestedBlockInfo(\n                state.doc,\n                prevBlockInfo,\n              );\n\n              if (!bottomBlock.isBlockContainer) {\n                // TODO\n                throw new Error(`todo`);\n              }\n\n              const prevBlockNotTableAndNoContent =\n                bottomBlock.blockContent.node.type.spec.content === \"\" ||\n                (bottomBlock.blockContent.node.type.spec.content ===\n                  \"inline*\" &&\n                  bottomBlock.blockContent.node.childCount === 0);\n\n              if (prevBlockNotTableAndNoContent) {\n                return chain()\n                  .cut(\n                    {\n                      from: blockInfo.bnBlock.beforePos,\n                      to: blockInfo.bnBlock.afterPos,\n                    },\n                    bottomBlock.bnBlock.afterPos,\n                  )\n                  .deleteRange({\n                    from: bottomBlock.bnBlock.beforePos,\n                    to: bottomBlock.bnBlock.afterPos,\n                  })\n                  .run();\n              }\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleDelete = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () =>\n          commands.command(({ state }) => {\n            // TODO: Change this to not rely on offsets & schema assumptions\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const {\n              bnBlock: blockContainer,\n              blockContent,\n              childContainer,\n            } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n            const blockAtDocEnd =\n              blockContainer.afterPos === state.doc.nodeSize - 3;\n            const selectionAtBlockEnd =\n              state.selection.from === blockContent.afterPos - 1;\n            const selectionEmpty = state.selection.empty;\n            const hasChildBlocks = childContainer !== undefined;\n\n            if (\n              !blockAtDocEnd &&\n              selectionAtBlockEnd &&\n              selectionEmpty &&\n              !hasChildBlocks\n            ) {\n              let oldDepth = depth;\n              let newPos = blockContainer.afterPos + 1;\n              let newDepth = state.doc.resolve(newPos).depth;\n\n              while (newDepth < oldDepth) {\n                oldDepth = newDepth;\n                newPos += 2;\n                newDepth = state.doc.resolve(newPos).depth;\n              }\n\n              return commands.command(mergeBlocksCommand(newPos - 1));\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = (withShift = false) => {\n      return this.editor.commands.first(({ commands, tr }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n            const blockIndented = depth > 1;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a hard break if block is configured to do so.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            const blockHardBreakShortcut =\n              this.options.editor.schema.blockSchema[\n                blockInfo.blockNoteType as keyof typeof this.options.editor.schema.blockSchema\n              ].meta?.hardBreakShortcut ?? \"shift+enter\";\n\n            if (blockHardBreakShortcut === \"none\") {\n              return false;\n            }\n\n            if (\n              // If shortcut is not configured, or is configured as \"shift+enter\",\n              // create a hard break for shift+enter, but not for enter.\n              (blockHardBreakShortcut === \"shift+enter\" && withShift) ||\n              // If shortcut is configured as \"enter\", create a hard break for\n              // both enter and shift+enter.\n              blockHardBreakShortcut === \"enter\"\n            ) {\n              const marks =\n                tr.storedMarks ||\n                tr.selection.$head\n                  .marks()\n                  .filter((m) =>\n                    this.editor.extensionManager.splittableMarks.includes(\n                      m.type.name,\n                    ),\n                  );\n\n              tr.insert(\n                tr.selection.head,\n                tr.doc.type.schema.nodes.hardBreak.create(),\n              ).ensureMarks(marks);\n              return true;\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, dispatch }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = blockContainer.afterPos;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              if (dispatch) {\n                const newBlock =\n                  state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n                state.tr\n                  .insert(newBlockInsertionPos, newBlock)\n                  .scrollIntoView();\n                state.tr.setSelection(\n                  new TextSelection(state.doc.resolve(newBlockContentPos)),\n                );\n              }\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .command(\n                  splitBlockCommand(\n                    state.selection.from,\n                    selectionAtBlockStart,\n                    selectionAtBlockStart,\n                  ),\n                )\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n    };\n\n    return {\n      Backspace: handleBackspace,\n      Delete: handleDelete,\n      Enter: () => handleEnter(),\n      \"Shift-Enter\": () => handleEnter(true),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.getExtension(FormattingToolbarExtension)?.store\n            .state ||\n            this.options.editor.getExtension(FilePanelExtension)?.store\n              .state !== undefined)\n          // TODO need to check if the link toolbar is open or another alternative entirely\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        return nestBlock(this.options.editor);\n      },\n      \"Shift-Tab\": () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.getExtension(FormattingToolbarExtension)?.store\n            .state ||\n            this.options.editor.getExtension(FilePanelExtension)?.store\n              .state !== undefined)\n          // TODO need to check if the link toolbar is open or another alternative entirely\n          // other menu types?\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        return this.editor.commands.liftListItem(\"blockContainer\");\n      },\n      \"Shift-Mod-ArrowUp\": () => {\n        this.options.editor.moveBlocksUp();\n        return true;\n      },\n      \"Shift-Mod-ArrowDown\": () => {\n        this.options.editor.moveBlocksDown();\n        return true;\n      },\n      \"Mod-z\": () => this.options.editor.undo(),\n      \"Mod-y\": () => this.options.editor.redo(),\n      \"Shift-Mod-z\": () => this.options.editor.redo(),\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\nimport { MarkSpec } from \"prosemirror-model\";\n\n// This copies the marks from @handlewithcare/prosemirror-suggest-changes,\n// but uses the Tiptap Mark API instead so we can use them in BlockNote\n\n// The ideal solution would be to not depend on tiptap nodes / marks, but be able to use prosemirror nodes / marks directly\n// this way we could directly use the exported marks from @handlewithcare/prosemirror-suggest-changes\nexport const SuggestionAddMark = Mark.create({\n  name: \"insertion\",\n  inclusive: false,\n  excludes: \"deletion modification insertion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"insertion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      toDOM(mark, inline) {\n        return [\n          \"ins\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"ins\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionDeleteMark = Mark.create({\n  name: \"deletion\",\n  inclusive: false,\n  excludes: \"insertion modification deletion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"deletion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      // attrs: {\n      //   id: { validate: \"number\" },\n      // },\n      toDOM(mark, inline) {\n        return [\n          \"del\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"del\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionModificationMark = Mark.create({\n  name: \"modification\",\n  inclusive: false,\n  excludes: \"deletion insertion\",\n  addAttributes() {\n    // note: validate is supported in prosemirror but not in tiptap\n    return {\n      id: { default: null, validate: \"number\" },\n      type: { validate: \"string\" },\n      attrName: { default: null, validate: \"string|null\" },\n      previousValue: { default: null },\n      newValue: { default: null },\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"modification\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n      // attrs: {\n      //   id: { validate: \"number\" },\n      //   type: { validate: \"string\" },\n      //   attrName: { default: null, validate: \"string|null\" },\n      //   previousValue: { default: null },\n      //   newValue: { default: null },\n      // },\n      toDOM(mark, inline) {\n        return [\n          inline ? \"span\" : \"div\",\n          {\n            \"data-type\": \"modification\",\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-mod-type\": mark.attrs[\"type\"] as string,\n            \"data-mod-prev-val\": JSON.stringify(mark.attrs[\"previousValue\"]),\n            // TODO: Try to serialize marks with toJSON?\n            \"data-mod-new-val\": JSON.stringify(mark.attrs[\"newValue\"]),\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"span[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n              newValue: node.dataset[\"modNewVal\"],\n            };\n          },\n        },\n        {\n          tag: \"div[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n","import { Extension } from \"@tiptap/core\";\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Generally text alignment is handled through props using the custom\n        // blocks API. Tables are the only blocks that are created as TipTap\n        // nodes and ported to blocks, so we need to add text alignment in a\n        // separate extension.\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => {\n              return element.getAttribute(\"data-text-alignment\");\n            },\n            renderHTML: (attributes) => {\n              if (attributes.textAlignment === \"left\") {\n                return {};\n              }\n              return {\n                \"data-text-alignment\": attributes.textAlignment,\n              };\n            },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { getTextColorAttribute } from \"../../../blocks/defaultProps.js\";\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"table\", \"tableCell\", \"tableHeader\"],\n        attributes: {\n          textColor: getTextColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\n// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n  editor: BlockNoteEditor<any, any, any>;\n}>({\n  name: \"blockContainer\",\n  group: \"blockGroupChild bnBlock\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n  marks: \"insertion modification deletion\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-node-type=\" + this.name + \"]\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (const [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          return attrs;\n        },\n      },\n      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.\n      {\n        tag: `div[data-node-type=\"blockOuter\"]`,\n        skip: true,\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockOuter = document.createElement(\"div\");\n    blockOuter.className = \"bn-block-outer\";\n    blockOuter.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockOuter.setAttribute(attribute, value);\n      }\n    }\n\n    const blockHTMLAttributes = {\n      ...(this.options.domAttributes?.block || {}),\n      ...HTMLAttributes,\n    };\n    const block = document.createElement(\"div\");\n    block.className = mergeCSSClasses(\"bn-block\", blockHTMLAttributes.class);\n    block.setAttribute(\"data-node-type\", this.name);\n    for (const [attribute, value] of Object.entries(blockHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        block.setAttribute(attribute, value);\n      }\n    }\n\n    blockOuter.appendChild(block);\n\n    return {\n      dom: blockOuter,\n      contentDOM: block,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\nexport const BlockGroup = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n}>({\n  name: \"blockGroup\",\n  group: \"childContainer\",\n  content: \"blockGroupChild+\",\n  marks: \"deletion insertion modification\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockGroupHTMLAttributes = {\n      ...(this.options.domAttributes?.blockGroup || {}),\n      ...HTMLAttributes,\n    };\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.className = mergeCSSClasses(\n      \"bn-block-group\",\n      blockGroupHTMLAttributes.class,\n    );\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockGroup.setAttribute(attribute, value);\n      }\n    }\n\n    return {\n      dom: blockGroup,\n      contentDOM: blockGroup,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nexport const Doc = Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"blockGroup\",\n  marks: \"insertion modification deletion\",\n});\n","import {\n  AnyExtension as AnyTiptapExtension,\n  extensions,\n  Node,\n  Extension as TiptapExtension,\n} from \"@tiptap/core\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Text } from \"@tiptap/extension-text\";\nimport { createDropFileExtension } from \"../../../api/clipboard/fromClipboard/fileDropExtension.js\";\nimport { createPasteFromClipboardExtension } from \"../../../api/clipboard/fromClipboard/pasteExtension.js\";\nimport { createCopyToClipboardExtension } from \"../../../api/clipboard/toClipboard/copyExtension.js\";\nimport {\n  BlockChangeExtension,\n  DropCursorExtension,\n  FilePanelExtension,\n  ForkYDocExtension,\n  FormattingToolbarExtension,\n  HistoryExtension,\n  LinkToolbarExtension,\n  NodeSelectionKeyboardExtension,\n  PlaceholderExtension,\n  PreviousBlockTypeExtension,\n  SchemaMigration,\n  ShowSelectionExtension,\n  SideMenuExtension,\n  SuggestionMenu,\n  TableHandlesExtension,\n  TrailingNodeExtension,\n  YCursorExtension,\n  YSyncExtension,\n  YUndoExtension,\n} from \"../../../extensions/index.js\";\nimport {\n  DEFAULT_LINK_PROTOCOL,\n  VALID_LINK_PROTOCOLS,\n} from \"../../../extensions/LinkToolbar/protocols.js\";\nimport {\n  BackgroundColorExtension,\n  HardBreak,\n  KeyboardShortcutsExtension,\n  SuggestionAddMark,\n  SuggestionDeleteMark,\n  SuggestionModificationMark,\n  TextAlignmentExtension,\n  TextColorExtension,\n  UniqueID,\n} from \"../../../extensions/tiptap-extensions/index.js\";\nimport { BlockContainer, BlockGroup, Doc } from \"../../../pm-nodes/index.js\";\nimport {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../BlockNoteEditor.js\";\nimport { ExtensionFactoryInstance } from \"../../BlockNoteExtension.js\";\n\n// TODO remove linkify completely by vendoring the link extension & dropping linkifyjs as a dependency\nlet LINKIFY_INITIALIZED = false;\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport function getDefaultTiptapExtensions(\n  editor: BlockNoteEditor<any, any, any>,\n  options: BlockNoteEditorOptions<any, any, any>,\n) {\n  const tiptapExtensions: AnyTiptapExtension[] = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n    Gapcursor,\n\n    UniqueID.configure({\n      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)\n      types: [\"blockContainer\", \"columnList\", \"column\"],\n      setIdAttribute: options.setIdAttribute,\n    }),\n    HardBreak,\n    Text,\n\n    // marks:\n    SuggestionAddMark,\n    SuggestionDeleteMark,\n    SuggestionModificationMark,\n    Link.extend({\n      inclusive: false,\n    }).configure({\n      defaultProtocol: DEFAULT_LINK_PROTOCOL,\n      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450\n      protocols: LINKIFY_INITIALIZED ? [] : VALID_LINK_PROTOCOLS,\n    }),\n    ...(Object.values(editor.schema.styleSpecs).map((styleSpec) => {\n      return styleSpec.implementation.mark.configure({\n        editor: editor,\n      });\n    }) as any[]),\n\n    TextColorExtension,\n\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)\n    TiptapExtension.create({\n      name: \"OverrideEscape\",\n      addKeyboardShortcuts: () => {\n        return {\n          Escape: () => {\n            if (editor.getExtension(SuggestionMenu)?.shown()) {\n              // escape should close the suggestion menu, but not blur the editor\n              return false;\n            }\n            editor.blur();\n            return true;\n          },\n        };\n      },\n    }),\n\n    // nodes\n    Doc,\n    BlockContainer.configure({\n      editor: editor,\n      domAttributes: options.domAttributes,\n    }),\n    KeyboardShortcutsExtension.configure({\n      editor: editor,\n      tabBehavior: options.tabBehavior,\n    }),\n    BlockGroup.configure({\n      domAttributes: options.domAttributes,\n    }),\n    ...Object.values(editor.schema.inlineContentSpecs)\n      .filter((a) => a.config !== \"link\" && a.config !== \"text\")\n      .map((inlineContentSpec) => {\n        return inlineContentSpec.implementation!.node.configure({\n          editor: editor,\n        });\n      }),\n\n    ...Object.values(editor.schema.blockSpecs).flatMap((blockSpec) => {\n      return [\n        // the node extension implementations\n        ...(\"node\" in blockSpec.implementation\n          ? [\n              (blockSpec.implementation.node as Node).configure({\n                editor: editor,\n                domAttributes: options.domAttributes,\n              }),\n            ]\n          : []),\n      ];\n    }),\n    createCopyToClipboardExtension(editor),\n    createPasteFromClipboardExtension(\n      editor,\n      options.pasteHandler ||\n        ((context: {\n          defaultPasteHandler: (context?: {\n            prioritizeMarkdownOverHTML?: boolean;\n            plainTextAsMarkdown?: boolean;\n          }) => boolean | undefined;\n        }) => context.defaultPasteHandler()),\n    ),\n    createDropFileExtension(editor),\n  ];\n\n  LINKIFY_INITIALIZED = true;\n\n  return tiptapExtensions;\n}\n\nexport function getDefaultExtensions(\n  editor: BlockNoteEditor<any, any, any>,\n  options: BlockNoteEditorOptions<any, any, any>,\n) {\n  const extensions = [\n    BlockChangeExtension(),\n    DropCursorExtension(options),\n    FilePanelExtension(options),\n    FormattingToolbarExtension(options),\n    LinkToolbarExtension(options),\n    NodeSelectionKeyboardExtension(),\n    PlaceholderExtension(options),\n    ShowSelectionExtension(options),\n    SideMenuExtension(options),\n    SuggestionMenu(options),\n    ...(options.trailingBlock !== false ? [TrailingNodeExtension()] : []),\n  ] as ExtensionFactoryInstance[];\n\n  if (options.collaboration) {\n    extensions.push(ForkYDocExtension(options.collaboration));\n    if (options.collaboration.provider?.awareness) {\n      extensions.push(YCursorExtension(options.collaboration));\n    }\n    extensions.push(YSyncExtension(options.collaboration));\n    extensions.push(YUndoExtension(options.collaboration));\n    extensions.push(SchemaMigration(options.collaboration));\n  } else {\n    // YUndo is not compatible with ProseMirror's history plugin\n    extensions.push(HistoryExtension());\n  }\n\n  if (\"table\" in editor.schema.blockSpecs) {\n    extensions.push(TableHandlesExtension(options));\n  }\n\n  if (options.animations !== false) {\n    extensions.push(PreviousBlockTypeExtension());\n  }\n\n  return extensions;\n}\n","import {\n  InputRule,\n  inputRules as inputRulesPlugin,\n} from \"@handlewithcare/prosemirror-inputrules\";\nimport {\n  AnyExtension as AnyTiptapExtension,\n  Extension as TiptapExtension,\n} from \"@tiptap/core\";\nimport { keymap } from \"@tiptap/pm/keymap\";\nimport { Plugin } from \"prosemirror-state\";\nimport { updateBlockTr } from \"../../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromTransaction } from \"../../../api/getBlockInfoFromPos.js\";\nimport { sortByDependencies } from \"../../../util/topo-sort.js\";\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../BlockNoteEditor.js\";\nimport type {\n  Extension,\n  ExtensionFactoryInstance,\n  ExtensionFactory,\n} from \"../../BlockNoteExtension.js\";\nimport { originalFactorySymbol } from \"./symbol.js\";\nimport {\n  getDefaultExtensions,\n  getDefaultTiptapExtensions,\n} from \"./extensions.js\";\n\nexport class ExtensionManager {\n  /**\n   * A set of extension keys which are disabled by the options\n   */\n  private disabledExtensions = new Set<string>();\n  /**\n   * A list of all the extensions that are registered to the editor\n   */\n  private extensions: Extension[] = [];\n  /**\n   * A map of all the abort controllers for each extension that has an init method defined\n   */\n  private abortMap = new Map<Extension, AbortController>();\n  /**\n   * A map of all the extension factories that are registered to the editor\n   */\n  private extensionFactories = new Map<ExtensionFactory, Extension>();\n  /**\n   * Because a single blocknote extension can both have it's own prosemirror plugins & additional generated ones (e.g. keymap & input rules plugins)\n   * We need to keep track of all the plugins for each extension, so that we can remove them when the extension is unregistered\n   */\n  private extensionPlugins: Map<Extension, Plugin[]> = new Map();\n\n  constructor(\n    private editor: BlockNoteEditor<any, any, any>,\n    private options: BlockNoteEditorOptions<any, any, any>,\n  ) {\n    /**\n     * When the editor is first mounted, we need to initialize all the extensions\n     */\n    editor.onMount(() => {\n      for (const extension of this.extensions) {\n        // If the extension has an init function, we can initialize it, otherwise, it is already added to the editor\n        if (extension.mount) {\n          // We create an abort controller for each extension, so that we can abort the extension when the editor is unmounted\n          const abortController = new window.AbortController();\n          const unmountCallback = extension.mount({\n            dom: editor.prosemirrorView.dom,\n            root: editor.prosemirrorView.root,\n            signal: abortController.signal,\n          });\n          // If the extension returns a method to unmount it, we can register it to be called when the abort controller is aborted\n          if (unmountCallback) {\n            abortController.signal.addEventListener(\"abort\", () => {\n              unmountCallback();\n            });\n          }\n          // Keep track of the abort controller for each extension, so that we can abort it when the editor is unmounted\n          this.abortMap.set(extension, abortController);\n        }\n      }\n    });\n\n    /**\n     * When the editor is unmounted, we need to abort all the extensions' abort controllers\n     */\n    editor.onUnmount(() => {\n      for (const [extension, abortController] of this.abortMap.entries()) {\n        // No longer track the abort controller for this extension\n        this.abortMap.delete(extension);\n        // Abort each extension's abort controller\n        abortController.abort();\n      }\n    });\n\n    // TODO do disabled extensions need to be only for editor base extensions? Or all of them?\n    this.disabledExtensions = new Set(options.disableExtensions || []);\n\n    // Add the default extensions\n    for (const extension of getDefaultExtensions(this.editor, this.options)) {\n      this.addExtension(extension);\n    }\n\n    // Add the extensions from the options\n    for (const extension of this.options.extensions ?? []) {\n      this.addExtension(extension);\n    }\n\n    // Add the extensions from blocks specs\n    for (const block of Object.values(this.editor.schema.blockSpecs)) {\n      for (const extension of block.extensions ?? []) {\n        this.addExtension(extension);\n      }\n    }\n  }\n\n  /**\n   * Register one or more extensions to the editor after the editor is initialized.\n   *\n   * This allows users to switch on & off extensions \"at runtime\".\n   */\n  public registerExtension(\n    extension:\n      | Extension\n      | ExtensionFactoryInstance\n      | (Extension | ExtensionFactoryInstance)[],\n  ): void {\n    const extensions = ([] as (Extension | ExtensionFactoryInstance)[])\n      .concat(extension)\n      .filter(Boolean) as (Extension | ExtensionFactoryInstance)[];\n\n    if (!extensions.length) {\n      // eslint-disable-next-line no-console\n      console.warn(`No extensions found to register`, extension);\n      return;\n    }\n\n    const registeredExtensions = extensions\n      .map((extension) => this.addExtension(extension))\n      .filter(Boolean) as Extension[];\n\n    const pluginsToAdd = new Set<Plugin>();\n    for (const extension of registeredExtensions) {\n      if (extension?.tiptapExtensions) {\n        // This is necessary because this can only switch out prosemirror plugins at runtime,\n        // it can't switch out Tiptap extensions since that can have more widespread effects (since a Tiptap extension can even add/remove to the schema).\n\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has tiptap extensions, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,\n          extension,\n        );\n      }\n\n      if (extension?.inputRules?.length) {\n        // This is necessary because input rules are defined in a single prosemirror plugin which cannot be re-initialized.\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has input rules, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,\n          extension,\n        );\n      }\n\n      this.getProsemirrorPluginsFromExtension(extension).plugins.forEach(\n        (plugin) => {\n          pluginsToAdd.add(plugin);\n        },\n      );\n    }\n\n    // TODO there isn't a great way to do sorting right now. This is something that should be improved in the future.\n    // So, we just append to the end of the list for now.\n    this.updatePlugins((plugins) => [...plugins, ...pluginsToAdd]);\n  }\n\n  /**\n   * Register an extension to the editor\n   * @param extension - The extension to register\n   * @returns The extension instance\n   */\n  private addExtension(\n    extension: Extension | ExtensionFactoryInstance,\n  ): Extension | undefined {\n    let instance: Extension;\n    if (typeof extension === \"function\") {\n      instance = extension({ editor: this.editor });\n    } else {\n      instance = extension;\n    }\n\n    if (!instance || this.disabledExtensions.has(instance.key)) {\n      return undefined as any;\n    }\n\n    // Now that we know that the extension is not disabled, we can add it to the extension factories\n    if (typeof extension === \"function\") {\n      const originalFactory = (instance as any)[originalFactorySymbol] as (\n        ...args: any[]\n      ) => ExtensionFactoryInstance;\n\n      if (typeof originalFactory === \"function\") {\n        this.extensionFactories.set(originalFactory, instance);\n      }\n    }\n\n    this.extensions.push(instance);\n\n    return instance as any;\n  }\n\n  /**\n   * Resolve an extension or a list of extensions into a list of extension instances\n   * @param toResolve - The extension or list of extensions to resolve\n   * @returns A list of extension instances\n   */\n  private resolveExtensions(\n    toResolve:\n      | undefined\n      | string\n      | Extension\n      | ExtensionFactory\n      | (Extension | ExtensionFactory | string | undefined)[],\n  ): Extension[] {\n    const extensions = [] as Extension[];\n    if (typeof toResolve === \"function\") {\n      const instance = this.extensionFactories.get(toResolve);\n      if (instance) {\n        extensions.push(instance);\n      }\n    } else if (Array.isArray(toResolve)) {\n      for (const extension of toResolve) {\n        extensions.push(...this.resolveExtensions(extension));\n      }\n    } else if (typeof toResolve === \"object\" && \"key\" in toResolve) {\n      extensions.push(toResolve);\n    } else if (typeof toResolve === \"string\") {\n      const instance = this.extensions.find((e) => e.key === toResolve);\n      if (instance) {\n        extensions.push(instance);\n      }\n    }\n    return extensions;\n  }\n\n  /**\n   * Unregister an extension from the editor\n   * @param toUnregister - The extension to unregister\n   * @returns void\n   */\n  public unregisterExtension(\n    toUnregister:\n      | undefined\n      | string\n      | Extension\n      | ExtensionFactory\n      | (Extension | ExtensionFactory | string | undefined)[],\n  ): void {\n    const extensions = this.resolveExtensions(toUnregister);\n\n    if (!extensions.length) {\n      // eslint-disable-next-line no-console\n      console.warn(`No extensions found to unregister`, toUnregister);\n      return;\n    }\n    let didWarn = false;\n\n    const pluginsToRemove = new Set<Plugin>();\n    for (const extension of extensions) {\n      this.extensions = this.extensions.filter((e) => e !== extension);\n      this.extensionFactories.forEach((instance, factory) => {\n        if (instance === extension) {\n          this.extensionFactories.delete(factory);\n        }\n      });\n      this.abortMap.get(extension)?.abort();\n      this.abortMap.delete(extension);\n\n      const plugins = this.extensionPlugins.get(extension);\n      plugins?.forEach((plugin) => {\n        pluginsToRemove.add(plugin);\n      });\n      this.extensionPlugins.delete(extension);\n\n      if (extension.tiptapExtensions && !didWarn) {\n        didWarn = true;\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Extension ${extension.key} has tiptap extensions, but they will not be removed. Please separate the extension into multiple extensions if you want to remove them, or re-initialize the editor.`,\n          toUnregister,\n        );\n      }\n    }\n\n    this.updatePlugins((plugins) =>\n      plugins.filter((plugin) => !pluginsToRemove.has(plugin)),\n    );\n  }\n\n  /**\n   * Allows resetting the current prosemirror state's plugins\n   * @param update - A function that takes the current plugins and returns the new plugins\n   * @returns void\n   */\n  private updatePlugins(update: (plugins: Plugin[]) => Plugin[]): void {\n    const currentState = this.editor.prosemirrorState;\n\n    const state = currentState.reconfigure({\n      plugins: update(currentState.plugins.slice()),\n    });\n\n    this.editor.prosemirrorView.updateState(state);\n  }\n\n  /**\n   * Get all the extensions that are registered to the editor\n   */\n  public getTiptapExtensions(): AnyTiptapExtension[] {\n    // Start with the default tiptap extensions\n    const tiptapExtensions = getDefaultTiptapExtensions(\n      this.editor,\n      this.options,\n    );\n    // TODO filter out the default extensions via the disabledExtensions set?\n\n    const getPriority = sortByDependencies(this.extensions);\n\n    const inputRulesByPriority = new Map<number, InputRule[]>();\n    for (const extension of this.extensions) {\n      if (extension.tiptapExtensions) {\n        tiptapExtensions.push(...extension.tiptapExtensions);\n      }\n\n      const priority = getPriority(extension.key);\n\n      const { plugins: prosemirrorPlugins, inputRules } =\n        this.getProsemirrorPluginsFromExtension(extension);\n      // Sometimes a blocknote extension might need to make additional prosemirror plugins, so we generate them here\n      if (prosemirrorPlugins.length) {\n        tiptapExtensions.push(\n          TiptapExtension.create({\n            name: extension.key,\n            priority,\n            addProseMirrorPlugins: () => prosemirrorPlugins,\n          }),\n        );\n      }\n      if (inputRules.length) {\n        if (!inputRulesByPriority.has(priority)) {\n          inputRulesByPriority.set(priority, []);\n        }\n        inputRulesByPriority.get(priority)!.push(...inputRules);\n      }\n    }\n\n    // Collect all input rules into 1 extension to reduce conflicts\n    tiptapExtensions.push(\n      TiptapExtension.create({\n        name: \"blocknote-input-rules\",\n        addProseMirrorPlugins() {\n          const rules = [] as InputRule[];\n          Array.from(inputRulesByPriority.keys())\n            // We sort the rules by their priority (the key)\n            .sort()\n            .reverse()\n            .forEach((priority) => {\n              // Append in reverse priority order\n              rules.push(...inputRulesByPriority.get(priority)!);\n            });\n          return [inputRulesPlugin({ rules })];\n        },\n      }),\n    );\n\n    // Add any tiptap extensions from the `_tiptapOptions`\n    for (const extension of this.options._tiptapOptions?.extensions ?? []) {\n      tiptapExtensions.push(extension);\n    }\n\n    return tiptapExtensions;\n  }\n\n  /**\n   * This maps a blocknote extension into an array of Prosemirror plugins if it has any of the following:\n   * - plugins\n   * - keyboard shortcuts\n   * - input rules\n   */\n  private getProsemirrorPluginsFromExtension(extension: Extension): {\n    plugins: Plugin[];\n    inputRules: InputRule[];\n  } {\n    const plugins: Plugin[] = [...(extension.prosemirrorPlugins ?? [])];\n    const inputRules: InputRule[] = [];\n    if (\n      !extension.prosemirrorPlugins?.length &&\n      !Object.keys(extension.keyboardShortcuts || {}).length &&\n      !extension.inputRules?.length\n    ) {\n      // We can bail out early if the extension has no features to add to the tiptap editor\n      return { plugins, inputRules };\n    }\n\n    this.extensionPlugins.set(extension, plugins);\n\n    if (extension.inputRules?.length) {\n      inputRules.push(\n        ...extension.inputRules.map((inputRule) => {\n          return new InputRule(inputRule.find, (state, match, start, end) => {\n            const replaceWith = inputRule.replace({\n              match,\n              range: { from: start, to: end },\n              editor: this.editor,\n            });\n            if (replaceWith) {\n              const cursorPosition = this.editor.getTextCursorPosition();\n\n              if (\n                this.editor.schema.blockSchema[cursorPosition.block.type]\n                  .content !== \"inline\"\n              ) {\n                return null;\n              }\n\n              const blockInfo = getBlockInfoFromTransaction(state.tr);\n              const tr = state.tr.deleteRange(start, end);\n\n              updateBlockTr(tr, blockInfo.bnBlock.beforePos, replaceWith);\n              return tr;\n            }\n            return null;\n          });\n        }),\n      );\n    }\n\n    if (Object.keys(extension.keyboardShortcuts || {}).length) {\n      plugins.push(\n        keymap(\n          Object.fromEntries(\n            Object.entries(extension.keyboardShortcuts!).map(([key, value]) => [\n              key,\n              () => value({ editor: this.editor }),\n            ]),\n          ),\n        ),\n      );\n    }\n\n    return { plugins, inputRules };\n  }\n\n  /**\n   * Get all extensions\n   */\n  public getExtensions(): Map<string, Extension> {\n    return new Map(\n      this.extensions.map((extension) => [extension.key, extension]),\n    );\n  }\n\n  /**\n   * Get a specific extension by it's instance\n   */\n  public getExtension<\n    const Ext extends Extension | ExtensionFactory = Extension,\n  >(\n    extension: string,\n  ):\n    | (Ext extends Extension\n        ? Ext\n        : Ext extends ExtensionFactory\n          ? ReturnType<ReturnType<Ext>>\n          : never)\n    | undefined;\n  public getExtension<const T extends ExtensionFactory>(\n    extension: T,\n  ): ReturnType<ReturnType<T>> | undefined;\n  public getExtension<const T extends ExtensionFactory | string = string>(\n    extension: T,\n  ):\n    | (T extends ExtensionFactory\n        ? ReturnType<ReturnType<T>>\n        : T extends string\n          ? Extension\n          : never)\n    | undefined {\n    if (typeof extension === \"string\") {\n      const instance = this.extensions.find((e) => e.key === extension);\n      if (!instance) {\n        return undefined;\n      }\n      return instance as any;\n    } else if (typeof extension === \"function\") {\n      const instance = this.extensionFactories.get(extension);\n      if (!instance) {\n        return undefined;\n      }\n      return instance as any;\n    }\n    throw new Error(`Invalid extension type: ${typeof extension}`);\n  }\n\n  /**\n   * Check if an extension exists\n   */\n  public hasExtension(key: string | Extension | ExtensionFactory): boolean {\n    if (typeof key === \"string\") {\n      return this.extensions.some((e) => e.key === key);\n    } else if (typeof key === \"object\" && \"key\" in key) {\n      return this.extensions.some((e) => e.key === key.key);\n    } else if (typeof key === \"function\") {\n      return this.extensionFactories.has(key);\n    }\n    return false;\n  }\n}\n","import { TextSelection, type Transaction } from \"prosemirror-state\";\nimport { TableMap } from \"prosemirror-tables\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { Selection } from \"../../../editor/selectionTypes.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { getBlockInfo, getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport {\n  nodeToBlock,\n  prosemirrorSliceToSlicedBlocks,\n} from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getSelection<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): Selection<BSchema, I, S> | undefined {\n  const pmSchema = getPmSchema(tr);\n  // Return undefined if the selection is collapsed or a node is selected.\n  if (tr.selection.empty || \"node\" in tr.selection) {\n    return undefined;\n  }\n\n  const $startBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.from).posBeforeNode,\n  );\n  const $endBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.to).posBeforeNode,\n  );\n\n  // Converts the node at the given index and depth around `$startBlockBeforePos`\n  // to a block. Used to get blocks at given indices at the shared depth and\n  // at the depth of `$startBlockBeforePos`.\n  const indexToBlock = (\n    index: number,\n    depth?: number,\n  ): Block<BSchema, I, S> => {\n    const pos = $startBlockBeforePos.posAtIndex(index, depth);\n    const node = tr.doc.resolve(pos).nodeAfter;\n\n    if (!node) {\n      throw new Error(\n        `Error getting selection - node not found at position ${pos}`,\n      );\n    }\n\n    return nodeToBlock(node, pmSchema);\n  };\n\n  const blocks: Block<BSchema, I, S>[] = [];\n  // Minimum depth at which the blocks share a common ancestor.\n  const sharedDepth = $startBlockBeforePos.sharedDepth($endBlockBeforePos.pos);\n  const startIndex = $startBlockBeforePos.index(sharedDepth);\n  const endIndex = $endBlockBeforePos.index(sharedDepth);\n\n  // In most cases, we want to return the blocks spanned by the selection at the\n  // shared depth. However, when the block in which the selection starts is at a\n  // higher depth than the shared depth, we omit the first block at the shared\n  // depth. Instead, we include the first block at its depth, and any blocks at\n  // a higher index up to the shared depth. The following  example illustrates\n  // this:\n  // - id-0\n  //   - id-1\n  //     - >|id-2\n  //     - id-3\n  //   - id-4\n  //     - id-5\n  //   - id-6\n  // - id-7\n  // - id-8\n  // - id-9|<\n  //   - id-10\n  // Here, each block is represented by its ID, and the selection is represented\n  // by the `>|` and `|<` markers. So the selection starts in block `id-2` and\n  // ends in block `id-8`. In this case, the shared depth is 0, since the blocks\n  // `id-6`, `id-7`, and `id-8` set the shared depth, as they are the least\n  // nested blocks spanned by the selection. Therefore, these blocks are all\n  // added to the `blocks` array. However, the selection starts in block `id-2`,\n  // which is at a higher depth than the shared depth. So we add block `id-2` to\n  // the `blocks` array, as well as any later siblings (in this case, `id-3`),\n  // and move up one level of depth. The ancestor of block `id-2` at this depth\n  // is block `id-1`, so we add all its later siblings to the `blocks` array as\n  // well, again moving up one level of depth. Since we're now at the shared\n  // depth, we are done. The final `blocks` array for this example would be:\n  // [ id-2, id-3, id-4, id-6, id-7, id-8, id-9 ]\n  if ($startBlockBeforePos.depth > sharedDepth) {\n    // Adds the block that the selection starts in.\n    blocks.push(nodeToBlock($startBlockBeforePos.nodeAfter!, pmSchema));\n\n    // Traverses all depths from the depth of the block in which the selection\n    // starts, up to the shared depth.\n    for (let depth = $startBlockBeforePos.depth; depth > sharedDepth; depth--) {\n      const parentNode = $startBlockBeforePos.node(depth);\n\n      if (parentNode.type.isInGroup(\"childContainer\")) {\n        const startIndexAtDepth = $startBlockBeforePos.index(depth) + 1;\n        const childCountAtDepth = $startBlockBeforePos.node(depth).childCount;\n\n        // Adds all blocks after the index of the block in which the selection\n        // starts (or its ancestors at lower depths).\n        for (let i = startIndexAtDepth; i < childCountAtDepth; i++) {\n          blocks.push(indexToBlock(i, depth));\n        }\n      }\n    }\n  } else {\n    // Adds the first block spanned by the selection at the shared depth.\n    blocks.push(indexToBlock(startIndex, sharedDepth));\n  }\n\n  // Adds all blocks spanned by the selection at the shared depth, excluding\n  // the first.\n  for (let i = startIndex + 1; i <= endIndex; i++) {\n    blocks.push(indexToBlock(i, sharedDepth));\n  }\n\n  if (blocks.length === 0) {\n    throw new Error(\n      `Error getting selection - selection doesn't span any blocks (${tr.selection})`,\n    );\n  }\n\n  return {\n    blocks,\n  };\n}\n\nexport function setSelection(\n  tr: Transaction,\n  startBlock: BlockIdentifier,\n  endBlock: BlockIdentifier,\n) {\n  const startBlockId =\n    typeof startBlock === \"string\" ? startBlock : startBlock.id;\n  const endBlockId = typeof endBlock === \"string\" ? endBlock : endBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  if (startBlockId === endBlockId) {\n    throw new Error(\n      `Attempting to set selection with the same anchor and head blocks (id ${startBlockId})`,\n    );\n  }\n  const anchorPosInfo = getNodeById(startBlockId, tr.doc);\n  if (!anchorPosInfo) {\n    throw new Error(`Block with ID ${startBlockId} not found`);\n  }\n  const headPosInfo = getNodeById(endBlockId, tr.doc);\n  if (!headPosInfo) {\n    throw new Error(`Block with ID ${endBlockId} not found`);\n  }\n\n  const anchorBlockInfo = getBlockInfo(anchorPosInfo);\n  const headBlockInfo = getBlockInfo(headPosInfo);\n\n  const anchorBlockConfig =\n    schema.blockSchema[\n      anchorBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n  const headBlockConfig =\n    schema.blockSchema[\n      headBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n\n  if (\n    !anchorBlockInfo.isBlockContainer ||\n    anchorBlockConfig.content === \"none\"\n  ) {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${startBlockId})`,\n    );\n  }\n  if (!headBlockInfo.isBlockContainer || headBlockConfig.content === \"none\") {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${endBlockId})`,\n    );\n  }\n\n  let startPos: number;\n  let endPos: number;\n\n  if (anchorBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(anchorBlockInfo.blockContent.node);\n    const firstCellPos =\n      anchorBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(0, 0, anchorBlockInfo.blockContent.node) +\n      1;\n    startPos = firstCellPos + 2;\n  } else {\n    startPos = anchorBlockInfo.blockContent.beforePos + 1;\n  }\n\n  if (headBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(headBlockInfo.blockContent.node);\n    const lastCellPos =\n      headBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(\n        tableMap.height - 1,\n        tableMap.width - 1,\n        headBlockInfo.blockContent.node,\n      ) +\n      1;\n    const lastCellNodeSize = tr.doc.resolve(lastCellPos).nodeAfter!.nodeSize;\n    endPos = lastCellPos + lastCellNodeSize - 2;\n  } else {\n    endPos = headBlockInfo.blockContent.afterPos - 1;\n  }\n\n  // TODO: We should polish up the `MultipleNodeSelection` and use that instead.\n  //  Right now it's missing a few things like a jsonID and styling to show\n  //  which nodes are selected. `TextSelection` is ok for now, but has the\n  //  restriction that the start/end blocks must have content.\n  tr.setSelection(TextSelection.create(tr.doc, startPos, endPos));\n}\n\nexport function getSelectionCutBlocks(tr: Transaction) {\n  // TODO: fix image node selection\n\n  const pmSchema = getPmSchema(tr);\n  let start = tr.selection.$from;\n  let end = tr.selection.$to;\n\n  // the selection moves below are used to make sure `prosemirrorSliceToSlicedBlocks` returns\n  // the correct information about whether content is cut at the start or end of a block\n\n  // if the end is at the end of a node (|</span></p>) move it forward so we include all closing tags (</span></p>|)\n  while (end.parentOffset >= end.parent.nodeSize - 2 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos + 1);\n  }\n\n  // if the end is at the start of an empty node (</span></p><p>|) move it backwards so we drop empty start tags (</span></p>|)\n  while (end.parentOffset === 0 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos - 1);\n  }\n\n  // if the start is at the start of a node (<p><span>|) move it backwards so we include all open tags (|<p><span>)\n  while (start.parentOffset === 0 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos - 1);\n  }\n\n  // if the start is at the end of a node (|</p><p><span>|) move it forwards so we drop all closing tags (|<p><span>)\n  while (start.parentOffset >= start.parent.nodeSize - 2 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos + 1);\n  }\n\n  const selectionInfo = prosemirrorSliceToSlicedBlocks(\n    tr.doc.slice(start.pos, end.pos, true),\n    pmSchema,\n  );\n\n  return {\n    _meta: {\n      startPos: start.pos,\n      endPos: end.pos,\n    },\n    ...selectionInfo,\n  };\n}\n","import type { Node } from \"prosemirror-model\";\nimport {\n  NodeSelection,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport type { TextCursorPosition } from \"../../../editor/cursorPositionTypes.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../util/typescript.js\";\nimport {\n  getBlockInfo,\n  getBlockInfoFromTransaction,\n} from \"../../getBlockInfoFromPos.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getTextCursorPosition<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): TextCursorPosition<BSchema, I, S> {\n  const { bnBlock } = getBlockInfoFromTransaction(tr);\n  const pmSchema = getPmSchema(tr.doc);\n\n  const resolvedPos = tr.doc.resolve(bnBlock.beforePos);\n  // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n  const prevNode = resolvedPos.nodeBefore;\n\n  // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n  const nextNode = tr.doc.resolve(bnBlock.afterPos).nodeAfter;\n\n  // Gets parent blockContainer node, if the current node is nested.\n  let parentNode: Node | undefined = undefined;\n  if (resolvedPos.depth > 1) {\n    // for nodes nested in bnBlocks\n    parentNode = resolvedPos.node();\n    if (!parentNode.type.isInGroup(\"bnBlock\")) {\n      // for blockGroups, we need to go one level up\n      parentNode = resolvedPos.node(resolvedPos.depth - 1);\n    }\n  }\n\n  return {\n    block: nodeToBlock(bnBlock.node, pmSchema),\n    prevBlock: prevNode === null ? undefined : nodeToBlock(prevNode, pmSchema),\n    nextBlock: nextNode === null ? undefined : nodeToBlock(nextNode, pmSchema),\n    parentBlock:\n      parentNode === undefined ? undefined : nodeToBlock(parentNode, pmSchema),\n  };\n}\n\nexport function setTextCursorPosition(\n  tr: Transaction,\n  targetBlock: BlockIdentifier,\n  placement: \"start\" | \"end\" = \"start\",\n) {\n  const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n  const pmSchema = getPmSchema(tr.doc);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  const info = getBlockInfo(posInfo);\n\n  const contentType: \"none\" | \"inline\" | \"table\" =\n    schema.blockSchema[info.blockNoteType]!.content;\n\n  if (info.isBlockContainer) {\n    const blockContent = info.blockContent;\n    if (contentType === \"none\") {\n      tr.setSelection(NodeSelection.create(tr.doc, blockContent.beforePos));\n      return;\n    }\n\n    if (contentType === \"inline\") {\n      if (placement === \"start\") {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 1),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 1),\n        );\n      }\n    } else if (contentType === \"table\") {\n      if (placement === \"start\") {\n        // Need to offset the position as we have to get through the `tableRow`\n        // and `tableCell` nodes to get to the `tableParagraph` node we want to\n        // set the selection in.\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 4),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 4),\n        );\n      }\n    } else {\n      throw new UnreachableCaseError(contentType);\n    }\n  } else {\n    const child =\n      placement === \"start\"\n        ? info.childContainer.node.firstChild!\n        : info.childContainer.node.lastChild!;\n\n    setTextCursorPosition(tr, child.attrs.id, placement);\n  }\n}\n","import {\n  getSelection,\n  getSelectionCutBlocks,\n  setSelection,\n} from \"../../api/blockManipulation/selections/selection.js\";\nimport {\n  getTextCursorPosition,\n  setTextCursorPosition,\n} from \"../../api/blockManipulation/selections/textCursorPosition.js\";\nimport { isNodeSelection, posToDOMRect } from \"@tiptap/core\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport { Selection } from \"../selectionTypes.js\";\nimport { TextCursorPosition } from \"../cursorPositionTypes.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class SelectionManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getSelection(tr));\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks() {\n    return this.editor.transact((tr) => getSelectionCutBlocks(tr));\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this.editor.transact((tr) => setSelection(tr, startBlock, endBlock));\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this.editor.transact((tr) => getTextCursorPosition(tr));\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this.editor.transact((tr) =>\n      setTextCursorPosition(tr, targetBlock, placement),\n    );\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    if (!this.editor.prosemirrorView) {\n      return undefined;\n    }\n\n    const { selection } = this.editor.prosemirrorState;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.editor.prosemirrorView.nodeDOM(from) as HTMLElement;\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(\n      this.editor.prosemirrorView,\n      from,\n      to,\n    ).toJSON() as DOMRect;\n  }\n}\n","import { Command, Transaction } from \"prosemirror-state\";\nimport type { YUndoExtension } from \"../../extensions/Collaboration/YUndo.js\";\nimport type { HistoryExtension } from \"../../extensions/History/History.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StateManager {\n  constructor(private editor: BlockNoteEditor<any, any, any>) {}\n\n  /**\n   * Stores the currently active transaction, which is the accumulated transaction from all {@link dispatch} calls during a {@link transact} calls\n   */\n  private activeTransaction: Transaction | null = null;\n\n  /**\n   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.\n   * @example\n   * ```ts\n   * if (editor.can(editor.undo)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   */\n  public can(cb: () => boolean) {\n    try {\n      this.isInCan = true;\n      return cb();\n    } finally {\n      this.isInCan = false;\n    }\n  }\n\n  // Flag to indicate if we're in a `can` call\n  private isInCan = false;\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call\",\n      );\n    }\n    if (this.isInCan) {\n      return this.canExec(command);\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n    const dispatch = (tr: Transaction) => this.prosemirrorView.dispatch(tr);\n\n    return command(state, dispatch, view);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call\",\n      );\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n\n    return command(state, undefined, view);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    if (this.activeTransaction) {\n      // Already in a transaction, so we can just callback immediately\n      return callback(this.activeTransaction);\n    }\n\n    try {\n      // Enter transaction mode, by setting a starting transaction\n      this.activeTransaction = this.editor._tiptapEditor.state.tr;\n\n      // Capture all dispatch'd transactions\n      const result = callback(this.activeTransaction);\n\n      // Any transactions captured by the `dispatch` call will be stored in `this.activeTransaction`\n      const activeTr = this.activeTransaction;\n\n      this.activeTransaction = null;\n      if (\n        activeTr &&\n        // Only dispatch if the transaction was actually modified in some way\n        (activeTr.docChanged ||\n          activeTr.selectionSet ||\n          activeTr.scrolledIntoView ||\n          activeTr.storedMarksSet ||\n          !activeTr.isGeneric)\n      ) {\n        // Dispatch the transaction if it was modified\n        this.prosemirrorView.dispatch(activeTr);\n      }\n\n      return result;\n    } finally {\n      // We wrap this in a finally block to ensure we don't disable future transactions just because of an error in the callback\n      this.activeTransaction = null;\n    }\n  }\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state\",\n      );\n    }\n    return this.editor._tiptapEditor.state;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this.editor._tiptapEditor.view;\n  }\n\n  public isFocused() {\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public focus() {\n    this.prosemirrorView?.focus();\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      return false;\n    }\n    return this.editor._tiptapEditor.isEditable === undefined\n      ? true\n      : this.editor._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      // not relevant on headless\n      return;\n    }\n    if (this.editor._tiptapEditor.options.editable !== editable) {\n      this.editor._tiptapEditor.setEditable(editable);\n    }\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo(): boolean {\n    // Purposefully not using the UndoPlugin to not import y-prosemirror when not needed\n    const undoPlugin = this.editor.getExtension<typeof YUndoExtension>(\"yUndo\");\n    if (undoPlugin) {\n      return this.exec(undoPlugin.undoCommand);\n    }\n\n    const historyPlugin =\n      this.editor.getExtension<typeof HistoryExtension>(\"history\");\n    if (historyPlugin) {\n      return this.exec(historyPlugin.undoCommand);\n    }\n\n    throw new Error(\"No undo plugin found\");\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo() {\n    const undoPlugin = this.editor.getExtension<typeof YUndoExtension>(\"yUndo\");\n    if (undoPlugin) {\n      return this.exec(undoPlugin.redoCommand);\n    }\n\n    const historyPlugin =\n      this.editor.getExtension<typeof HistoryExtension>(\"history\");\n    if (historyPlugin) {\n      return this.exec(historyPlugin.redoCommand);\n    }\n\n    throw new Error(\"No redo plugin found\");\n  }\n}\n","import { selectionToInsertionEnd } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n\nimport type { Transaction } from \"prosemirror-state\";\n\n// similar to tiptap insertContentAt\nexport function insertContentAt(\n  tr: Transaction,\n  position: number | { from: number; to: number },\n  nodes: Node[],\n  options: {\n    updateSelection: boolean;\n  } = { updateSelection: true },\n) {\n  // donâ€™t dispatch an empty fragment because this can lead to strange errors\n  // if (content.toString() === \"<>\") {\n  //   return true;\n  // }\n\n  let { from, to } =\n    typeof position === \"number\"\n      ? { from: position, to: position }\n      : { from: position.from, to: position.to };\n\n  let isOnlyTextContent = true;\n  let isOnlyBlockContent = true;\n  // const nodes = isFragment(content) ? content : [content];\n\n  let text = \"\";\n\n  nodes.forEach((node) => {\n    // check if added node is valid\n    node.check();\n\n    if (isOnlyTextContent && node.isText && node.marks.length === 0) {\n      text += node.text;\n    } else {\n      isOnlyTextContent = false;\n    }\n\n    isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n  });\n\n  // check if we can replace the wrapping node by\n  // the newly inserted content\n  // example:\n  // replace an empty paragraph by an inserted image\n  // instead of inserting the image below the paragraph\n  if (from === to && isOnlyBlockContent) {\n    const { parent } = tr.doc.resolve(from);\n    const isEmptyTextBlock =\n      parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n\n    if (isEmptyTextBlock) {\n      from -= 1;\n      to += 1;\n    }\n  }\n\n  // if there is only plain text we have to use `insertText`\n  // because this will keep the current marks\n  if (isOnlyTextContent) {\n    // if value is string, we can use it directly\n    // otherwise if it is an array, we have to join it\n    // if (Array.isArray(value)) {\n    //   tr.insertText(value.map((v) => v.text || \"\").join(\"\"), from, to);\n    // } else if (typeof value === \"object\" && !!value && !!value.text) {\n    //   tr.insertText(value.text, from, to);\n    // } else {\n    //   tr.insertText(value as string, from, to);\n    // }\n    tr.insertText(text, from, to);\n  } else {\n    tr.replaceWith(from, to, nodes);\n  }\n\n  // set cursor at end of inserted content\n  if (options.updateSelection) {\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n  }\n\n  return true;\n}\n","import { insertContentAt } from \"../../api/blockManipulation/insertContentAt.js\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  PartialInlineContent,\n  StyleSchema,\n  Styles,\n} from \"../../schema/index.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport { TextSelection } from \"@tiptap/pm/state\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StyleManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    const nodes = inlineContentToNodes(content, this.editor.pmSchema);\n\n    this.editor.transact((tr) => {\n      insertContentAt(\n        tr,\n        {\n          from: tr.selection.from,\n          to: tr.selection.to,\n        },\n        nodes,\n        {\n          updateSelection,\n        },\n      );\n    });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    return this.editor.transact((tr) => {\n      const styles: Styles<SSchema> = {};\n      const marks = tr.selection.$to.marks();\n\n      for (const mark of marks) {\n        const config = this.editor.schema.styleSchema[mark.type.name];\n        if (!config) {\n          if (\n            // Links are not considered styles in blocknote\n            mark.type.name !== \"link\" &&\n            // \"blocknoteIgnore\" tagged marks (such as comments) are also not considered BlockNote \"styles\"\n            !mark.type.spec.blocknoteIgnore\n          ) {\n            // eslint-disable-next-line no-console\n            console.warn(\"mark not found in styleschema\", mark.type.name);\n          }\n\n          continue;\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        }\n      }\n\n      return styles;\n    });\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.setMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.setMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    for (const style of Object.keys(styles)) {\n      this.editor._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.toggleMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.toggleMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this.editor.transact((tr) => {\n      return tr.doc.textBetween(tr.selection.from, tr.selection.to);\n    });\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this.editor._tiptapEditor.getAttributes(\"link\").href as\n      | string\n      | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n    const mark = this.editor.pmSchema.mark(\"link\", { href: url });\n    this.editor.transact((tr) => {\n      const { from, to } = tr.selection;\n\n      if (text) {\n        tr.insertText(text, from, to).addMark(from, from + text.length, mark);\n      } else {\n        tr.setSelection(TextSelection.create(tr.doc, to)).addMark(\n          from,\n          to,\n          mark,\n        );\n      }\n    });\n  }\n}\n","import { Fragment, Schema, Slice } from \"@tiptap/pm/model\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { getBlockInfoFromSelection } from \"../api/getBlockInfoFromPos.js\";\n\n// helper function to remove a child from a fragment\nfunction removeChild(node: Fragment, n: number) {\n  const children: any[] = [];\n  node.forEach((child, _, i) => {\n    if (i !== n) {\n      children.push(child);\n    }\n  });\n  return Fragment.from(children);\n}\n\n/**\n * Wrap adjacent tableRow items in a table.\n *\n * This makes sure the content that we paste is always a table (and not a tableRow)\n * A table works better for the remaing paste handling logic, as it's actually a blockContent node\n */\nexport function wrapTableRows(f: Fragment, schema: Schema) {\n  const newItems: any[] = [];\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.name === \"tableRow\") {\n      if (\n        newItems.length > 0 &&\n        newItems[newItems.length - 1].type.name === \"table\"\n      ) {\n        // append to existing table\n        const prevTable = newItems[newItems.length - 1];\n        const newTable = prevTable.copy(prevTable.content.addToEnd(f.child(i)));\n        newItems[newItems.length - 1] = newTable;\n      } else {\n        // create new table to wrap tableRow with\n        const newTable = schema.nodes.table.createChecked(\n          undefined,\n          f.child(i),\n        );\n        newItems.push(newTable);\n      }\n    } else {\n      newItems.push(f.child(i));\n    }\n  }\n  f = Fragment.from(newItems);\n  return f;\n}\n\n/**\n * fix for https://github.com/ProseMirror/prosemirror/issues/1430#issuecomment-1822570821\n *\n * This fix wraps pasted ProseMirror nodes in their own `blockContainer` nodes\n * in most cases. This is to ensure that ProseMirror inserts them as separate\n * blocks, which it sometimes doesn't do because it doesn't have enough context\n * about the hierarchy of the pasted nodes. The issue can be seen when pasting\n * e.g. an image or two consecutive paragraphs, where PM tries to nest the\n * pasted block(s) when it shouldn't.\n *\n * However, the fix is not applied in a few cases. See `shouldApplyFix` for\n * which cases are excluded.\n */\nexport function transformPasted(slice: Slice, view: EditorView) {\n  let f = Fragment.from(slice.content);\n  f = wrapTableRows(f, view.state.schema);\n\n  if (!shouldApplyFix(f, view)) {\n    // Don't apply the fix.\n    return new Slice(f, slice.openStart, slice.openEnd);\n  }\n\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.spec.group === \"blockContent\") {\n      const content = [f.child(i)];\n\n      // when there is a blockGroup with lists, it should be nested in the new blockcontainer\n      // (if we remove this if-block, the nesting bug will be fixed, but lists won't be nested correctly)\n      if (\n        i + 1 < f.childCount &&\n        f.child(i + 1).type.name === \"blockGroup\" // TODO\n      ) {\n        const nestedChild = f\n          .child(i + 1)\n          .child(0)\n          .child(0);\n\n        if (\n          nestedChild.type.name === \"bulletListItem\" ||\n          nestedChild.type.name === \"numberedListItem\" ||\n          nestedChild.type.name === \"checkListItem\"\n        ) {\n          content.push(f.child(i + 1));\n          f = removeChild(f, i + 1);\n        }\n      }\n      const container = view.state.schema.nodes.blockContainer.createChecked(\n        undefined,\n        content,\n      );\n      f = f.replaceChild(i, container);\n    }\n  }\n  return new Slice(f, slice.openStart, slice.openEnd);\n}\n\n/**\n * Used in `transformPasted` to check if the fix there should be applied, i.e.\n * if the pasted fragment should be wrapped in a `blockContainer` node. This\n * will explicitly tell ProseMirror to treat it as a separate block.\n */\nfunction shouldApplyFix(fragment: Fragment, view: EditorView) {\n  const nodeHasSingleChild = fragment.childCount === 1;\n  const nodeHasInlineContent =\n    fragment.firstChild?.type.spec.content === \"inline*\";\n  const nodeHasTableContent =\n    fragment.firstChild?.type.spec.content === \"tableRow+\";\n\n  if (nodeHasSingleChild) {\n    if (nodeHasInlineContent) {\n      // Case when we paste a single node with inline content, e.g. a paragraph\n      // or heading. We want to insert the content in-line for better UX instead\n      // of a separate block, so we return false.\n      return false;\n    }\n\n    if (nodeHasTableContent) {\n      // Not ideal that we check selection here, as `transformPasted` is called\n      // for both paste and drop events. Drop events can potentially cause\n      // issues as they don't always happen at the current selection.\n      const blockInfo = getBlockInfoFromSelection(view.state);\n      if (blockInfo.isBlockContainer) {\n        const selectedBlockHasTableContent =\n          blockInfo.blockContent.node.type.spec.content === \"tableRow+\";\n\n        // Case for when we paste a single node with table content, i.e. a\n        // table. Normally, we return true as we want to ensure the table is\n        // inserted as a separate block. However, if the selection is in an\n        // existing table, we return false, as we want the content of the pasted\n        // table to be added to the existing one for better UX.\n        return !selectedBlockHasTableContent;\n      }\n    }\n  }\n\n  return true;\n}\n","import {\n  createDocument,\n  EditorOptions,\n  FocusPosition,\n  getSchema,\n  Editor as TiptapEditor,\n} from \"@tiptap/core\";\nimport { type Command, type Plugin, type Transaction } from \"@tiptap/pm/state\";\nimport { Node, Schema } from \"prosemirror-model\";\nimport * as Y from \"yjs\";\n\nimport type { BlocksChanged } from \"../api/getBlocksChangedByTransaction.js\";\nimport { blockToNode } from \"../api/nodeConversions/blockToNode.js\";\nimport {\n  Block,\n  BlockNoteSchema,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../blocks/index.js\";\nimport { UniqueID } from \"../extensions/tiptap-extensions/UniqueID/UniqueID.js\";\nimport type { Dictionary } from \"../i18n/dictionary.js\";\nimport { en } from \"../i18n/locales/index.js\";\nimport type {\n  BlockIdentifier,\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialInlineContent,\n  Styles,\n  StyleSchema,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport \"../style.css\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\nimport { EventEmitter } from \"../util/EventEmitter.js\";\nimport type { NoInfer } from \"../util/typescript.js\";\nimport { ExtensionFactoryInstance } from \"./BlockNoteExtension.js\";\nimport type { TextCursorPosition } from \"./cursorPositionTypes.js\";\nimport {\n  BlockManager,\n  EventManager,\n  ExportManager,\n  ExtensionManager,\n  SelectionManager,\n  StateManager,\n  StyleManager,\n} from \"./managers/index.js\";\nimport type { Selection } from \"./selectionTypes.js\";\nimport { transformPasted } from \"./transformPasted.js\";\n\nexport type BlockCache<\n  BSchema extends BlockSchema = any,\n  ISchema extends InlineContentSchema = any,\n  SSchema extends StyleSchema = any,\n> = WeakMap<Node, Block<BSchema, ISchema, SSchema>>;\n\nexport interface BlockNoteEditorOptions<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> {\n  /**\n   * Whether changes to blocks (like indentation, creating lists, changing headings) should be animated or not. Defaults to `true`.\n   *\n   * @default true\n   */\n  animations?: boolean;\n\n  /**\n   * Whether the editor should be focused automatically when it's created.\n   *\n   * @default false\n   */\n  autofocus?: FocusPosition;\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   * See [Real-time Collaboration](https://www.blocknotejs.org/docs/advanced/real-time-collaboration) for more info.\n   *\n   * @remarks `CollaborationOptions`\n   */\n  collaboration?: {\n    /**\n     * The Yjs XML fragment that's used for collaboration.\n     */\n    fragment: Y.XmlFragment;\n    /**\n     * The user info for the current user that's shown to other collaborators.\n     */\n    user: {\n      name: string;\n      color: string;\n    };\n    /**\n     * A Yjs provider (used for awareness / cursor information)\n     */\n    provider: any;\n    /**\n     * Optional function to customize how cursors of users are rendered\n     */\n    renderCursor?: (user: any) => HTMLElement;\n    /**\n     * Optional flag to set when the user label should be shown with the default\n     * collaboration cursor. Setting to \"always\" will always show the label,\n     * while \"activity\" will only show the label when the user moves the cursor\n     * or types. Defaults to \"activity\".\n     */\n    showCursorLabels?: \"always\" | \"activity\";\n  };\n\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles?: boolean;\n\n  /**\n   * A dictionary object containing translations for the editor.\n   *\n   * See [Localization / i18n](https://www.blocknotejs.org/docs/advanced/localization) for more info.\n   *\n   * @remarks `Dictionary` is a type that contains all the translations for the editor.\n   */\n  dictionary?: Dictionary & Record<string, any>;\n\n  /**\n   * Disable internal extensions (based on keys / extension name)\n   *\n   * @note Advanced\n   */\n  disableExtensions?: string[];\n\n  /**\n   * An object containing attributes that should be added to HTML elements of the editor.\n   *\n   * See [Adding DOM Attributes](https://www.blocknotejs.org/docs/theming#adding-dom-attributes) for more info.\n   *\n   * @example { editor: { class: \"my-editor-class\" } }\n   * @remarks `Record<string, Record<string, string>>`\n   */\n  domAttributes?: Partial<BlockNoteDOMAttributes>;\n\n  /**\n   * A replacement indicator to use when dragging and dropping blocks. Uses the [ProseMirror drop cursor](https://github.com/ProseMirror/prosemirror-dropcursor), or a modified version when [Column Blocks](https://www.blocknotejs.org/docs/document-structure#column-blocks) are enabled.\n   * @remarks `() => Plugin`\n   */\n  dropCursor?: (opts: {\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    color?: string | false;\n    width?: number;\n    class?: string;\n  }) => Plugin;\n\n  /**\n   * The content that should be in the editor when it's created, represented as an array of {@link PartialBlock} objects.\n   *\n   * See [Partial Blocks](https://www.blocknotejs.org/docs/editor-api/manipulating-blocks#partial-blocks) for more info.\n   *\n   * @remarks `PartialBlock[]`\n   */\n  initialContent?: PartialBlock<\n    NoInfer<BSchema>,\n    NoInfer<ISchema>,\n    NoInfer<SSchema>\n  >[];\n\n  /**\n   * @deprecated, provide placeholders via dictionary instead\n   * @internal\n   */\n  placeholders?: Record<\n    string | \"default\" | \"emptyDocument\",\n    string | undefined\n  >;\n\n  /**\n   * Custom paste handler that can be used to override the default paste behavior.\n   *\n   * See [Paste Handling](https://www.blocknotejs.org/docs/advanced/paste-handling) for more info.\n   *\n   * @remarks `PasteHandler`\n   * @returns The function should return `true` if the paste event was handled, otherwise it should return `false` if it should be canceled or `undefined` if it should be handled by another handler.\n   *\n   * @example\n   * ```ts\n   * pasteHandler: ({ defaultPasteHandler }) => {\n   *   return defaultPasteHandler({ pasteBehavior: \"prefer-html\" });\n   * }\n   * ```\n   */\n  pasteHandler?: (context: {\n    event: ClipboardEvent;\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    /**\n     * The default paste handler\n     * @param context The context object\n     * @returns Whether the paste event was handled or not\n     */\n    defaultPasteHandler: (context?: {\n      /**\n       * Whether to prioritize Markdown content in `text/plain` over `text/html` when pasting from the clipboard.\n       * @default true\n       */\n      prioritizeMarkdownOverHTML?: boolean;\n      /**\n       * Whether to parse `text/plain` content from the clipboard as Markdown content.\n       * @default true\n       */\n      plainTextAsMarkdown?: boolean;\n    }) => boolean | undefined;\n  }) => boolean | undefined;\n\n  /**\n   * Resolve a URL of a file block to one that can be displayed or downloaded. This can be used for creating authenticated URL or\n   * implementing custom protocols / schemes\n   * @returns The URL that's\n   */\n  resolveFileUrl?: (url: string) => Promise<string>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   *\n   * See [Custom Schemas](https://www.blocknotejs.org/docs/custom-schemas) for more info.\n   * @remarks `BlockNoteSchema`\n   */\n  schema: CustomBlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  /**\n   * A flag indicating whether to set an HTML ID for every block\n   *\n   * When set to `true`, on each block an id attribute will be set with the block id\n   * Otherwise, the HTML ID attribute will not be set.\n   *\n   * (note that the id is always set on the `data-id` attribute)\n   */\n  setIdAttribute?: boolean;\n\n  /**\n   * Determines behavior when pressing Tab (or Shift-Tab) while multiple blocks are selected and a toolbar is open.\n   * - `\"prefer-navigate-ui\"`: Changes focus to the toolbar. User must press Escape to close toolbar before indenting blocks. Better for keyboard accessibility.\n   * - `\"prefer-indent\"`: Always indents selected blocks, regardless of toolbar state. Keyboard navigation of toolbars not possible.\n   * @default \"prefer-navigate-ui\"\n   */\n  tabBehavior?: \"prefer-navigate-ui\" | \"prefer-indent\";\n\n  /**\n   * Allows enabling / disabling features of tables.\n   *\n   * See [Tables](https://www.blocknotejs.org/docs/editor-basics/document-structure#tables) for more info.\n   *\n   * @remarks `TableConfig`\n   */\n  tables?: {\n    /**\n     * Whether to allow splitting and merging cells within a table.\n     *\n     * @default false\n     */\n    splitCells?: boolean;\n    /**\n     * Whether to allow changing the background color of cells.\n     *\n     * @default false\n     */\n    cellBackgroundColor?: boolean;\n    /**\n     * Whether to allow changing the text color of cells.\n     *\n     * @default false\n     */\n    cellTextColor?: boolean;\n    /**\n     * Whether to allow changing cells into headers.\n     *\n     * @default false\n     */\n    headers?: boolean;\n  };\n\n  /**\n   * An option which user can pass with `false` value to disable the automatic creation of a trailing new block on the next line when the user types or edits any block.\n   *\n   * @default true\n   */\n  trailingBlock?: boolean;\n\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   * @remarks `(file: File) => Promise<UploadFileResult>`\n   */\n  uploadFile?: (\n    file: File,\n    blockId?: string,\n  ) => Promise<string | Record<string, any>>;\n\n  /**\n   * additional tiptap options, undocumented\n   * @internal\n   */\n  _tiptapOptions?: Partial<EditorOptions>;\n\n  /**\n   * Register extensions to the editor.\n   *\n   * See [Extensions](/docs/features/extensions) for more info.\n   *\n   * @remarks `ExtensionFactory[]`\n   */\n  extensions?: Array<ExtensionFactoryInstance>;\n}\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> extends EventEmitter<{\n  create: void;\n}> {\n  /**\n   * The underlying prosemirror schema\n   */\n  public readonly pmSchema: Schema;\n\n  public readonly _tiptapEditor: TiptapEditor & {\n    contentComponent: any;\n  };\n\n  /**\n   * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements\n   * in the correct context (used by `ReactRenderUtil`)\n   */\n  public elementRenderer: ((node: any, container: HTMLElement) => void) | null =\n    null;\n\n  /**\n   * Cache of all blocks. This makes sure we don't have to \"recompute\" blocks if underlying Prosemirror Nodes haven't changed.\n   * This is especially useful when we want to keep track of the same block across multiple operations,\n   * with this cache, blocks stay the same object reference (referential equality with ===).\n   */\n  public blockCache: BlockCache = new WeakMap();\n\n  /**\n   * The dictionary contains translations for the editor.\n   */\n  public readonly dictionary: Dictionary & Record<string, any>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   */\n  public readonly schema: BlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  public readonly blockImplementations: BlockSpecs;\n  public readonly inlineContentImplementations: InlineContentSpecs;\n  public readonly styleImplementations: StyleSpecs;\n\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   */\n  public readonly uploadFile:\n    | ((file: File, blockId?: string) => Promise<string | Record<string, any>>)\n    | undefined;\n\n  private onUploadStartCallbacks: ((blockId?: string) => void)[] = [];\n  private onUploadEndCallbacks: ((blockId?: string) => void)[] = [];\n\n  public readonly resolveFileUrl?: (url: string) => Promise<string>;\n  /**\n   * Editor settings\n   */\n  public readonly settings: {\n    tables: {\n      splitCells: boolean;\n      cellBackgroundColor: boolean;\n      cellTextColor: boolean;\n      headers: boolean;\n    };\n  };\n  public static create<\n    Options extends Partial<BlockNoteEditorOptions<any, any, any>> | undefined,\n  >(\n    options?: Options,\n  ): Options extends {\n    schema: CustomBlockNoteSchema<infer BSchema, infer ISchema, infer SSchema>;\n  }\n    ? BlockNoteEditor<BSchema, ISchema, SSchema>\n    : BlockNoteEditor<\n        DefaultBlockSchema,\n        DefaultInlineContentSchema,\n        DefaultStyleSchema\n      > {\n    return new BlockNoteEditor(options ?? {}) as any;\n  }\n\n  protected constructor(\n    protected readonly options: Partial<\n      BlockNoteEditorOptions<BSchema, ISchema, SSchema>\n    >,\n  ) {\n    super();\n\n    this.dictionary = options.dictionary || en;\n    this.settings = {\n      tables: {\n        splitCells: options?.tables?.splitCells ?? false,\n        cellBackgroundColor: options?.tables?.cellBackgroundColor ?? false,\n        cellTextColor: options?.tables?.cellTextColor ?? false,\n        headers: options?.tables?.headers ?? false,\n      },\n    };\n\n    // apply defaults\n    const newOptions = {\n      defaultStyles: true,\n      schema:\n        options.schema ||\n        (BlockNoteSchema.create() as unknown as CustomBlockNoteSchema<\n          BSchema,\n          ISchema,\n          SSchema\n        >),\n      ...options,\n      placeholders: {\n        ...this.dictionary.placeholders,\n        ...options.placeholders,\n      },\n    };\n\n    // @ts-ignore\n    this.schema = newOptions.schema;\n    this.blockImplementations = newOptions.schema.blockSpecs;\n    this.inlineContentImplementations = newOptions.schema.inlineContentSpecs;\n    this.styleImplementations = newOptions.schema.styleSpecs;\n\n    // TODO this should just be an extension\n    if (newOptions.uploadFile) {\n      const uploadFile = newOptions.uploadFile;\n      this.uploadFile = async (file, blockId) => {\n        this.onUploadStartCallbacks.forEach((callback) =>\n          callback.apply(this, [blockId]),\n        );\n        try {\n          return await uploadFile(file, blockId);\n        } finally {\n          this.onUploadEndCallbacks.forEach((callback) =>\n            callback.apply(this, [blockId]),\n          );\n        }\n      };\n    }\n\n    this.resolveFileUrl = newOptions.resolveFileUrl;\n\n    this._eventManager = new EventManager(this as any);\n    this._extensionManager = new ExtensionManager(this, newOptions);\n\n    const tiptapExtensions = this._extensionManager.getTiptapExtensions();\n\n    const collaborationEnabled =\n      this._extensionManager.hasExtension(\"ySync\") ||\n      this._extensionManager.hasExtension(\"liveblocksExtension\");\n\n    if (collaborationEnabled && newOptions.initialContent) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\",\n      );\n    }\n\n    const tiptapOptions: EditorOptions = {\n      ...blockNoteTipTapOptions,\n      ...newOptions._tiptapOptions,\n      element: null,\n      autofocus: newOptions.autofocus ?? false,\n      extensions: tiptapExtensions,\n      editorProps: {\n        ...newOptions._tiptapOptions?.editorProps,\n        attributes: {\n          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not\n          // editable, so you can't focus it. We want to revert this as we have\n          // UI behaviour that relies on it.\n          tabIndex: \"0\",\n          ...newOptions._tiptapOptions?.editorProps?.attributes,\n          ...newOptions.domAttributes?.editor,\n          class: mergeCSSClasses(\n            \"bn-editor\",\n            newOptions.defaultStyles ? \"bn-default-styles\" : \"\",\n            newOptions.domAttributes?.editor?.class || \"\",\n          ),\n        },\n        transformPasted,\n      },\n    } as any;\n\n    try {\n      const initialContent =\n        newOptions.initialContent ||\n        (collaborationEnabled\n          ? [\n              {\n                type: \"paragraph\",\n                id: \"initialBlockId\",\n              },\n            ]\n          : [\n              {\n                type: \"paragraph\",\n                id: UniqueID.options.generateID(),\n              },\n            ]);\n\n      if (!Array.isArray(initialContent) || initialContent.length === 0) {\n        throw new Error(\n          \"initialContent must be a non-empty array of blocks, received: \" +\n            initialContent,\n        );\n      }\n      const schema = getSchema(tiptapOptions.extensions!);\n      const pmNodes = initialContent.map((b) =>\n        blockToNode(b, schema, this.schema.styleSchema).toJSON(),\n      );\n      const doc = createDocument(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: pmNodes,\n            },\n          ],\n        },\n        schema,\n        tiptapOptions.parseOptions,\n      );\n\n      this._tiptapEditor = new TiptapEditor({\n        ...tiptapOptions,\n        content: doc.toJSON(),\n      }) as any;\n      this.pmSchema = this._tiptapEditor.schema;\n    } catch (e) {\n      throw new Error(\n        \"Error creating document from blocks passed as `initialContent`\",\n        { cause: e },\n      );\n    }\n\n    // When y-prosemirror creates an empty document, the `blockContainer` node is created with an `id` of `null`.\n    // This causes the unique id extension to generate a new id for the initial block, which is not what we want\n    // Since it will be randomly generated & cause there to be more updates to the ydoc\n    // This is a hack to make it so that anytime `schema.doc.createAndFill` is called, the initial block id is already set to \"initialBlockId\"\n    let cache: Node | undefined = undefined;\n    const oldCreateAndFill = this.pmSchema.nodes.doc.createAndFill;\n    this.pmSchema.nodes.doc.createAndFill = (...args: any) => {\n      if (cache) {\n        return cache;\n      }\n      const ret = oldCreateAndFill.apply(this.pmSchema.nodes.doc, args)!;\n\n      // create a copy that we can mutate (otherwise, assigning attrs is not safe and corrupts the pm state)\n      const jsonNode = JSON.parse(JSON.stringify(ret.toJSON()));\n      jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n\n      cache = Node.fromJSON(this.pmSchema, jsonNode);\n      return cache;\n    };\n    this.pmSchema.cached.blockNoteEditor = this;\n\n    // Initialize managers\n    this._blockManager = new BlockManager(this as any);\n\n    this._exportManager = new ExportManager(this as any);\n    this._selectionManager = new SelectionManager(this as any);\n    this._stateManager = new StateManager(this as any);\n    this._styleManager = new StyleManager(this as any);\n\n    this.emit(\"create\");\n  }\n\n  // Manager instances\n  private readonly _blockManager: BlockManager<any, any, any>;\n  private readonly _eventManager: EventManager<any, any, any>;\n  private readonly _exportManager: ExportManager<any, any, any>;\n  private readonly _extensionManager: ExtensionManager;\n  private readonly _selectionManager: SelectionManager<any, any, any>;\n  private readonly _stateManager: StateManager;\n  private readonly _styleManager: StyleManager<any, any, any>;\n\n  /**\n   * BlockNote extensions that are added to the editor, keyed by the extension key\n   */\n  public get extensions() {\n    return this._extensionManager.getExtensions();\n  }\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    return this._stateManager.exec(command);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    return this._stateManager.canExec(command);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    return this._stateManager.transact(callback);\n  }\n\n  /**\n   * Remove extension(s) from the editor\n   */\n  public unregisterExtension: ExtensionManager[\"unregisterExtension\"] = (\n    ...args: Parameters<ExtensionManager[\"unregisterExtension\"]>\n  ) => this._extensionManager.unregisterExtension(...args);\n\n  /**\n   * Register extension(s) to the editor\n   */\n  public registerExtension: ExtensionManager[\"registerExtension\"] = (\n    ...args: Parameters<ExtensionManager[\"registerExtension\"]>\n  ) => this._extensionManager.registerExtension(...args) as any;\n\n  /**\n   * Get an extension from the editor\n   */\n  public getExtension: ExtensionManager[\"getExtension\"] = ((\n    ...args: Parameters<ExtensionManager[\"getExtension\"]>\n  ) => this._extensionManager.getExtension(...args)) as any;\n\n  /**\n   * Mount the editor to a DOM element.\n   *\n   * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting\n   */\n  public mount = (element: HTMLElement) => {\n    this._tiptapEditor.mount({ mount: element });\n  };\n\n  /**\n   * Unmount the editor from the DOM element it is bound to\n   */\n  public unmount = () => {\n    this._tiptapEditor.unmount();\n  };\n\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    return this._stateManager.prosemirrorState;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this._stateManager.prosemirrorView;\n  }\n\n  public get domElement() {\n    if (this.headless) {\n      return undefined;\n    }\n    return this.prosemirrorView?.dom as HTMLDivElement | undefined;\n  }\n\n  public isFocused() {\n    if (this.headless) {\n      return false;\n    }\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public get headless() {\n    return !this._tiptapEditor.isInitialized;\n  }\n\n  /**\n   * Focus on the editor\n   */\n  public focus() {\n    if (this.headless) {\n      return;\n    }\n    this.prosemirrorView.focus();\n  }\n\n  /**\n   * Blur the editor\n   */\n  public blur() {\n    if (this.headless) {\n      return;\n    }\n    this.prosemirrorView.dom.blur();\n  }\n\n  // TODO move to extension\n  public onUploadStart(callback: (blockId?: string) => void) {\n    this.onUploadStartCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadStartCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadStartCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  public onUploadEnd(callback: (blockId?: string) => void) {\n    this.onUploadEndCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadEndCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadEndCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  public get topLevelBlocks(): Block<BSchema, ISchema, SSchema>[] {\n    return this.document;\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this._blockManager.document;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getPrevBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getNextBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getParentBlock(blockIdentifier);\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    this._blockManager.forEachBlock(callback, reverse);\n  }\n\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use {@link BlockNoteEditor.onChange} instead\n   */\n  public onEditorContentChange(callback: () => void) {\n    this._tiptapEditor.on(\"update\", callback);\n  }\n\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use `onSelectionChange` instead\n   */\n  public onEditorSelectionChange(callback: () => void) {\n    this._tiptapEditor.on(\"selectionUpdate\", callback);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this._selectionManager.getTextCursorPosition();\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this._selectionManager.setTextCursorPosition(targetBlock, placement);\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this._selectionManager.getSelection();\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks() {\n    return this._selectionManager.getSelectionCutBlocks();\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this._selectionManager.setSelection(startBlock, endBlock);\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._stateManager.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    this._stateManager.isEditable = editable;\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this._blockManager.insertBlocks(\n      blocksToInsert,\n      referenceBlock,\n      placement,\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this._blockManager.updateBlock(blockToUpdate, update);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this._blockManager.removeBlocks(blocksToRemove);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this._blockManager.replaceBlocks(blocksToRemove, blocksToInsert);\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo(): boolean {\n    return this._stateManager.undo();\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo(): boolean {\n    return this._stateManager.redo();\n  }\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    this._styleManager.insertInlineContent(content, { updateSelection });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles(): Styles<SSchema> {\n    return this._styleManager.getActiveStyles();\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    this._styleManager.addStyles(styles);\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    this._styleManager.removeStyles(styles);\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    this._styleManager.toggleStyles(styles);\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._styleManager.getSelectedText();\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._styleManager.getSelectedLinkUrl();\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    this._styleManager.createLink(url, text);\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return this._blockManager.canNestBlock();\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._blockManager.nestBlock();\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return this._blockManager.canUnnestBlock();\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._blockManager.unnestBlock();\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return this._blockManager.moveBlocksUp();\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return this._blockManager.moveBlocksDown();\n  }\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToHTMLLossy(blocks);\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToFullHTML(blocks);\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseHTMLToBlocks(html);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToMarkdownLossy(blocks);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseMarkdownToBlocks(markdown);\n  }\n\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onChange(\n    callback: (\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n      context: {\n        /**\n         * Returns the blocks that were inserted, updated, or deleted by the change that occurred.\n         */\n        getChanges(): BlocksChanged<BSchema, ISchema, SSchema>;\n      },\n    ) => void,\n    /**\n     * If true, the callback will be triggered when the changes are caused by a remote user\n     * @default true\n     */\n    includeUpdatesFromRemote?: boolean,\n  ) {\n    return this._eventManager.onChange(callback, includeUpdatesFromRemote);\n  }\n\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void,\n    includeSelectionChangedByRemote?: boolean,\n  ) {\n    return this._eventManager.onSelectionChange(\n      callback,\n      includeSelectionChangedByRemote,\n    );\n  }\n\n  /**\n   * A callback function that runs when the editor has been mounted.\n   *\n   * This can be useful for plugins to initialize themselves after the editor has been mounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onMount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onMount(callback);\n  }\n\n  /**\n   * A callback function that runs when the editor has been unmounted.\n   *\n   * This can be useful for plugins to clean up themselves after the editor has been unmounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onUnmount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onUnmount(callback);\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   * @returns The bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    return this._selectionManager.getSelectionBoundingBox();\n  }\n\n  public get isEmpty() {\n    const doc = this.document;\n    // Note: only works for paragraphs as default blocks (but for now this is default in blocknote)\n    // checking prosemirror directly might be faster\n    return (\n      doc.length === 0 ||\n      (doc.length === 1 &&\n        doc[0].type === \"paragraph\" &&\n        (doc[0].content as any).length === 0)\n    );\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    this._exportManager.pasteHTML(html, raw);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this._exportManager.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    return this._exportManager.pasteMarkdown(markdown);\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport {\n  BlockFromConfig,\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n  StyledText,\n  Styles,\n} from \"../schema/index.js\";\n\nimport type {\n  BlockMapping,\n  InlineContentMapping,\n  StyleMapping,\n} from \"./mapping.js\";\n\nexport type ExporterOptions = {\n  /**\n   * A function that can be used to resolve files, images, etc.\n   * Exporters might need the binary contents of files like images,\n   * which might not always be available from the same origin as the main page.\n   * You can use this option to proxy requests through a server you control\n   * to avoid cross-origin (CORS) issues.\n   *\n   * @default uses a BlockNote hosted proxy (https://corsproxy.api.blocknotejs.org/)\n   * @param url - The URL of the file to resolve\n   * @returns A Promise that resolves to a string (the URL to use instead of the original)\n   * or a Blob (you can return the Blob directly if you have already fetched it)\n   */\n  resolveFileUrl?: (url: string) => Promise<string | Blob>;\n  /**\n   * Colors to use for background of blocks, font colors, and highlight colors\n   */\n  colors: typeof COLORS_DEFAULT;\n};\nexport abstract class Exporter<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n  RS,\n  TS,\n> {\n  public constructor(\n    _schema: BlockNoteSchema<B, I, S>, // only used for type inference\n    protected readonly mappings: {\n      blockMapping: BlockMapping<B, I, S, RB, RI>;\n      inlineContentMapping: InlineContentMapping<I, S, RI, TS>;\n      styleMapping: StyleMapping<S, RS>;\n    },\n    public readonly options: ExporterOptions,\n  ) {}\n\n  public async resolveFile(url: string) {\n    if (!this.options?.resolveFileUrl) {\n      return (await fetch(url)).blob();\n    }\n    const ret = await this.options.resolveFileUrl(url);\n    if (ret instanceof Blob) {\n      return ret;\n    }\n    return (await fetch(ret)).blob();\n  }\n\n  public mapStyles(styles: Styles<S>) {\n    const stylesArray = Object.entries(styles).map(([key, value]) => {\n      const mappedStyle = this.mappings.styleMapping[key](value, this);\n      return mappedStyle;\n    });\n    return stylesArray;\n  }\n\n  public mapInlineContent(inlineContent: InlineContent<I, S>) {\n    return this.mappings.inlineContentMapping[inlineContent.type](\n      inlineContent,\n      this,\n    );\n  }\n\n  public transformInlineContent(inlineContentArray: InlineContent<I, S>[]) {\n    return inlineContentArray.map((ic) => this.mapInlineContent(ic));\n  }\n\n  public abstract transformStyledText(styledText: StyledText<S>): TS;\n\n  public async mapBlock(\n    block: BlockFromConfig<B[keyof B], I, S>,\n    nestingLevel: number,\n    numberedListIndex: number,\n    children?: Array<Awaited<RB>>,\n  ) {\n    return this.mappings.blockMapping[block.type](\n      block,\n      this,\n      nestingLevel,\n      numberedListIndex,\n      children,\n    );\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchema,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n  Styles,\n} from \"../schema/index.js\";\nimport type { Exporter } from \"./Exporter.js\";\n\n/**\n * Defines a mapping from all block types with a schema to a result type `R`.\n */\nexport type BlockMapping<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n> = {\n  [K in keyof B]: (\n    block: BlockFromConfigNoChildren<B[K], I, S>,\n    // we don't know the exact types that are supported by the exporter at this point,\n    // because the mapping only knows about converting certain types (which might be a subset of the supported types)\n    // this is why there are many `any` types here (same for types below)\n    exporter: Exporter<any, any, any, RB, RI, any, any>,\n    nestingLevel: number,\n    numberedListIndex?: number,\n    children?: Array<Awaited<RB>>,\n  ) => RB | Promise<RB>;\n};\n\n/**\n * Defines a mapping from all inline content types with a schema to a result type R.\n */\nexport type InlineContentMapping<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RI,\n  TS,\n> = {\n  [K in keyof I]: (\n    inlineContent: InlineContentFromConfig<I[K], S>,\n    exporter: Exporter<any, I, S, any, RI, any, TS>,\n  ) => RI;\n};\n\n/**\n * Defines a mapping from all style types with a schema to a result type R.\n */\nexport type StyleMapping<S extends StyleSchema, RS> = {\n  [K in keyof S]: (\n    style: Styles<S>[K],\n    exporter: Exporter<any, any, any, any, any, RS, any>,\n  ) => RS;\n};\n\n/**\n * The mapping factory is a utility function to easily create mappings for\n * a BlockNoteSchema. Using the factory makes it easier to get typescript code completion etc.\n */\nexport function mappingFactory<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(_schema: BlockNoteSchema<B, I, S>) {\n  return {\n    createBlockMapping: <R, RI>(mapping: BlockMapping<B, I, S, R, RI>) =>\n      mapping,\n    createInlineContentMapping: <R, RS>(\n      mapping: InlineContentMapping<I, S, R, RS>,\n    ) => mapping,\n    createStyleMapping: <R>(mapping: StyleMapping<S, R>) => mapping,\n  };\n}\n","/**\n * Combines items by group. This can be used to combine multiple slash menu item arrays,\n * while making sure that items from the same group are adjacent to each other.\n */\nexport function combineByGroup<T extends { group?: string }>(\n  items: T[],\n  ...additionalItemsArray: {\n    group?: string;\n  }[][]\n) {\n  const combinedItems = [...items];\n  for (const additionalItems of additionalItemsArray) {\n    for (const additionalItem of additionalItems) {\n      const lastItemWithSameGroup = combinedItems.findLastIndex(\n        (item) => item.group === additionalItem.group,\n      );\n      if (lastItemWithSameGroup === -1) {\n        combinedItems.push(additionalItem as T);\n      } else {\n        combinedItems.splice(lastItemWithSameGroup + 1, 0, additionalItem as T);\n      }\n    }\n  }\n  return combinedItems;\n}\n"],"names":["getInlineContentParseRules","config","customParseFunction","rules","element","htmlElement","node","props","createInlineContentSpec","inlineContentConfig","inlineContentImplementation","Node","_a","propsToAttributes","addInlineContentKeyboardShortcuts","editor","output","nodeToCustomInlineContent","addInlineContentAttributes","getPos","update","content","inlineContentToNodes","pos","tr","createInlineContentSpecFromTipTapNode","inlineContent","updateInlineContent","insertBlocks","blocksToInsert","referenceBlock","placement","id","pmSchema","getPmSchema","nodesToInsert","block","blockToNode","posInfo","getNodeById","ReplaceStep","Slice","Fragment","nodeToBlock","isEmptyColumn","column","blockContainer","blockContent","removeEmptyColumns","columnListPos","$columnListPos","columnList","columnIndex","columnPos","fixColumnList","firstColumnBeforePos","firstColumn","lastColumnAfterPos","lastColumn","firstColumnEmpty","lastColumnEmpty","ReplaceAroundStep","removeAndInsertBlocks","blocksToRemove","idsOfBlocksToRemove","removedBlocks","columnListPositions","idOfFirstBlock","removedSize","oldDocSize","newDocSize","$pos","notFoundIds","serializeInlineContentInternalHTML","serializer","blockType","options","nodes","tableContentToNodes","UnreachableCaseError","fragment","contentFragment","dom","mark","newDom","domOutputSpec","DOMSerializer","nodeFragment","serializeBlock","BC_NODE","name","spec","children","ret","ic","serializeBlocks","bc","_c","_b","_d","_e","serializeBlocksInternalHTML","blocks","blockDOM","BG_NODE","bg","createInternalHTMLSerializer","schema","getBlockSelectionData","anchorBlockPosInfo","getNearestBlockPos","CellSelection","NodeSelection","headBlockPosInfo","updateBlockSelectionFromData","data","anchorBlockPos","selection","headBlockPos","TextSelection","flattenColumns","moveSelectedBlocksAndSelection","selectionData","checkPlacementIsValid","parentBlock","getMoveUpPlacement","prevBlock","referenceBlockParent","getMoveDownPlacement","nextBlock","moveBlocksUp","moveUpPlacement","moveBlocksDown","moveDownPlacement","sinkListItem","itemType","groupType","$from","$to","range","startIndex","nodeBefore","nestedBefore","inner","slice","before","after","nestBlock","unnestBlock","canNestBlock","getBlockInfoFromTransaction","canUnnestBlock","getBlock","doc","blockIdentifier","getPrevBlock","nodeToConvert","getNextBlock","getParentBlock","$posBeforeNode","parentNode","grandparentNode","BlockManager","docToBlocks","callback","reverse","traverseBlockArray","blockArray","blockToUpdate","updateBlock","EventManager","EventEmitter","transaction","appendedTransactions","includeUpdatesFromRemote","cb","isRemoteTransaction","getBlocksChangedByTransaction","includeSelectionChangedByRemote","e","getChildIndex","isWhitespaceNode","liftNestedListsToParent","list","index","parentListItem","siblingsAfter","sibling","siblingContainer","createGroups","listItem","blockGroup","_detachedDoc","detachedDoc","nestedListsToBlockNoteStructure","elementOrHTML","HTMLToBlocks","html","htmlNode","DOMParser","i","code","state","value","properties","result","video","url","title","markdownToHTML","markdown","unified","remarkParse","remarkGfm","remarkRehype","remarkRehypeDefaultHandlers","isVideoUrl","rehypeStringify","markdownToBlocks","htmlString","ExportManager","createExternalHTMLExporter","blocksToMarkdown","raw","htmlToPaste","text","acceptedMIMETypes","checkFileExtensionsMatch","fileExtension1","fileExtension2","checkMIMETypesMatch","mimeType1","mimeType2","types1","types2","insertOrUpdateBlock","newBlock","insertedBlockId","handleFileInsertion","event","dataTransfer","format","mimeType","items","fileBlockType","blockSpec","isFileExtension","file","fileBlock","currentBlock","coords","blockElement","blockRect","updateData","updatedFileBlock","createDropFileExtension","Extension","Plugin","_view","h1","bold","link","ul","ol","hr","fences","blockquote","tableHeader","tableDivider","tableRow","isMarkdown","src","handleVSCodePaste","view","vscode","vscodeData","language","defaultPasteHandler","prioritizeMarkdownOverHTML","plainTextAsMarkdown","plainText","createPasteFromClipboardExtension","pasteHandler","fragmentToExternalHTML","selectedFragment","isWithinBlockContent","isWithinTable","fragmentWithoutParents","child","externalHTML","externalHTMLExporter","contentNodeToTableContent","contentNodeToInlineContent","fragmentToBlocks","selectedFragmentToHTML","clipboardHTML","cleanHTMLToMarkdown","checkIfSelectionInNonEditableBlock","copyToClipboard","createCopyToClipboardExtension","BackgroundColorExtension","getBackgroundColorAttribute","HardBreak","HTMLAttributes","mergeAttributes","getPrevBlockInfo","beforePos","indexInParent","prevBlockBeforePos","getBlockInfoFromResolvedPos","getBottomNestedBlockInfo","blockInfo","group","newPos","canMerge","prevBlockInfo","nextBlockInfo","mergeBlocks","dispatch","childBlocksStart","childBlocksEnd","childBlocksRange","mergeBlocksCommand","posBetweenBlocks","bottomNestedBlockInfo","KeyboardShortcutsExtension","handleBackspace","chain","commands","getBlockInfoFromSelection","selectionAtBlockStart","isParagraph","updateBlockCommand","selectionEmpty","$blockPos","$columnPos","chainedCommands","lastCellParagraphEndPos","nonEditableBlockContentStartPos","blockContentStartPos","bottomBlock","handleDelete","childContainer","depth","blockAtDocEnd","selectionAtBlockEnd","oldDepth","newDepth","handleEnter","withShift","blockEmpty","blockIndented","blockHardBreakShortcut","marks","m","newBlockInsertionPos","newBlockContentPos","splitBlockCommand","FormattingToolbarExtension","FilePanelExtension","SuggestionAddMark","Mark","extension","inline","SuggestionDeleteMark","SuggestionModificationMark","TextAlignmentExtension","attributes","TextColorExtension","getTextColorAttribute","BlockAttributes","BlockContainer","attrs","nodeAttr","HTMLAttr","blockOuter","attribute","blockHTMLAttributes","mergeCSSClasses","BlockGroup","blockGroupHTMLAttributes","Doc","LINKIFY_INITIALIZED","getDefaultTiptapExtensions","tiptapExtensions","extensions","Gapcursor","UniqueID","Text","Link","DEFAULT_LINK_PROTOCOL","VALID_LINK_PROTOCOLS","styleSpec","TiptapExtension","SuggestionMenu","a","inlineContentSpec","context","getDefaultExtensions","BlockChangeExtension","DropCursorExtension","LinkToolbarExtension","NodeSelectionKeyboardExtension","PlaceholderExtension","ShowSelectionExtension","SideMenuExtension","TrailingNodeExtension","ForkYDocExtension","YCursorExtension","YSyncExtension","YUndoExtension","SchemaMigration","HistoryExtension","TableHandlesExtension","PreviousBlockTypeExtension","ExtensionManager","__publicField","abortController","unmountCallback","registeredExtensions","pluginsToAdd","plugin","plugins","instance","originalFactory","originalFactorySymbol","toResolve","toUnregister","didWarn","pluginsToRemove","factory","currentState","getPriority","sortByDependencies","inputRulesByPriority","priority","prosemirrorPlugins","inputRules","inputRulesPlugin","inputRule","InputRule","match","start","end","replaceWith","cursorPosition","updateBlockTr","keymap","key","getSelection","$startBlockBeforePos","$endBlockBeforePos","indexToBlock","sharedDepth","endIndex","startIndexAtDepth","childCountAtDepth","setSelection","startBlock","endBlock","startBlockId","endBlockId","getBlockNoteSchema","anchorPosInfo","headPosInfo","anchorBlockInfo","getBlockInfo","headBlockInfo","anchorBlockConfig","headBlockConfig","startPos","endPos","tableMap","TableMap","lastCellPos","lastCellNodeSize","getSelectionCutBlocks","selectionInfo","prosemirrorSliceToSlicedBlocks","getTextCursorPosition","bnBlock","resolvedPos","prevNode","nextNode","setTextCursorPosition","targetBlock","info","contentType","SelectionManager","ranges","from","to","isNodeSelection","posToDOMRect","StateManager","command","activeTr","editable","undoPlugin","historyPlugin","insertContentAt","position","isOnlyTextContent","isOnlyBlockContent","parent","selectionToInsertionEnd","StyleManager","updateSelection","styles","style","removeChild","n","_","wrapTableRows","f","newItems","prevTable","newTable","transformPasted","shouldApplyFix","nestedChild","container","nodeHasSingleChild","nodeHasInlineContent","nodeHasTableContent","blockNoteTipTapOptions","BlockNoteEditor","args","en","newOptions","BlockNoteSchema","uploadFile","blockId","collaborationEnabled","tiptapOptions","_g","_f","_h","_j","_i","initialContent","getSchema","pmNodes","b","createDocument","TiptapEditor","cache","oldCreateAndFill","jsonNode","Exporter","_schema","mappings","inlineContentArray","nestingLevel","numberedListIndex","mappingFactory","mapping","combineByGroup","additionalItemsArray","combinedItems","additionalItems","additionalItem","lastItemWithSameGroup","item"],"mappings":"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"}}]
}